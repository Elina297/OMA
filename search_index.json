[["index.html", "Orchestrating Microbiome Analysis Welcome", " Orchestrating Microbiome Analysis Authors: Leo Lahti [aut], Sudarshan Shetty [aut], Tuomas Borman [aut, cre], Felix GM Ernst [aut] Version: 0.98.10 Modified: 2022-10-05 Compiled: 2022-11-09 Environment: R version 4.2.1 (2022-06-23), Bioconductor 3.15 License: CC BY-NC-SA 3.0 US Copyright: Source: https://github.com/microbiome/OMA Welcome You are reading the online book, Orchestrating Microbiome Analysis with R and Bioconductor (Lahti et al. 2021), where we walk through common strategies and workflows in microbiome data science. The book shows through concrete examples how you can take advantage of the latest developments in R/Bioconductor for the manipulation, analysis, and reproducible reporting of hierarchical and heterogeneous microbiome profiling data sets. The book was borne out of necessity, while updating microbiome analysis tools to work with Bioconductor classes that provide support for multi-modal data collections. Many of these techniques are generic and widely applicable in other contexts as well. This work has been heavily influenced by other similar resources, in particular the Orchestrating Single-Cell Analysis with Bioconductor (R. A. Amezquita et al. 2020), phyloseq tutorials (Callahan2016?) and microbiome tutorials (Shetty and Lahti 2019). This book extends these resources to teach the grammar of Bioconductor workflows in the context of microbiome data science. As such, it supports the adoption of general skills in the analysis of large, hierarchical, and multi-modal data collections. We focus on microbiome analysis tools, including entirely new, partially updated as well as previously established methods. This online resource and its associated ecosystem of microbiome data science tools are a result of a community-driven development process, and welcoming new contributors. Several individuals have contributed methods, workflows and improvements as acknowledged in the Introduction. You can find more information on how to find us online and join the developer community through the project homepage at microbiome.github.io. This online resource has been written in RMarkdown with the bookdown R package. The material is free to use with the Creative Commons Attribution-NonCommercial 3.0 License. Bibliography "],["intro.html", "Chapter 1 Introduction", " Chapter 1 Introduction .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } This work - Orchestrating Microbiome Analysis with R and Bioconductor (Lahti et al. 2021) - contributes novel methods and educational resources for microbiome data science. It aims to teach the grammar of Bioconductor workflows in the context of microbiome data science. We show through concrete examples how to use the latest developments and data analytical strategies in R/Bioconductor for the manipulation, analysis, and reproducible reporting of hierarchical, heterogeneous, and multi-modal microbiome profiling data. The data science methodology is tightly integrated with the broader R/Bioconductor ecosystem that focuses on the development of of high-quality open research software for life sciences (Gentleman et al. (2004), Huber et al. (2015)). The support for modularity and interoperability is a key to efficient resource sharing and collaborative development both within and across research fields. The central data infrastructure, the SummarizedExperiment data container and its derivatives, have already been widely adopted in microbiome research, single cell sequencing, and in other fields, allowing a rapid adoption and extensions of emerging data science techniques across application domains. We assume that the reader is already familiar with R programming. For references and tips on introductory material for R and Bioconductor, see Chapter 15. This online resource and its associated ecosystem of microbiome data science tools are a result of a community-driven development process, and welcoming new users and contributors. You can find more information on how to find us online and join the developer community through the project homepage at microbiome.github.io. The book is organized into three parts. We start by introducing the material and link to further resources for learning R and Bioconductor. We describe the key data infrastructure, the TreeSummarizedExperiment class that provides a container for microbiome data, and how to get started by loading microbiome data set in the context of this new framework. The second section, Focus Topics, covers the common steps in microbiome data analysis, beginning with the most common steps and progressing to more specialized methods in subsequent sections. Third, Workflows, provides case studies for the various datasets used throughout the book. Finally, Appendix, links to further resources and acknowledgments. Bibliography "],["containers.html", "Chapter 2 Microbiome Data 2.1 Data science framework 2.2 Data containers 2.3 Loading experimental microbiome data 2.4 Demonstration data Session Info", " Chapter 2 Microbiome Data .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 2.1 Data science framework The building blocks of the framework are data container (SummarizedExperiment and its derivatives), packages from various developers using the TreeSE container, open demonstration data sets, in a separate chapter 2.4, and online tutorials including this online book as well as the various package vignettes and other material. 2.2 Data containers SummarizedExperiment (SE) is a generic and highly optimized container for complex data structures. It has become a common choice for analysing various types of biomedical profiling data, such as RNAseq, ChIp-Seq, microarrays, flow cytometry, proteomics, and single-cell sequencing. TreeSummarizedExperiment (TreeSE) was developed as an extension to incorporate hierarchical information (such as phylogenetic trees and sample hierarchies) and reference sequences. MultiAssayExperiment (MAE) provides an organized way to bind several different data structures together in a single object. For example, we can bind microbiome data (in TreeSE format) with metabolomic profiling data (in SE) format, with shared sample metadata. This is convenient and robust for instance in subsetting and other data manipulation tasks. Microbiome data can be part of multiomics experiments and analysis strategies and we want to outline the understanding in which we think the packages explained and used in this book relate to these experiment layouts using the TreeSummarizedExperiment and classes beyond. This section provides an introductions to these data containers. In microbiome data science, these containers link taxonomic abundance tables with rich side information on the features and samples. Taxonomic abundance data can be obtained by 16S rRNA amplicon or metagenomic sequencing, phylogenetic microarrays, or by other means. Many microbiome experiments include multiple versions and types of data generated independently or derived from each other through transformation or agglomeration. We start by providing recommendations on how to represent different varieties of multi-table data within the TreeSummarizedExperiment class. The options and recommendations are summarized in Table 2.1. 2.2.1 Assay data The original count-based taxonomic abundance tables may have different transformations, such as logarithmic, Centered Log-Ratio (CLR), or relative abundance. These are typically stored in assays. library(mia) data(GlobalPatterns, package=&quot;mia&quot;) tse &lt;- GlobalPatterns assays(tse) ## List of length 1 ## names(1): counts The assays slot contains the experimental data as count matrices. Multiple matrices can be stored the result of assays is actually a list of matrices. assays(tse) ## List of length 1 ## names(1): counts Individual assays can be accessed via assay assay(tse, &quot;counts&quot;)[1:5,1:7] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## 549322 0 0 0 0 0 0 0 ## 522457 0 0 0 0 0 0 0 ## 951 0 0 0 0 0 0 1 ## 244423 0 0 0 0 0 0 0 ## 586076 0 0 0 0 0 0 0 To illustrate the use of multiple assays, the relative abundance data can be calcualted and stored along the original count data using relAbundanceCounts. tse &lt;- relAbundanceCounts(tse) assays(tse) ## List of length 2 ## names(2): counts relabundance Now there are two assays available in the tse object, counts and relabundance. assay(tse, &quot;relabundance&quot;)[1:5,1:7] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## 549322 0 0 0 0 0 0 0.000e+00 ## 522457 0 0 0 0 0 0 0.000e+00 ## 951 0 0 0 0 0 0 2.305e-06 ## 244423 0 0 0 0 0 0 0.000e+00 ## 586076 0 0 0 0 0 0 0.000e+00 Here the dimension of the count data remains unchanged. This is in fact a requirement for any SummarizedExperiment object. 2.2.2 colData colData contains data on the samples. colData(tse) ## DataFrame with 26 rows and 7 columns ## X.SampleID Primer Final_Barcode Barcode_truncated_plus_T ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## CL3 CL3 ILBC_01 AACGCA TGCGTT ## CC1 CC1 ILBC_02 AACTCG CGAGTT ## SV1 SV1 ILBC_03 AACTGT ACAGTT ## M31Fcsw M31Fcsw ILBC_04 AAGAGA TCTCTT ## M11Fcsw M11Fcsw ILBC_05 AAGCTG CAGCTT ## ... ... ... ... ... ## TS28 TS28 ILBC_25 ACCAGA TCTGGT ## TS29 TS29 ILBC_26 ACCAGC GCTGGT ## Even1 Even1 ILBC_27 ACCGCA TGCGGT ## Even2 Even2 ILBC_28 ACCTCG CGAGGT ## Even3 Even3 ILBC_29 ACCTGT ACAGGT ## Barcode_full_length SampleType ## &lt;factor&gt; &lt;factor&gt; ## CL3 CTAGCGTGCGT Soil ## CC1 CATCGACGAGT Soil ## SV1 GTACGCACAGT Soil ## M31Fcsw TCGACATCTCT Feces ## M11Fcsw CGACTGCAGCT Feces ## ... ... ... ## TS28 GCATCGTCTGG Feces ## TS29 CTAGTCGCTGG Feces ## Even1 TGACTCTGCGG Mock ## Even2 TCTGATCGAGG Mock ## Even3 AGAGAGACAGG Mock ## Description ## &lt;factor&gt; ## CL3 Calhoun South Carolina Pine soil, pH 4.9 ## CC1 Cedar Creek Minnesota, grassland, pH 6.1 ## SV1 Sevilleta new Mexico, desert scrub, pH 8.3 ## M31Fcsw M3, Day 1, fecal swab, whole body study ## M11Fcsw M1, Day 1, fecal swab, whole body study ## ... ... ## TS28 Twin #1 ## TS29 Twin #2 ## Even1 Even1 ## Even2 Even2 ## Even3 Even3 2.2.3 rowData rowData contains data on the features of the analyzed samples. Of particular interest for the microbiome field this is used to store taxonomic information. rowData(tse) ## DataFrame with 19216 rows and 7 columns ## Kingdom Phylum Class Order Family ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 549322 Archaea Crenarchaeota Thermoprotei NA NA ## 522457 Archaea Crenarchaeota Thermoprotei NA NA ## 951 Archaea Crenarchaeota Thermoprotei Sulfolobales Sulfolobaceae ## 244423 Archaea Crenarchaeota Sd-NA NA NA ## 586076 Archaea Crenarchaeota Sd-NA NA NA ## ... ... ... ... ... ... ## 278222 Bacteria SR1 NA NA NA ## 463590 Bacteria SR1 NA NA NA ## 535321 Bacteria SR1 NA NA NA ## 200359 Bacteria SR1 NA NA NA ## 271582 Bacteria SR1 NA NA NA ## Genus Species ## &lt;character&gt; &lt;character&gt; ## 549322 NA NA ## 522457 NA NA ## 951 Sulfolobus Sulfolobusacidocalda.. ## 244423 NA NA ## 586076 NA NA ## ... ... ... ## 278222 NA NA ## 463590 NA NA ## 535321 NA NA ## 200359 NA NA ## 271582 NA NA 2.2.4 rowTree Phylogenetic trees also play an important role for the microbiome field. The TreeSummarizedExperiment class is able to keep track of feature and node relations via two functions, rowTree and rowLinks. A tree can be accessed via rowTree as phylo object. rowTree(tse) ## ## Phylogenetic tree with 19216 tips and 19215 internal nodes. ## ## Tip labels: ## 549322, 522457, 951, 244423, 586076, 246140, ... ## Node labels: ## , 0.858.4, 1.000.154, 0.764.3, 0.995.2, 1.000.2, ... ## ## Rooted; includes branch lengths. The links to the individual features are available through rowLinks. rowLinks(tse) ## LinkDataFrame with 19216 rows and 5 columns ## nodeLab nodeNum nodeLab_alias isLeaf whichTree ## &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;logical&gt; &lt;character&gt; ## 1 549322 1 alias_1 TRUE phylo ## 2 522457 2 alias_2 TRUE phylo ## 3 951 3 alias_3 TRUE phylo ## 4 244423 4 alias_4 TRUE phylo ## 5 586076 5 alias_5 TRUE phylo ## ... ... ... ... ... ... ## 19212 278222 19212 alias_19212 TRUE phylo ## 19213 463590 19213 alias_19213 TRUE phylo ## 19214 535321 19214 alias_19214 TRUE phylo ## 19215 200359 19215 alias_19215 TRUE phylo ## 19216 271582 19216 alias_19216 TRUE phylo Please note that there can be a 1:1 relationship between tree nodes and features, but this is not a must have. This means there can be features, which are not linked to nodes, and nodes, which are not linked to features. To change the links in an existing object, the changeTree function is available. 2.2.5 Alternative experiments Alternative experiments differ from transformations as they can contain complementary data, which is no longer tied to the same dimensions as the assay data. However, the number of samples (columns) must be the same. This can come into play for instance when one has taxonomic abundance profiles quantified with different measurement technologies, such as phylogenetic microarrays, amplicon sequencing, or metagenomic sequencing. Such alternative experiments that concern the same samples can be stored as Separate assays assuming that the taxonomic information can be mapped between feature directly 1:1; or data in the altExp slot of the TreeSummarizedExperiment, if the feature dimensions differ. Each element of the altExp slot is a SummarizedExperiment or an object from a derived class with independent feature data. As an example, we show how to store taxonomic abundance tables agglomerated at different taxonomic levels. However, the data could as well originate from entirely different measurement sources as long as the samples are matched. # Agglomerate the data to Phylym level tse_phylum &lt;- agglomerateByRank(tse, &quot;Phylum&quot;) # both have the same number of columns (samples) dim(tse) ## [1] 19216 26 dim(tse_phylum) ## [1] 67 26 # Add the new table as an alternative experiment altExp(tse, &quot;Phylum&quot;) &lt;- tse_phylum altExpNames(tse) ## [1] &quot;Phylum&quot; # Pick a sample subset: this acts on both altExp and assay data tse[,1:10] ## class: TreeSummarizedExperiment ## dim: 19216 10 ## metadata(0): ## assays(2): counts relabundance ## rownames(19216): 549322 522457 ... 200359 271582 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(10): CL3 CC1 ... M31Tong M11Tong ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(1): Phylum ## rowLinks: a LinkDataFrame (19216 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL dim(altExp(tse[,1:10],&quot;Phylum&quot;)) ## [1] 67 10 For more details of altExp have a look at the Intro vignette of the SingleCellExperiment package (Lun and Risso 2020). 2.2.6 MultiAssayExperiments Multiple experiments relate to complementary measurement types, such as transcriptomic or metabolomic profiling of the microbiome or the host. Multiple experiments can be represented using the same options as alternative experiments, or by using the MultiAssayExperiment class (Ramos and Waldron 2020). Depending on how the datasets relate to each other the data can be stored as: Separate altExp if the samples can be matched directly 1:1; or As MultiAssayExperiment objects, in which the connections between samples are defined through a sampleMap. Each element on the experimentsList of an MultiAssayExperiment is matrix or matrix-like object including SummarizedExperiment objects, and the number of samples can differ between the elements. #TODO: Find the right dataset to explain a non 1:1 sample relationship For information have a look at the intro vignette of the MultiAssayExperiment package. Table 2.1: Recommended options for storing multiple data tables in microbiome studies The assays are best suited for data transformations (one-to-one match between samples and columns across the assays). The alternative experiments are particularly suitable for alternative versions of the data that are of same type but may have a different number of features (e.g. taxonomic groups); this is for instance the case with taxonomic abundance tables agglomerated at different levels (e.g. genus vs. phyla) or alternative profiling technologies (e.g. amplicon sequencing vs. shallow shotgun metagenomics). For alternative experiments one-to-one match between samples (cols) is required but the alternative experiment tables can have different numbers of features (rows). Finally, elements of the MultiAssayExperiment provide the most flexible way to incorporate multi-omic data tables with flexible numbers of samples and features. We recommend these conventions as the basis for methods development and application in microbiome studies. Option Rows (features) Cols (samples) Recommended assays match match Data transformations altExp free match Alternative experiments MultiAssay free free (mapping) Multi-omic experiments 2.3 Loading experimental microbiome data 2.3.1 16S workflow Result of amplicon sequencing is large number of files that include all the sequences that were read from samples. Those sequences need to be matched with taxa. Additionally, we need to know how many times each taxa were found from each sample. There are several algorithms to do that, and DADA2 is one of the most common. You can find DADA2 pipeline tutorial for example from here. After DADA2 portion of the tutorial is the data is stored into phyloseq object (Bonus: Handoff to phyloseq). To store the data to TreeSummarizedExperiment, follow the example below. You can find full workflow script without further explanations and comments from here Load required packages. library(mia) library(ggplot2) if( !require(&quot;BiocManager&quot;) ){ install.packages(&quot;BiocManager&quot;) library(&quot;BiocManager&quot;) } if( !require(&quot;Biostrings&quot;) ){ BiocManager::install(&quot;Biostrings&quot;) library(&quot;Biostrings&quot;) } library(Biostrings) Create arbitrary example sample metadata like it was done in tutorial. Usually, sample metadata is imported as a file. samples.out &lt;- rownames(seqtab.nochim) subject &lt;- sapply(strsplit(samples.out, &quot;D&quot;), `[`, 1) gender &lt;- substr(subject,1,1) subject &lt;- substr(subject,2,999) day &lt;- as.integer(sapply(strsplit(samples.out, &quot;D&quot;), `[`, 2)) samdf &lt;- data.frame(Subject=subject, Gender=gender, Day=day) samdf$When &lt;- &quot;Early&quot; samdf$When[samdf$Day&gt;100] &lt;- &quot;Late&quot; rownames(samdf) &lt;- samples.out Convert data into right format and create TreeSE object. # Create a list that contains assays counts &lt;- t(seqtab.nochim) counts &lt;- as.matrix(counts) assays &lt;- SimpleList(counts = counts) # Convert colData and rowData into DataFrame samdf &lt;- DataFrame(samdf) taxa &lt;- DataFrame(taxa) # Create TreeSE tse &lt;- TreeSummarizedExperiment(assays = assays, colData = samdf, rowData = taxa ) # Remove mock sample like it is also done in DADA2 pipeline tutorial tse &lt;- tse[ , colnames(tse) != &quot;mock&quot;] Add sequences into referenceSeq slot and convert rownames into simpler format. # Convert sequences into right format dna &lt;- Biostrings::DNAStringSet( rownames(tse) ) # Add sequences into referenceSeq slot referenceSeq(tse) &lt;- dna # Convert rownames into ASV_number format rownames(tse) &lt;- paste0(&quot;ASV&quot;, seq( nrow(tse) )) tse ## class: TreeSummarizedExperiment ## dim: 232 20 ## metadata(0): ## assays(1): counts ## rownames(232): ASV1 ASV2 ... ASV231 ASV232 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(20): F3D0 F3D1 ... F3D9 Mock ## colData names(4): Subject Gender Day When ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: NULL ## rowTree: NULL ## colLinks: NULL ## colTree: NULL ## referenceSeq: a DNAStringSet (232 sequences) 2.3.2 Import from external files Microbiome (taxonomic) profiling data is commonly distributed in various file formats. You can import such external data files as a (Tree)SummarizedExperiment object but the details depend on the file format. Here, we provide examples for common formats. CSV data tables can be imported with the standard R functions, then converted to the desired format. For detailed examples, you can check the Bioconductor course material by Martin Morgan. The following example reads abundance tables, taxonomic mapping tables, and sample metadata, assuming that the input data files are properly prepared with appropriate row and column names. count_file &lt;- &quot;data/assay_taxa.csv&quot; tax_file &lt;- &quot;data/rowdata_taxa.csv&quot; sample_file &lt;- &quot;data/coldata.csv&quot; # Load files counts &lt;- read.csv(count_file) # Abundance table (e.g. ASV data; to assay data) tax &lt;- read.csv(tax_file) # Taxonomy table (to rowData) samples &lt;- read.csv(sample_file) # Sample data (to colData) Always ensure that the tables have rownames! The TreeSE constructor compares rownames and makes sure that, for example, right samples are linked with right patient. # Add rownames and remove an additional column rownames(counts) &lt;- counts$X counts$X &lt;- NULL # Add rownames and remove an additional column rownames(samples) &lt;- samples$X samples$X &lt;- NULL # Add rownames and remove an additional column rownames(tax) &lt;- tax$X tax$X &lt;- NULL # As an example: # If e.g. samples do not match between colData and counts table, you must order # counts based on colData if( any( colnames(counts) != rownames(samples) ) ){ counts &lt;- counts[ , rownames(samples) ] } # And same with rowData and counts... if( any( rownames(counts) != rownames(tax) ) ){ counts &lt;- counts[ rownames(tax), ] } The tables must be in correct format: counts –&gt; matrix rowData –&gt; DataFrame colData –&gt; DataFrame # Ensure that the data is in correct format # counts should be in matrix format counts &lt;- as.matrix(counts) # And it should be added to a SimpleList assays &lt;- SimpleList(counts = counts) # colData and rowData should be in DataFrame format colData &lt;- DataFrame(colData) rowData &lt;- DataFrame(rowData) # Create a TreeSE tse_taxa &lt;- TreeSummarizedExperiment(assays = assays, colData = samples, rowData = tax) tse_taxa ## class: TreeSummarizedExperiment ## dim: 12706 40 ## metadata(0): ## assays(1): counts ## rownames(12706): GAYR01026362.62.2014 CVJT01000011.50.2173 ... ## JRJTB:03787:02429 JRJTB:03787:02478 ## rowData names(7): Phylum Class ... Species OTU ## colnames(40): C1 C2 ... C39 C40 ## colData names(6): Sample Rat ... Fat XOS ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: NULL ## rowTree: NULL ## colLinks: NULL ## colTree: NULL To construct a MultiAssayExperiment object, just combine multiple TreeSE data containers. Here we import metabolite data from the same study. count_file &lt;- &quot;data/assay_metabolites.csv&quot; sample_file &lt;- &quot;data/coldata.csv&quot; # Load files counts &lt;- read.csv(count_file) samples &lt;- read.csv(sample_file) # Add rownames and remove an additional column rownames(counts) &lt;- counts$X counts$X &lt;- NULL rownames(samples) &lt;- samples$X samples$X &lt;- NULL # Convert into right format counts &lt;- as.matrix(counts) assays &lt;- SimpleList(concs = counts) colData &lt;- DataFrame(colData) # Create a TreeSE tse_metabolite &lt;- TreeSummarizedExperiment(assays = assays, colData = samples) tse_metabolite ## class: TreeSummarizedExperiment ## dim: 38 40 ## metadata(0): ## assays(1): concs ## rownames(38): Butyrate Acetate ... Malonate 1,3-dihydroxyacetone ## rowData names(0): ## colnames(40): C1 C2 ... C39 C40 ## colData names(6): Sample Rat ... Fat XOS ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: NULL ## rowTree: NULL ## colLinks: NULL ## colTree: NULL Now we can combine these two experiments into MAE. # Create an ExperimentList that includes experiments experiments &lt;- ExperimentList(microbiome = tse_taxa, metabolite = tse_metabolite) # Create a MAE mae &lt;- MultiAssayExperiment(experiments = experiments) mae ## A MultiAssayExperiment object of 2 listed ## experiments with user-defined names and respective classes. ## Containing an ExperimentList class object of length 2: ## [1] microbiome: TreeSummarizedExperiment with 12706 rows and 40 columns ## [2] metabolite: TreeSummarizedExperiment with 38 rows and 40 columns ## Functionality: ## experiments() - obtain the ExperimentList instance ## colData() - the primary/phenotype DataFrame ## sampleMap() - the sample coordination DataFrame ## `$`, `[`, `[[` - extract colData columns, subset, or experiment ## *Format() - convert into a long or wide DataFrame ## assays() - convert ExperimentList to a SimpleList of matrices ## exportClass() - save data to flat files Specific import functions are provided for: Biom files (see help(mia::loadFromBiom)) QIIME2 files (see help(mia::loadFromQIIME2)) Mothur files (see help(mia::loadFromMothur)) 2.3.2.1 Biom example This example shows how Biom files are imported into a TreeSummarizedExperiment object. The data is from following publication: Tengeler AC et al. (2020) Gut microbiota from persons with attention-deficit/hyperactivity disorder affects the brain in mice. The data set consists of 3 files: biom file: abundance table and taxonomy information csv file: sample metadata tree file: phylogenetic tree Store the data in your desired local directory (for instance, data/ under the working directory), and define source file paths biom_file_path &lt;- &quot;data/Aggregated_humanization2.biom&quot; sample_meta_file_path &lt;- &quot;data/Mapping_file_ADHD_aggregated.csv&quot; tree_file_path &lt;- &quot;data/Data_humanization_phylo_aggregation.tre&quot; Now we can load the biom data into a SummarizedExperiment (SE) object. library(mia) # Imports the data se &lt;- loadFromBiom(biom_file_path) # Check se ## class: TreeSummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): taxonomy1 taxonomy2 ... taxonomy5 taxonomy6 ## colnames(27): A110 A111 ... A38 A39 ## colData names(0): ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: NULL ## rowTree: NULL ## colLinks: NULL ## colTree: NULL The assays slot includes a list of abundance tables. The imported abundance table is named as “counts”. Let us inspect only the first cols and rows. assays(se)$counts[1:3, 1:3] ## A110 A111 A12 ## 1726470 17722 11630 0 ## 1726471 12052 0 2679 ## 17264731 0 970 0 The rowdata includes taxonomic information from the biom file. The head() command shows just the beginning of the data table for an overview. knitr::kable() is for printing the information more nicely. head(rowData(se)) ## DataFrame with 6 rows and 6 columns ## taxonomy1 taxonomy2 taxonomy3 ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1726470 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## 1726471 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## 17264731 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## 17264726 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## 1726472 &quot;k__Bacteria p__Verrucomicrobia c__Verrucomicrobiae ## 17264724 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## taxonomy4 taxonomy5 taxonomy6 ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1726470 o__Bacteroidales f__Bacteroidaceae g__Bacteroides&quot; ## 1726471 o__Bacteroidales f__Bacteroidaceae g__Bacteroides&quot; ## 17264731 o__Bacteroidales f__Porphyromonadaceae g__Parabacteroides&quot; ## 17264726 o__Bacteroidales f__Bacteroidaceae g__Bacteroides&quot; ## 1726472 o__Verrucomicrobiales f__Verrucomicrobiaceae g__Akkermansia&quot; ## 17264724 o__Bacteroidales f__Bacteroidaceae g__Bacteroides&quot; These taxonomic rank names (column names) are not real rank names. Let’s replace them with real rank names. In addition to that, the taxa names include, e.g., ’“k__’ before the name, so let’s make them cleaner by removing them. names(rowData(se)) &lt;- c(&quot;Kingdom&quot;, &quot;Phylum&quot;, &quot;Class&quot;, &quot;Order&quot;, &quot;Family&quot;, &quot;Genus&quot;) # Goes through the whole DataFrame. Removes &#39;.*[kpcofg]__&#39; from strings, where [kpcofg] # is any character from listed ones, and .* any character. rowdata_modified &lt;- BiocParallel::bplapply(rowData(se), FUN = stringr::str_remove, pattern = &#39;.*[kpcofg]__&#39;) # Genus level has additional &#39;\\&quot;&#39;, so let&#39;s delete that also rowdata_modified &lt;- BiocParallel::bplapply(rowdata_modified, FUN = stringr::str_remove, pattern = &#39;\\&quot;&#39;) # rowdata_modified is a list, so it is converted back to DataFrame format. rowdata_modified &lt;- DataFrame(rowdata_modified) # And then assigned back to the SE object rowData(se) &lt;- rowdata_modified # Now we have a nicer table head(rowData(se)) ## DataFrame with 6 rows and 6 columns ## Kingdom Phylum Class Order ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1726470 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 1726471 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 17264731 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 17264726 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 1726472 Bacteria Verrucomicrobia Verrucomicrobiae Verrucomicrobiales ## 17264724 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## Family Genus ## &lt;character&gt; &lt;character&gt; ## 1726470 Bacteroidaceae Bacteroides ## 1726471 Bacteroidaceae Bacteroides ## 17264731 Porphyromonadaceae Parabacteroides ## 17264726 Bacteroidaceae Bacteroides ## 1726472 Verrucomicrobiaceae Akkermansia ## 17264724 Bacteroidaceae Bacteroides We notice that the imported biom file did not contain the sample meta data yet, so it includes an empty data frame. head(colData(se)) ## DataFrame with 6 rows and 0 columns Let us add a sample metadata file. # We use this to check what type of data it is # read.table(sample_meta_file_path) # It seems like a comma separated file and it does not include headers # Let us read it and then convert from data.frame to DataFrame # (required for our purposes) sample_meta &lt;- DataFrame(read.table(sample_meta_file_path, sep = &quot;,&quot;, header = FALSE)) # Add sample names to rownames rownames(sample_meta) &lt;- sample_meta[,1] # Delete column that included sample names sample_meta[,1] &lt;- NULL # We can add headers colnames(sample_meta) &lt;- c(&quot;patient_status&quot;, &quot;cohort&quot;, &quot;patient_status_vs_cohort&quot;, &quot;sample_name&quot;) # Then it can be added to colData colData(se) &lt;- sample_meta Now colData includes the sample metadata. head(colData(se)) ## DataFrame with 6 rows and 4 columns ## patient_status cohort patient_status_vs_cohort sample_name ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## A110 ADHD Cohort_1 ADHD_Cohort_1 A110 ## A12 ADHD Cohort_1 ADHD_Cohort_1 A12 ## A15 ADHD Cohort_1 ADHD_Cohort_1 A15 ## A19 ADHD Cohort_1 ADHD_Cohort_1 A19 ## A21 ADHD Cohort_2 ADHD_Cohort_2 A21 ## A23 ADHD Cohort_2 ADHD_Cohort_2 A23 Now, let’s add a phylogenetic tree. The current data object, se, is a SummarizedExperiment object. This does not include a slot for adding a phylogenetic tree. In order to do this, we can convert the SE object to an extended TreeSummarizedExperiment object which includes also a rowTree slot. TreeSummarizedExperiment contains also other additional slots and features which is why we recommend to use TreeSE. tse &lt;- as(se, &quot;TreeSummarizedExperiment&quot;) # tse includes same data as se tse ## class: TreeSummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): Kingdom Phylum ... Family Genus ## colnames(27): A110 A12 ... A35 A38 ## colData names(4): patient_status cohort patient_status_vs_cohort ## sample_name ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: NULL ## rowTree: NULL ## colLinks: NULL ## colTree: NULL Next, let us read the tree data file and add it to the R data object (tse). # Reads the tree file tree &lt;- ape::read.tree(tree_file_path) # Add tree to rowTree rowTree(tse) &lt;- tree # Check tse ## class: TreeSummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): Kingdom Phylum ... Family Genus ## colnames(27): A110 A12 ... A35 A38 ## colData names(4): patient_status cohort patient_status_vs_cohort ## sample_name ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (151 rows) ## rowTree: 1 phylo tree(s) (151 leaves) ## colLinks: NULL ## colTree: NULL Now rowTree includes a phylogenetic tree: head(rowTree(tse)) 2.3.3 Conversions between data formats in R If the data has already been imported in R in another format, it can be readily converted into TreeSummarizedExperiment, as shown in our next example. Note that similar conversion functions to TreeSummarizedExperiment are available for multiple data formats via the mia package (see makeTreeSummarizedExperimentFrom* for phyloseq, Biom, and DADA2). library(mia) # phyloseq example data data(GlobalPatterns, package=&quot;phyloseq&quot;) GlobalPatterns_phyloseq &lt;- GlobalPatterns GlobalPatterns_phyloseq ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 19216 taxa and 26 samples ] ## sample_data() Sample Data: [ 26 samples by 7 sample variables ] ## tax_table() Taxonomy Table: [ 19216 taxa by 7 taxonomic ranks ] ## phy_tree() Phylogenetic Tree: [ 19216 tips and 19215 internal nodes ] # convert phyloseq to TSE GlobalPatterns_TSE &lt;- makeTreeSummarizedExperimentFromPhyloseq(GlobalPatterns_phyloseq) GlobalPatterns_TSE ## class: TreeSummarizedExperiment ## dim: 19216 26 ## metadata(0): ## assays(1): counts ## rownames(19216): 549322 522457 ... 200359 271582 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (19216 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL We can also convert TreeSummarizedExperiment objects into phyloseq with respect to the shared components that are supported by both formats (i.e. taxonomic abundance table, sample metadata, taxonomic table, phylogenetic tree, sequence information). This is useful for instance when additional methods are available for phyloseq. # convert TSE to phyloseq GlobalPatterns_phyloseq2 &lt;- makePhyloseqFromTreeSummarizedExperiment(GlobalPatterns_TSE) GlobalPatterns_phyloseq2 ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 19216 taxa and 26 samples ] ## sample_data() Sample Data: [ 26 samples by 7 sample variables ] ## tax_table() Taxonomy Table: [ 19216 taxa by 7 taxonomic ranks ] ## phy_tree() Phylogenetic Tree: [ 19216 tips and 19215 internal nodes ] Conversion is possible between other data formats. Interested readers can refer to the following functions: * makeTreeSummarizedExperimentFromDADA2 * makeSummarizedExperimentFromBiom * loadFromMetaphlan * readQZA 2.4 Demonstration data Open demonstration data for testing and benchmarking purposes is available from multiple locations. This chapter introduces some options. The other chapters of this book provide ample examples about the use of the data. 2.4.1 Package data The mia R package contains example data sets that are direct conversions from the alternative phyloseq container to the TreeSummarizedExperiment container. List the available datasets in the mia package: library(mia) data(package=&quot;mia&quot;) Load the GlobalPatterns data from the mia package: data(&quot;GlobalPatterns&quot;, package=&quot;mia&quot;) GlobalPatterns ## class: TreeSummarizedExperiment ## dim: 19216 26 ## metadata(0): ## assays(1): counts ## rownames(19216): 549322 522457 ... 200359 271582 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (19216 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL Check the documentation for this data set: ## Help on topic &#39;GlobalPatterns&#39; was found in the following packages: ## ## Package Library ## phyloseq /__w/_temp/Library ## mia /__w/_temp/Library ## ## ## Using the first match ... 2.4.2 ExperimentHub data ExperimentHub provides a variety of data resources, including the microbiomeDataSets package. A table of the available data sets is available through the availableDataSets function. library(microbiomeDataSets) availableDataSets() ## Dataset ## 1 GrieneisenTSData ## 2 HintikkaXOData ## 3 LahtiMLData ## 4 LahtiMData ## 5 LahtiWAData ## 6 OKeefeDSData ## 7 SilvermanAGutData ## 8 SongQAData ## 9 SprockettTHData All data are downloaded from ExperimentHub and cached for local re-use. Check the man pages of each function for a detailed documentation of the data contents and references. Let us retrieve a MultiAssayExperiment data set: mae &lt;- HintikkaXOData() Data is available in SummarizedExperiment, r Biocpkg(\"TreeSummarizedExperiment\"), and r Biocpkg(\"MultiAssayExperiment\") data containers; see the separate page on alternative containers for more details. 2.4.3 Other data sources The curatedMetagenomicData is an independent source that provides various example data sets as (Tree)SummarizedExperiment objects. This resource provides curated human microbiome data including gene families, marker abundance, marker presence, pathway abundance, pathway coverage, and relative abundance for samples from different body sites. See the package homepage for more details on data availability and access. As one example, let us retrieve the Vatanen (2016) (Vatanen et al. 2016) data set. This is a larger collection with a bit longer download time. library(curatedMetagenomicData) tse &lt;- curatedMetagenomicData(&quot;Vatanen*&quot;, dryrun = FALSE, counts = TRUE) Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] microbiomeDataSets_1.1.7 phyloseq_1.40.0 [3] BiocManager_1.30.19 ggplot2_3.4.0 [5] mia_1.5.17 MultiAssayExperiment_1.24.0 [7] TreeSummarizedExperiment_2.1.4 Biostrings_2.66.0 [9] XVector_0.38.0 SingleCellExperiment_1.20.0 [11] SummarizedExperiment_1.28.0 Biobase_2.58.0 [13] GenomicRanges_1.50.1 GenomeInfoDb_1.34.2 [15] IRanges_2.32.0 S4Vectors_0.36.0 [17] BiocGenerics_0.44.0 MatrixGenerics_1.10.0 [19] matrixStats_0.62.0-9005 BiocStyle_2.24.0 [21] rebook_1.6.0 loaded via a namespace (and not attached): [1] AnnotationHub_3.4.0 BiocFileCache_2.4.0 [3] plyr_1.8.7 igraph_1.3.5 [5] lazyeval_0.2.2 splines_4.2.1 [7] BiocParallel_1.32.1 scater_1.26.0 [9] digest_0.6.30 foreach_1.5.2 [11] yulab.utils_0.0.5 htmltools_0.5.3 [13] viridis_0.6.2 fansi_1.0.3 [15] magrittr_2.0.3 memoise_2.0.1 [17] ScaledMatrix_1.6.0 cluster_2.1.4 [19] DECIPHER_2.26.0 colorspace_2.0-3 [21] rappdirs_0.3.3 blob_1.2.3 [23] ggrepel_0.9.2 xfun_0.34 [25] dplyr_1.0.10 crayon_1.5.2 [27] RCurl_1.98-1.9 jsonlite_1.8.3 [29] graph_1.74.0 survival_3.4-0 [31] iterators_1.0.14 ape_5.6-2 [33] glue_1.6.2 gtable_0.3.1 [35] zlibbioc_1.44.0 DelayedArray_0.24.0 [37] BiocSingular_1.14.0 Rhdf5lib_1.18.2 [39] scales_1.2.1 DBI_1.1.3 [41] Rcpp_1.0.9 xtable_1.8-4 [43] viridisLite_0.4.1 decontam_1.18.0 [45] tidytree_0.4.1 bit_4.0.4 [47] rsvd_1.0.5 httr_1.4.4 [49] dir.expiry_1.4.0 ellipsis_0.3.2 [51] pkgconfig_2.0.3 XML_3.99-0.12 [53] scuttle_1.8.0 CodeDepends_0.6.5 [55] sass_0.4.2 dbplyr_2.2.1 [57] utf8_1.2.2 AnnotationDbi_1.58.0 [59] later_1.3.0 tidyselect_1.2.0 [61] rlang_1.0.6 reshape2_1.4.4 [63] munsell_0.5.0 BiocVersion_3.15.2 [65] tools_4.2.1 cachem_1.0.6 [67] cli_3.4.1 DirichletMultinomial_1.40.0 [69] generics_0.1.3 RSQLite_2.2.18 [71] ExperimentHub_2.4.0 ade4_1.7-20 [73] evaluate_0.18 biomformat_1.24.0 [75] stringr_1.4.1 fastmap_1.1.0 [77] yaml_2.3.6 knitr_1.40 [79] bit64_4.0.5 purrr_0.3.5 [81] KEGGREST_1.36.3 nlme_3.1-160 [83] sparseMatrixStats_1.10.0 mime_0.12 [85] compiler_4.2.1 interactiveDisplayBase_1.34.0 [87] curl_4.3.3 beeswarm_0.4.0 [89] filelock_1.0.2 png_0.1-7 [91] treeio_1.22.0 tibble_3.1.8 [93] bslib_0.4.1 stringi_1.7.8 [95] highr_0.9 lattice_0.20-45 [97] Matrix_1.5-1 vegan_2.6-4 [99] permute_0.9-7 multtest_2.52.0 [101] vctrs_0.5.0 pillar_1.8.1 [103] lifecycle_1.0.3 rhdf5filters_1.8.0 [105] jquerylib_0.1.4 BiocNeighbors_1.16.0 [107] data.table_1.14.4 bitops_1.0-7 [109] irlba_2.3.5.1 httpuv_1.6.6 [111] R6_2.5.1 promises_1.2.0.1 [113] bookdown_0.29 gridExtra_2.3 [115] vipor_0.4.5 codetools_0.2-18 [117] MASS_7.3-58.1 assertthat_0.2.1 [119] rhdf5_2.40.0 withr_2.5.0 [121] GenomeInfoDbData_1.2.9 mgcv_1.8-41 [123] parallel_4.2.1 grid_4.2.1 [125] beachmat_2.14.0 tidyr_1.2.1 [127] rmarkdown_2.17 DelayedMatrixStats_1.20.0 [129] shiny_1.7.3 ggbeeswarm_0.6.0 Bibliography "],["packages.html", "Chapter 3 Packages 3.1 Package installation 3.2 Some available packages Session Info", " Chapter 3 Packages .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 3.1 Package installation Several R packages provide methods for the analysis and manipulation of SummarizedExperiment and related data containers. One of these is mia. The installation for this and other packages has the following procedure. Stable Bioconductor release version can be installed with: BiocManager::install(&quot;microbiome/mia&quot;) Biocondcuctor development version requires the installation of the latest R beta version, and this is primarily recommended for those who already have solid experience with R/Bioconductor and need access to the latest experimental updates. BiocManager::install(&quot;microbiome/mia&quot;, version=&quot;devel&quot;) The bleeding edge (and potentially unstable) development version lives in Github: devtools::install_github(&quot;microbiome/mia&quot;) 3.2 Some available packages Some of the R packages supporting the framework include: mia : Microbiome analysis tools miaViz : Microbiome analysis specific visualization miaSim : Microbiome data simulations miaTime : Microbiome time series analysis philr (external) Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] BiocStyle_2.24.0 rebook_1.6.0 loaded via a namespace (and not attached): [1] graph_1.74.0 knitr_1.40 magrittr_2.0.3 [4] BiocGenerics_0.44.0 R6_2.5.1 rlang_1.0.6 [7] fastmap_1.1.0 stringr_1.4.1 tools_4.2.1 [10] xfun_0.34 cli_3.4.1 jquerylib_0.1.4 [13] htmltools_0.5.3 CodeDepends_0.6.5 yaml_2.3.6 [16] digest_0.6.30 bookdown_0.29 dir.expiry_1.4.0 [19] BiocManager_1.30.19 codetools_0.2-18 sass_0.4.2 [22] cachem_1.0.6 evaluate_0.18 rmarkdown_2.17 [25] stringi_1.7.8 compiler_4.2.1 bslib_0.4.1 [28] filelock_1.0.2 XML_3.99-0.12 stats4_4.2.1 [31] jsonlite_1.8.3 "],["datamanipulation.html", "Chapter 4 Data Manipulation 4.1 Tidying and subsetting 4.2 Merge data", " Chapter 4 Data Manipulation .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 4.1 Tidying and subsetting 4.1.1 Tidy data For several custom analysis and visualization packages, such as those from the tidyverse, the SE data can be converted to long data.frame format with meltAssay. library(mia) data(GlobalPatterns, package=&quot;mia&quot;) tse &lt;- GlobalPatterns tse &lt;- transformSamples(tse, method=&quot;relabundance&quot;) molten_tse &lt;- meltAssay(tse, add_row_data = TRUE, add_col_data = TRUE, assay_name = &quot;relabundance&quot;) molten_tse ## # A tibble: 499,616 × 17 ## FeatureID SampleID relabund…¹ Kingdom Phylum Class Order Family Genus Species ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 549322 CL3 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 549322 CC1 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 549322 SV1 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 549322 M31Fcsw 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 549322 M11Fcsw 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 6 549322 M31Plmr 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 7 549322 M11Plmr 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 8 549322 F21Plmr 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 9 549322 M31Tong 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 10 549322 M11Tong 0 Archaea Crena… Ther… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # … with 499,606 more rows, 7 more variables: X.SampleID &lt;fct&gt;, Primer &lt;fct&gt;, ## # Final_Barcode &lt;fct&gt;, Barcode_truncated_plus_T &lt;fct&gt;, ## # Barcode_full_length &lt;fct&gt;, SampleType &lt;fct&gt;, Description &lt;fct&gt;, and ## # abbreviated variable name ¹​relabundance 4.1.2 Subsetting Subsetting data helps to draw the focus of analysis on particular sets of samples and / or features. When dealing with large data sets, the subset of interest can be extracted and investigated separately. This might improve performance and reduce the computational load. Load: mia dplyr knitr data GlobalPatterns Let us store GlobalPatterns into tse and check its original number of features (rows) and samples (columns). Note: when subsetting by sample, expect the number of columns to decrease; when subsetting by feature, expect the number of rows to decrease. # store data into se and check dimensions data(&quot;GlobalPatterns&quot;, package=&quot;mia&quot;) tse &lt;- GlobalPatterns # show dimensions (features x samples) dim(tse) ## [1] 19216 26 4.1.2.1 Subset by sample (column-wise) For the sake of demonstration, here we will extract a subset containing only the samples of human origin (feces, skin or tongue), stored as SampleType within colData(tse) and also in tse. First, we would like to see all the possible values that SampleType can take on and how frequent those are: # inspect possible values for SampleType unique(tse$SampleType) ## [1] Soil Feces Skin Tongue ## [5] Freshwater Freshwater (creek) Ocean Sediment (estuary) ## [9] Mock ## 9 Levels: Feces Freshwater Freshwater (creek) Mock ... Tongue # show recurrence for each value tse$SampleType %&gt;% table() . Freq Feces 4 Freshwater 2 Freshwater (creek) 3 Mock 3 Ocean 3 Sediment (estuary) 3 Skin 3 Soil 3 Tongue 2 Note: after subsetting, expect the number of columns to equal the sum of the recurrences of the samples that you are interested in. For instance, ncols = Feces + Skin + Tongue = 4 + 3 + 2 = 9. Next, we logical index across the columns of tse (make sure to leave the first index empty to select all rows) and filter for the samples of human origin. For this, we use the information on the samples from the meta data colData(tse). # subset by sample tse_subset_by_sample &lt;- tse[ , tse$SampleType %in% c(&quot;Feces&quot;, &quot;Skin&quot;, &quot;Tongue&quot;)] # show dimensions dim(tse_subset_by_sample) ## [1] 19216 9 As a sanity check, the new object tse_subset_by_sample should have the original number of features (rows) and a number of samples (columns) equal to the sum of the samples of interest (in this case 9). Several characteristics can be used to subset by sample: origin sampling time sequencing method DNA / RNA barcode cohort 4.1.2.2 Subset by feature (row-wise) Similarly, here we will extract a subset containing only the features that belong to the Phyla “Actinobacteria” and “Chlamydiae”, stored as Phylum within rowData(tse). However, subsetting by feature implies a few more obstacles, such as the presence of NA elements and the possible need for agglomeration. As previously, we would first like to see all the possible values that Phylum can take on and how frequent those are: # inspect possible values for Phylum unique(rowData(tse)$Phylum) ## [1] &quot;Crenarchaeota&quot; &quot;Euryarchaeota&quot; &quot;Actinobacteria&quot; &quot;Spirochaetes&quot; ## [5] &quot;MVP-15&quot; &quot;Proteobacteria&quot; &quot;SBR1093&quot; &quot;Fusobacteria&quot; ## [9] &quot;Tenericutes&quot; &quot;ZB3&quot; &quot;Cyanobacteria&quot; &quot;GOUTA4&quot; ## [13] &quot;TG3&quot; &quot;Chlorobi&quot; &quot;Bacteroidetes&quot; &quot;Caldithrix&quot; ## [17] &quot;KSB1&quot; &quot;SAR406&quot; &quot;LCP-89&quot; &quot;Thermi&quot; ## [21] &quot;Gemmatimonadetes&quot; &quot;Fibrobacteres&quot; &quot;GN06&quot; &quot;AC1&quot; ## [25] &quot;TM6&quot; &quot;OP8&quot; &quot;Elusimicrobia&quot; &quot;NC10&quot; ## [29] &quot;SPAM&quot; NA &quot;Acidobacteria&quot; &quot;CCM11b&quot; ## [33] &quot;Nitrospirae&quot; &quot;NKB19&quot; &quot;BRC1&quot; &quot;Hyd24-12&quot; ## [37] &quot;WS3&quot; &quot;PAUC34f&quot; &quot;GN04&quot; &quot;GN12&quot; ## [41] &quot;Verrucomicrobia&quot; &quot;Lentisphaerae&quot; &quot;LD1&quot; &quot;Chlamydiae&quot; ## [45] &quot;OP3&quot; &quot;Planctomycetes&quot; &quot;Firmicutes&quot; &quot;OP9&quot; ## [49] &quot;WPS-2&quot; &quot;Armatimonadetes&quot; &quot;SC3&quot; &quot;TM7&quot; ## [53] &quot;GN02&quot; &quot;SM2F11&quot; &quot;ABY1_OD1&quot; &quot;ZB2&quot; ## [57] &quot;OP11&quot; &quot;Chloroflexi&quot; &quot;SC4&quot; &quot;WS1&quot; ## [61] &quot;GAL15&quot; &quot;AD3&quot; &quot;WS2&quot; &quot;Caldiserica&quot; ## [65] &quot;Thermotogae&quot; &quot;Synergistetes&quot; &quot;SR1&quot; # show recurrence for each value rowData(tse)$Phylum %&gt;% table() . Freq ABY1_OD1 7 AC1 1 Acidobacteria 1021 Actinobacteria 1631 AD3 9 Armatimonadetes 61 Bacteroidetes 2382 BRC1 13 Caldiserica 3 Caldithrix 10 CCM11b 2 Chlamydiae 21 Chlorobi 64 Chloroflexi 437 Crenarchaeota 106 Cyanobacteria 393 Elusimicrobia 31 Euryarchaeota 102 Fibrobacteres 7 Firmicutes 4356 Fusobacteria 37 GAL15 2 Gemmatimonadetes 191 GN02 8 GN04 7 GN06 2 GN12 1 GOUTA4 11 Hyd24-12 4 KSB1 6 LCP-89 2 LD1 2 Lentisphaerae 21 MVP-15 5 NC10 9 Nitrospirae 74 NKB19 16 OP11 6 OP3 30 OP8 27 OP9 4 PAUC34f 3 Planctomycetes 638 Proteobacteria 6416 SAR406 21 SBR1093 9 SC3 8 SC4 8 SM2F11 5 SPAM 22 Spirochaetes 124 SR1 5 Synergistetes 7 Tenericutes 143 TG3 5 Thermi 46 Thermotogae 1 TM6 27 TM7 32 Verrucomicrobia 470 WPS-2 20 WS1 5 WS2 2 WS3 70 ZB2 2 ZB3 2 Note: after subsetting, expect the number of columns to equal the sum of the recurrences of the feature(s) that you are interested in. For instance, nrows = Actinobacteria + Chlamydiae = 1631 + 21 = 1652. Depending on your research question, you might need to or need not agglomerate the data in the first place: if you want to find the abundance of each and every feature that belongs to Actinobacteria and Chlamydiae, agglomeration is not needed; if you want to find the total abundance of all the features that belong to Actinobacteria or Chlamydiae, agglomeration is recommended. 4.1.2.2.1 Non-agglomerated data Next, we logical index across the rows of tse (make sure to leave the second index empty to select all columns) and filter for the features that fall in either Actinobacteria or Chlamydiae. For this, we use the information on the samples from the meta data rowData(tse). The first term with the %in% operator are includes all the features of interest, whereas the second term after the AND operator &amp; filters out all the features that present a NA in place of Phylum. # subset by feature tse_subset_by_feature &lt;- tse[rowData(tse)$Phylum %in% c(&quot;Actinobacteria&quot;, &quot;Chlamydiae&quot;) &amp; !is.na(rowData(tse)$Phylum), ] # show dimensions dim(tse_subset_by_feature) ## [1] 1652 26 As a sanity check, the new object tse_subset_by_feature should have the original number of samples (columns) and a number of features (rows) equal to the sum of the features of interest (in this case 1652). 4.1.2.2.2 Agglomerated data When total abundances of certain Phyla are of relevance, the data is initially agglomerated by Phylum. Then, similar steps as in the case of not agglomerated data are followed. # agglomerate by Phylum tse_phylum &lt;- tse %&gt;% agglomerateByRank(rank = &quot;Phylum&quot;) # subset by feature and get rid of NAs tse_phylum_subset_by_feature &lt;- tse_phylum[rowData(tse_phylum)$Phylum %in% c(&quot;Actinobacteria&quot;, &quot;Chlamydiae&quot;) &amp; !is.na(rowData(tse_phylum)$Phylum), ] # show dimensions dim(tse_phylum_subset_by_feature) ## [1] 2 26 Note: as data was agglomerated, the number of rows equal the number of Phyla used to index (in this case, just 2) Alternatively: # store features of interest into phyla phyla &lt;- c(&quot;Phylum:Actinobacteria&quot;, &quot;Phylum:Chlamydiae&quot;) # subset by feature tse_phylum_subset_by_feature &lt;- tse_phylum[phyla, ] # show dimensions dim(tse_subset_by_feature) ## [1] 1652 26 The code above returns the not agglomerated version of the data. Fewer characteristics can be used to subset by feature: Taxonomic rank Meta-taxonomic group For subsetting by Kingdom, agglomeration does not apply, whereas for the other ranks it can be applied if necessary. 4.1.2.3 Subset by sample and feature Finally, we can subset data by sample and feature at once. The resulting subset contains all the samples of human origin and all the features of Phyla “Actinobacteria” or “Chlamydiae”. # subset by sample and feature and get rid of NAs tse_subset_by_sample_feature &lt;- tse[rowData(tse)$Phylum %in% c(&quot;Actinobacteria&quot;, &quot;Chlamydiae&quot;) &amp; !is.na(rowData(tse)$Phylum), tse$SampleType %in% c(&quot;Feces&quot;, &quot;Skin&quot;, &quot;Tongue&quot;)] # show dimensions dim(tse_subset_by_sample_feature) ## [1] 1652 9 Note: the dimensions of tse_subset_by_sample_feature agree with those of the previous subsets (9 columns filtered by sample and 1652 rows filtered by feature). If a study was to consider and quantify the presence of Actinobacteria as well as Chlamydiae in different sites of the human body, tse_subset_by_sample_feature might be a suitable subset to start with. 4.1.2.4 Remove empty columns and rows Sometimes data might contain, e.g., features that are not present in any of the samples. This might occur after subsetting for instance. In certain analyses we might want to remove those instances. # Agglomerate data at Genus level tse_genus &lt;- agglomerateByRank(tse, rank = &quot;Genus&quot;) # List bacteria that we want to include genera &lt;- c(&quot;Class:Thermoprotei&quot;, &quot;Genus:Sulfolobus&quot;, &quot;Genus:Sediminicola&quot;) # Subset data tse_genus_sub &lt;- tse_genus[genera, ] tse_genus_sub ## class: TreeSummarizedExperiment ## dim: 3 26 ## metadata(1): agglomerated_by_rank ## assays(1): counts ## rownames(3): Class:Thermoprotei Genus:Sulfolobus Genus:Sediminicola ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (3 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL # List total counts of each sample colSums(assay(tse_genus_sub, &quot;counts&quot;)) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr F21Plmr ## 1 0 0 1 1 0 4 1 ## M31Tong M11Tong LMEpi24M SLEpi20M AQC1cm AQC4cm AQC7cm NP2 ## 7 3 0 2 64 105 136 222 ## NP3 NP5 TRRsed1 TRRsed2 TRRsed3 TS28 TS29 Even1 ## 6433 1154 2 2 2 0 0 0 ## Even2 Even3 ## 2 0 Now we can see that certain samples do not include any bacteria. We can remove those. # Remove samples that do not have present any bacteria tse_genus_sub &lt;- tse_genus_sub[ , colSums(assay(tse_genus_sub, &quot;counts&quot;)) != 0 ] tse_genus_sub ## class: TreeSummarizedExperiment ## dim: 3 18 ## metadata(1): agglomerated_by_rank ## assays(1): counts ## rownames(3): Class:Thermoprotei Genus:Sulfolobus Genus:Sediminicola ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(18): CL3 M31Fcsw ... TRRsed3 Even2 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (3 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL Same thing can be done for features. # Take only those samples that are collected from feces, skin, or tongue tse_genus_sub &lt;- tse_genus[ , colData(tse_genus)$SampleType %in% c(&quot;Feces&quot;, &quot;Skin&quot;, &quot;Tongue&quot;)] tse_genus_sub ## class: TreeSummarizedExperiment ## dim: 1516 9 ## metadata(1): agglomerated_by_rank ## assays(1): counts ## rownames(1516): Class:Thermoprotei Genus:Sulfolobus ... ## Genus:Coprothermobacter Phylum:SR1 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(9): M31Fcsw M11Fcsw ... TS28 TS29 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (1516 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL # How many bacteria there are that are not present? sum(rowSums(assay(tse_genus_sub, &quot;counts&quot;)) == 0) ## [1] 435 We can see that there are bacteria that are not present in these samples that we chose. We can remove those bacteria from the data. # Take only those bacteria that are present tse_genus_sub &lt;- tse_genus_sub[rowSums(assay(tse_genus_sub, &quot;counts&quot;)) &gt; 0, ] tse_genus_sub ## class: TreeSummarizedExperiment ## dim: 1081 9 ## metadata(1): agglomerated_by_rank ## assays(1): counts ## rownames(1081): Genus:Sulfolobus Order:NRP-J ... ## Genus:Coprothermobacter Phylum:SR1 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(9): M31Fcsw M11Fcsw ... TS28 TS29 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (1081 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL 4.1.3 Splitting You can split data base on variables. There are available functions splitByRanks and splitOn. splitByRanks splits the data based on rank. Since the elements of the output list share columns, they can be stored into altExp. altExps(tse) &lt;- splitByRanks(tse) altExps(tse) ## List of length 7 ## names(7): Kingdom Phylum Class Order Family Genus Species If you want to split the data based on other variable than taxonomy rank, use splitOn. It works for row-wise and column-wise splitting. splitOn(tse, &quot;SampleType&quot;) ## List of length 9 ## names(9): Soil Feces Skin Tongue ... Ocean Sediment (estuary) Mock 4.2 Merge data mia package has mergeSEs function that merges multiple SummarizedExperiment objects. For example, it is possible to combine multiple TreeSE objects which each includes one sample. mergeSEs works like dplyr joining functions. In fact, there are available dplyr-like aliases of mergeSEs, such as full_join. # Take subsets for demonstrative purpose tse1 &lt;- tse[, 1] tse2 &lt;- tse[, 2] tse3 &lt;- tse[, 3] tse4 &lt;- tse[1:100, 4] # With inner join, we want to include all shared rows. When using mergeSEs function # all the samples are always preserved. tse &lt;- mergeSEs(list(tse1, tse2, tse3, tse4), join = &quot;inner&quot;) tse ## class: TreeSummarizedExperiment ## dim: 100 4 ## metadata(0): ## assays(1): counts ## rownames(100): 100679 101071 ... 71074 951 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(4): CC1 CL3 M31Fcsw SV1 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (100 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL # left join preserves all the rows of the 1st object tse &lt;- mia::left_join(tse1, tse4, missing_values = 0) tse ## class: TreeSummarizedExperiment ## dim: 19216 2 ## metadata(0): ## assays(1): counts ## rownames(19216): 100011 100015 ... 99953 99956 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(2): CL3 M31Fcsw ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (19216 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL 4.2.1 Additional functions mapTaxonomy mergeRows/mergeCols "],["quality-control.html", "Chapter 5 Exploration and quality Control 5.1 Abundance 5.2 Prevalence 5.3 Quality control Session Info", " Chapter 5 Exploration and quality Control .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } This chapter focuses on the quality control and exploration of microbiome data and establishes commonly used descriptive summaries. Familiarizing with the peculiarities of a given data set is the essential basis for any data analysis and model building. The dataset should not suffer from severe technical biases, and you should at least be aware of potential challenges, such as outliers, biases, unexpected patterns and so forth. Standard summaries and visualizations can help, and the rest comes with experience. The exploration and quality control can be iterative processes. library(mia) 5.1 Abundance Abundance visualization is an important data exploration approach. miaViz offers the function plotAbundanceDensity to plot the most abundant taxa with several options. In the following few demonstrations are shown, using the (Lahti et al. 2014) dataset. A Jitter plot based on relative abundance data, similar to the one presented at (Salosensaari et al. 2021) supplementary figure 1, could be visualized as follows: # Loading example data #library(microbiomeDataSets) #tse &lt;- atlas1006() library(miaTime) data(hitchip1006) tse &lt;- hitchip1006 # Add relative abundances tse &lt;- transformSamples(tse, method = &quot;relabundance&quot;) library(miaViz) plotAbundanceDensity(tse, layout = &quot;jitter&quot;, assay_name = &quot;relabundance&quot;, n = 40, point_size=1, point_shape=19, point_alpha=0.1) + scale_x_log10(label=scales::percent) The relative abundance values for the top-5 taxonomic features can be visualized as a density plot over a log scaled axis, with “nationality” indicated by colors: plotAbundanceDensity(tse, layout = &quot;density&quot;, assay_name = &quot;relabundance&quot;, n = 5, colour_by=&quot;nationality&quot;, point_alpha=1/10) + scale_x_log10() 5.2 Prevalence Prevalence quantifies the frequency of samples where certain microbes were detected (above a given detection threshold). The prevalence can be given as sample size (N) or percentage (unit interval). Investigating prevalence allows you either to focus on changes which pertain to the majority of the samples, or identify rare microbes, which may be conditionally abundant in a small number of samples, however. The population prevalence (frequency) at a 1% relative abundance threshold (detection = 1/100 and as_relative = TRUE), can look like this. head(getPrevalence(tse, detection = 1/100, sort = TRUE, as_relative = TRUE)) ## Faecalibacterium prausnitzii et rel. Ruminococcus obeum et rel. ## 0.9522 0.9140 ## Oscillospira guillermondii et rel. Clostridium symbiosum et rel. ## 0.8801 0.8714 ## Subdoligranulum variable at rel. Clostridium orbiscindens et rel. ## 0.8358 0.8315 The function arguments detection and as_relative can also be used to access, how many samples do pass a threshold for raw counts. Here the population prevalence (frequency) at the absolute abundance threshold (as_relative = FALSE) at read count 1 (detection = 1) is accessed. head(getPrevalence(tse, detection = 1, sort = TRUE, assay_name = &quot;counts&quot;, as_relative = FALSE)) ## Uncultured Mollicutes Uncultured Clostridiales II ## 1 1 ## Uncultured Clostridiales I Tannerella et rel. ## 1 1 ## Sutterella wadsworthia et rel. Subdoligranulum variable at rel. ## 1 1 If the output should be used for subsetting or storing the data in the rowData, set sort = FALSE. 5.2.1 Prevalence analysis To investigate microbiome prevalence at a selected taxonomic level, two approaches are available. First the data can be agglomerated to the taxonomic level and getPrevalence applied on the resulting object. # Agglomerate taxa abundances to Phylum level, and add the new table to the altExp slot altExp(tse,&quot;Phylum&quot;) &lt;- agglomerateByRank(tse, &quot;Phylum&quot;) # Check prevalence for the Phylum abundance table from the altExp slot head(getPrevalence(altExp(tse,&quot;Phylum&quot;), detection = 1/100, sort = TRUE, assay_name = &quot;counts&quot;, as_relative = TRUE)) ## Firmicutes Bacteroidetes Actinobacteria Proteobacteria Verrucomicrobia ## 1.0000000 0.9852302 0.4821894 0.2988705 0.1277150 ## Cyanobacteria ## 0.0008688 Alternatively, the rank argument could be set to perform the agglomeration on the fly. head(getPrevalence(tse, rank = &quot;Phylum&quot;, detection = 1/100, sort = TRUE, assay_name = &quot;counts&quot;, as_relative = TRUE)) ## Firmicutes Bacteroidetes Actinobacteria Proteobacteria Verrucomicrobia ## 1.0000000 0.9852302 0.4821894 0.2988705 0.1277150 ## Cyanobacteria ## 0.0008688 Note that, by default, na.rm = TRUE is used for agglomeration in getPrevalence, whereas the default for agglomerateByRank is FALSE to prevent accidental data loss. If you only need the names of the prevalent taxa, getPrevalentTaxa is available. This returns the taxa that exceed the given prevalence and detection thresholds. getPrevalentTaxa(tse, detection = 0, prevalence = 50/100) prev &lt;- getPrevalentTaxa(tse, detection = 0, prevalence = 50/100, rank = &quot;Phylum&quot;, sort = TRUE) prev Note that the detection and prevalence thresholds are not the same, since detection can be applied to relative counts or absolute counts depending on whether as_relative is set TRUE or FALSE The function ‘getPrevalentAbundance’ can be used to check the total relative abundance of the prevalent taxa (between 0 and 1). 5.2.2 Rare taxa Related functions are available for the analysis of rare taxa (rareMembers; rareAbundance; lowAbundance, getRareTaxa, subsetByRareTaxa). 5.2.3 Plotting prevalence To plot the prevalence, add the prevalence of each taxa to the rowData. Here, we are analysing the Phylum level abundances, which are stored in the altExp slot. rowData(altExp(tse,&quot;Phylum&quot;))$prevalence &lt;- getPrevalence(altExp(tse,&quot;Phylum&quot;), detection = 1/100, sort = FALSE, assay_name = &quot;counts&quot;, as_relative = TRUE) The prevalences can be then plotted via the plotting functions from the scater package. library(scater) plotRowData(altExp(tse,&quot;Phylum&quot;), &quot;prevalence&quot;, colour_by = &quot;Phylum&quot;) The prevalence can be also visualized on the taxonomic tree with the miaViz package. altExps(tse) &lt;- splitByRanks(tse) altExps(tse) &lt;- lapply(altExps(tse), function(y){ rowData(y)$prevalence &lt;- getPrevalence(y, detection = 1/100, sort = FALSE, assay_name = &quot;counts&quot;, as_relative = TRUE) y }) top_phyla &lt;- getTopTaxa(altExp(tse,&quot;Phylum&quot;), method=&quot;prevalence&quot;, top=5L, assay_name=&quot;counts&quot;) top_phyla_mean &lt;- getTopTaxa(altExp(tse,&quot;Phylum&quot;), method=&quot;mean&quot;, top=5L, assay_name=&quot;counts&quot;) x &lt;- unsplitByRanks(tse, ranks = taxonomyRanks(tse)[1:6]) x &lt;- addTaxonomyTree(x) After some preparation the data is assembled and can be plotted via plotRowTree. library(miaViz) plotRowTree(x[rowData(x)$Phylum %in% top_phyla,], edge_colour_by = &quot;Phylum&quot;, tip_colour_by = &quot;prevalence&quot;, node_colour_by = &quot;prevalence&quot;) Figure 5.1: Prevalence of top phyla as judged by prevalence plotRowTree(x[rowData(x)$Phylum %in% top_phyla_mean,], edge_colour_by = &quot;Phylum&quot;, tip_colour_by = &quot;prevalence&quot;, node_colour_by = &quot;prevalence&quot;) Figure 5.2: Prevalence of top phyla as judged by mean abundance 5.3 Quality control Next, let us load the GlobalPatterns data set to illustrate standard microbiome data summaries. library(mia) data(&quot;GlobalPatterns&quot;, package=&quot;mia&quot;) tse &lt;- GlobalPatterns 5.3.1 Top taxa The getTopTaxa identifies top taxa in the data. # Pick the top taxa top_features &lt;- getTopTaxa(tse, method=&quot;median&quot;, top=10) # Check the information for these rowData(tse)[top_features, taxonomyRanks(tse)] ## DataFrame with 10 rows and 7 columns ## Kingdom Phylum Class Order ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 549656 Bacteria Cyanobacteria Chloroplast Stramenopiles ## 331820 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 317182 Bacteria Cyanobacteria Chloroplast Stramenopiles ## 94166 Bacteria Proteobacteria Gammaproteobacteria Pasteurellales ## 279599 Bacteria Cyanobacteria Nostocophycideae Nostocales ## 158660 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 329744 Bacteria Actinobacteria Actinobacteria Actinomycetales ## 326977 Bacteria Actinobacteria Actinobacteria Bifidobacteriales ## 248140 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 550960 Bacteria Proteobacteria Gammaproteobacteria Enterobacteriales ## Family Genus Species ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 549656 NA NA NA ## 331820 Bacteroidaceae Bacteroides NA ## 317182 NA NA NA ## 94166 Pasteurellaceae Haemophilus Haemophilusparainflu.. ## 279599 Nostocaceae Dolichospermum NA ## 158660 Bacteroidaceae Bacteroides NA ## 329744 ACK-M1 NA NA ## 326977 Bifidobacteriaceae Bifidobacterium Bifidobacteriumadole.. ## 248140 Bacteroidaceae Bacteroides Bacteroidescaccae ## 550960 Enterobacteriaceae Providencia NA 5.3.2 Library size / read count The total counts/sample can be calculated using the perCellQCMetrics/addPerCellQC from the scater package. The former one just calculates the values, whereas the latter one directly adds them to the colData. library(scater) perCellQCMetrics(tse) ## DataFrame with 26 rows and 3 columns ## sum detected total ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## CL3 864077 6964 864077 ## CC1 1135457 7679 1135457 ## SV1 697509 5729 697509 ## M31Fcsw 1543451 2667 1543451 ## M11Fcsw 2076476 2574 2076476 ## ... ... ... ... ## TS28 937466 2679 937466 ## TS29 1211071 2629 1211071 ## Even1 1216137 4213 1216137 ## Even2 971073 3130 971073 ## Even3 1078241 2776 1078241 tse &lt;- addPerCellQC(tse) colData(tse) ## DataFrame with 26 rows and 10 columns ## X.SampleID Primer Final_Barcode Barcode_truncated_plus_T ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## CL3 CL3 ILBC_01 AACGCA TGCGTT ## CC1 CC1 ILBC_02 AACTCG CGAGTT ## SV1 SV1 ILBC_03 AACTGT ACAGTT ## M31Fcsw M31Fcsw ILBC_04 AAGAGA TCTCTT ## M11Fcsw M11Fcsw ILBC_05 AAGCTG CAGCTT ## ... ... ... ... ... ## TS28 TS28 ILBC_25 ACCAGA TCTGGT ## TS29 TS29 ILBC_26 ACCAGC GCTGGT ## Even1 Even1 ILBC_27 ACCGCA TGCGGT ## Even2 Even2 ILBC_28 ACCTCG CGAGGT ## Even3 Even3 ILBC_29 ACCTGT ACAGGT ## Barcode_full_length SampleType ## &lt;factor&gt; &lt;factor&gt; ## CL3 CTAGCGTGCGT Soil ## CC1 CATCGACGAGT Soil ## SV1 GTACGCACAGT Soil ## M31Fcsw TCGACATCTCT Feces ## M11Fcsw CGACTGCAGCT Feces ## ... ... ... ## TS28 GCATCGTCTGG Feces ## TS29 CTAGTCGCTGG Feces ## Even1 TGACTCTGCGG Mock ## Even2 TCTGATCGAGG Mock ## Even3 AGAGAGACAGG Mock ## Description sum detected ## &lt;factor&gt; &lt;numeric&gt; &lt;numeric&gt; ## CL3 Calhoun South Carolina Pine soil, pH 4.9 864077 6964 ## CC1 Cedar Creek Minnesota, grassland, pH 6.1 1135457 7679 ## SV1 Sevilleta new Mexico, desert scrub, pH 8.3 697509 5729 ## M31Fcsw M3, Day 1, fecal swab, whole body study 1543451 2667 ## M11Fcsw M1, Day 1, fecal swab, whole body study 2076476 2574 ## ... ... ... ... ## TS28 Twin #1 937466 2679 ## TS29 Twin #2 1211071 2629 ## Even1 Even1 1216137 4213 ## Even2 Even2 971073 3130 ## Even3 Even3 1078241 2776 ## total ## &lt;numeric&gt; ## CL3 864077 ## CC1 1135457 ## SV1 697509 ## M31Fcsw 1543451 ## M11Fcsw 2076476 ## ... ... ## TS28 937466 ## TS29 1211071 ## Even1 1216137 ## Even2 971073 ## Even3 1078241 The distribution of calculated library sizes can be visualized as a histogram (left), or by sorting the samples by library size (right). library(ggplot2) p1 &lt;- ggplot(as.data.frame(colData(tse))) + geom_histogram(aes(x = sum), color = &quot;black&quot;, fill = &quot;gray&quot;, bins = 30) + labs(x = &quot;Library size&quot;, y = &quot;Frequency (n)&quot;) + # scale_x_log10(breaks = scales::trans_breaks(&quot;log10&quot;, function(x) 10^x), # labels = scales::trans_format(&quot;log10&quot;, scales::math_format(10^.x))) + theme_bw() + theme(panel.grid.major = element_blank(), # Removes the grid panel.grid.minor = element_blank(), panel.border = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) # Adds y-axis library(dplyr) df &lt;- as.data.frame(colData(tse)) %&gt;% arrange(sum) %&gt;% mutate(index = 1:n()) p2 &lt;- ggplot(df, aes(y = index, x = sum/1e6)) + geom_point() + labs(x = &quot;Library size (million reads)&quot;, y = &quot;Sample index&quot;) + theme_bw() + theme(panel.grid.major = element_blank(), # Removes the grid panel.grid.minor = element_blank(), panel.border = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) # Adds y-axis library(patchwork) p1 + p2 Figure 5.3: Library size distribution. Library sizes - and other variables from colData - can be also visualized by using specified function called plotColData. library(ggplot2) # Sort samples by read count, order the factor levels, and store back to tse as DataFrame # TODO: plotColData could include an option for sorting samples based on colData variables colData(tse) &lt;- as.data.frame(colData(tse)) %&gt;% arrange(X.SampleID) %&gt;% mutate(X.SampleID = factor(X.SampleID, levels=X.SampleID)) %&gt;% DataFrame plotColData(tse,&quot;sum&quot;,&quot;X.SampleID&quot;, colour_by = &quot;SampleType&quot;) + theme(axis.text.x = element_text(angle = 45, hjust=1)) + labs(y = &quot;Library size (N)&quot;, x = &quot;Sample ID&quot;) Figure 5.4: Library sizes per sample. plotColData(tse,&quot;sum&quot;,&quot;SampleType&quot;, colour_by = &quot;SampleType&quot;) + theme(axis.text.x = element_text(angle = 45, hjust=1)) Figure 5.5: Library sizes per sample type. In addition, data can be rarefied with subsampleCounts, which normalises the samples to an equal number of reads. However, this practice has been discouraged for the analysis of differentially abundant microorganisms (see (McMurdie and Holmes 2014)). 5.3.3 Contaminant sequences Samples might be contaminated with exogenous sequences. The impact of each contaminant can be estimated based on their frequencies and concentrations across the samples. The following decontam functions are based on the (Davis et al. 2018) and support such functionality: isContaminant, isNotContaminant addContaminantQC, addNotContaminantQC Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] patchwork_1.1.2 dplyr_1.0.10 [3] scater_1.26.0 scuttle_1.8.0 [5] miaViz_1.5.4 ggraph_2.1.0 [7] ggplot2_3.4.0 miaTime_0.1.15 [9] mia_1.5.17 MultiAssayExperiment_1.24.0 [11] TreeSummarizedExperiment_2.1.4 Biostrings_2.66.0 [13] XVector_0.38.0 SingleCellExperiment_1.20.0 [15] SummarizedExperiment_1.28.0 Biobase_2.58.0 [17] GenomicRanges_1.50.1 GenomeInfoDb_1.34.2 [19] IRanges_2.32.0 S4Vectors_0.36.0 [21] BiocGenerics_0.44.0 MatrixGenerics_1.10.0 [23] matrixStats_0.62.0-9005 BiocStyle_2.24.0 [25] rebook_1.6.0 loaded via a namespace (and not attached): [1] utf8_1.2.2 tidyselect_1.2.0 [3] RSQLite_2.2.18 AnnotationDbi_1.58.0 [5] grid_4.2.1 TSP_1.2-1 [7] BiocParallel_1.32.1 Rtsne_0.16 [9] munsell_0.5.0 ScaledMatrix_1.6.0 [11] codetools_0.2-18 withr_2.5.0 [13] colorspace_2.0-3 filelock_1.0.2 [15] highr_0.9 knitr_1.40 [17] ca_0.71.1 labeling_0.4.2 [19] GenomeInfoDbData_1.2.9 polyclip_1.10-4 [21] bit64_4.0.5 farver_2.1.1 [23] vctrs_0.5.0 treeio_1.22.0 [25] generics_0.1.3 xfun_0.34 [27] R6_2.5.1 doParallel_1.0.17 [29] ggbeeswarm_0.6.0 clue_0.3-62 [31] graphlayouts_0.8.3 rsvd_1.0.5 [33] seriation_1.4.0 locfit_1.5-9.6 [35] gridGraphics_0.5-1 bitops_1.0-7 [37] cachem_1.0.6 DelayedArray_0.24.0 [39] assertthat_0.2.1 scales_1.2.1 [41] SEtools_1.10.0 beeswarm_0.4.0 [43] gtable_0.3.1 beachmat_2.14.0 [45] sva_3.44.0 tidygraph_1.2.2 [47] rlang_1.0.6 genefilter_1.78.0 [49] GlobalOptions_0.1.2 splines_4.2.1 [51] lazyeval_0.2.2 BiocManager_1.30.19 [53] yaml_2.3.6 reshape2_1.4.4 [55] tools_4.2.1 bookdown_0.29 [57] ggplotify_0.1.0 ellipsis_0.3.2 [59] decontam_1.18.0 jquerylib_0.1.4 [61] RColorBrewer_1.1-3 Rcpp_1.0.9 [63] plyr_1.8.7 sparseMatrixStats_1.10.0 [65] zlibbioc_1.44.0 purrr_0.3.5 [67] RCurl_1.98-1.9 GetoptLong_1.0.5 [69] viridis_0.6.2 cowplot_1.1.1 [71] ggrepel_0.9.2 cluster_2.1.4 [73] DECIPHER_2.26.0 magrittr_2.0.3 [75] data.table_1.14.4 openxlsx_4.2.5.1 [77] circlize_0.4.15 ggnewscale_0.4.8 [79] randomcoloR_1.1.0.1 evaluate_0.18 [81] xtable_1.8-4 XML_3.99-0.12 [83] gridExtra_2.3 shape_1.4.6 [85] compiler_4.2.1 tibble_3.1.8 [87] V8_4.2.2 crayon_1.5.2 [89] htmltools_0.5.3 ggfun_0.0.8 [91] mgcv_1.8-41 aplot_0.1.8 [93] tidyr_1.2.1 geneplotter_1.74.0 [95] DBI_1.1.3 tweenr_2.0.2 [97] ComplexHeatmap_2.12.1 MASS_7.3-58.1 [99] Matrix_1.5-1 permute_0.9-7 [101] cli_3.4.1 parallel_4.2.1 [103] igraph_1.3.5 pkgconfig_2.0.3 [105] dir.expiry_1.4.0 registry_0.5-1 [107] foreach_1.5.2 ggtree_3.4.4 [109] annotate_1.74.0 vipor_0.4.5 [111] bslib_0.4.1 DirichletMultinomial_1.40.0 [113] yulab.utils_0.0.5 stringr_1.4.1 [115] digest_0.6.30 vegan_2.6-4 [117] graph_1.74.0 rmarkdown_2.17 [119] tidytree_0.4.1 edgeR_3.38.4 [121] DelayedMatrixStats_1.20.0 curl_4.3.3 [123] rjson_0.2.21 lifecycle_1.0.3 [125] nlme_3.1-160 jsonlite_1.8.3 [127] BiocNeighbors_1.16.0 CodeDepends_0.6.5 [129] viridisLite_0.4.1 limma_3.52.4 [131] fansi_1.0.3 pillar_1.8.1 [133] lattice_0.20-45 KEGGREST_1.36.3 [135] fastmap_1.1.0 httr_1.4.4 [137] survival_3.4-0 glue_1.6.2 [139] zip_2.2.2 sechm_1.4.1 [141] png_0.1-7 iterators_1.0.14 [143] bit_4.0.4 ggforce_0.4.1 [145] stringi_1.7.8 sass_0.4.2 [147] blob_1.2.3 DESeq2_1.36.0 [149] BiocSingular_1.14.0 memoise_2.0.1 [151] irlba_2.3.5.1 ape_5.6-2 Bibliography "],["taxonomic-information.html", "Chapter 6 Taxonomic Information 6.1 Assigning taxonomic information. 6.2 Functions to access taxonomic information 6.3 Data agglomeration 6.4 Data transformation 6.5 Pick specific Session Info", " Chapter 6 Taxonomic Information .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } library(mia) data(&quot;GlobalPatterns&quot;, package=&quot;mia&quot;) tse &lt;- GlobalPatterns Taxonomic information is a key part of analyzing microbiome data and without it, any type of data analysis probably will not make much sense. However, the degree of detail of taxonomic information differs depending on the dataset and annotation data used. Therefore, the mia package expects a loose assembly of taxonomic information and assumes certain key aspects: Taxonomic information is given as character vectors or factors in the rowData of a SummarizedExperiment object. The columns containing the taxonomic information must be named domain, kingdom, phylum, class, order, family, genus, species or with a capital first letter. the columns must be given in the order shown above column can be omited, but the order must remain 6.1 Assigning taxonomic information. There are a number of methods to assign taxonomic information. We like to give a short introduction about the methods available without ranking one over the other. This has to be your choice based on the result for the individual dataset. 6.1.1 dada2 The dada2 package (Callahan, McMurdie, and Holmes 2020) implements the assignTaxonomy function, which takes as input the ASV sequences associated with each row of data and a training dataset. For more information visit the dada2 homepage. 6.1.2 DECIPHER The DECIPHER package (Wright 2020) implements the IDTAXA algorithm to assign either taxonomic information or function information. For mia only the first option is of interest for now and more information can be found on the DECIPHER website. 6.2 Functions to access taxonomic information checkTaxonomy checks whether the taxonomic information is usable for mia checkTaxonomy(tse) ## [1] TRUE Since the rowData can contain other data, taxonomyRanks will return the columns mia assumes to contain the taxonomic information. taxonomyRanks(tse) ## [1] &quot;Kingdom&quot; &quot;Phylum&quot; &quot;Class&quot; &quot;Order&quot; &quot;Family&quot; &quot;Genus&quot; &quot;Species&quot; This can then be used to subset the rowData to columns needed. rowData(tse)[,taxonomyRanks(tse)] ## DataFrame with 19216 rows and 7 columns ## Kingdom Phylum Class Order Family ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 549322 Archaea Crenarchaeota Thermoprotei NA NA ## 522457 Archaea Crenarchaeota Thermoprotei NA NA ## 951 Archaea Crenarchaeota Thermoprotei Sulfolobales Sulfolobaceae ## 244423 Archaea Crenarchaeota Sd-NA NA NA ## 586076 Archaea Crenarchaeota Sd-NA NA NA ## ... ... ... ... ... ... ## 278222 Bacteria SR1 NA NA NA ## 463590 Bacteria SR1 NA NA NA ## 535321 Bacteria SR1 NA NA NA ## 200359 Bacteria SR1 NA NA NA ## 271582 Bacteria SR1 NA NA NA ## Genus Species ## &lt;character&gt; &lt;character&gt; ## 549322 NA NA ## 522457 NA NA ## 951 Sulfolobus Sulfolobusacidocalda.. ## 244423 NA NA ## 586076 NA NA ## ... ... ... ## 278222 NA NA ## 463590 NA NA ## 535321 NA NA ## 200359 NA NA ## 271582 NA NA taxonomyRankEmpty checks for empty values in the given rank and returns a logical vector of length(x). all(!taxonomyRankEmpty(tse, rank = &quot;Kingdom&quot;)) ## [1] TRUE table(taxonomyRankEmpty(tse, rank = &quot;Genus&quot;)) ## ## FALSE TRUE ## 8008 11208 table(taxonomyRankEmpty(tse, rank = &quot;Species&quot;)) ## ## FALSE TRUE ## 1413 17803 getTaxonomyLabels is a multi-purpose function, which turns taxonomic information into a character vector of length(x) head(getTaxonomyLabels(tse)) ## [1] &quot;Class:Thermoprotei&quot; &quot;Class:Thermoprotei_1&quot; ## [3] &quot;Species:Sulfolobusacidocaldarius&quot; &quot;Class:Sd-NA&quot; ## [5] &quot;Class:Sd-NA_1&quot; &quot;Class:Sd-NA_2&quot; By default, this will use the lowest non-empty information to construct a string with the following scheme level:value. If all levels are the same, this part is omitted, but can be added by setting with_rank = TRUE. phylum &lt;- !is.na(rowData(tse)$Phylum) &amp; vapply(data.frame(apply(rowData(tse)[,taxonomyRanks(tse)[3:7]],1L,is.na)),all,logical(1)) head(getTaxonomyLabels(tse[phylum,])) ## [1] &quot;Crenarchaeota&quot; &quot;Crenarchaeota_1&quot; &quot;Crenarchaeota_2&quot; &quot;Actinobacteria&quot; ## [5] &quot;Actinobacteria_1&quot; &quot;Spirochaetes&quot; head(getTaxonomyLabels(tse[phylum,], with_rank = TRUE)) ## [1] &quot;Phylum:Crenarchaeota&quot; &quot;Phylum:Crenarchaeota_1&quot; ## [3] &quot;Phylum:Crenarchaeota_2&quot; &quot;Phylum:Actinobacteria&quot; ## [5] &quot;Phylum:Actinobacteria_1&quot; &quot;Phylum:Spirochaetes&quot; By default the return value of getTaxonomyLabels contains only unique elements by passing it through make.unique. This step can be omitted by setting make_unique = FALSE. head(getTaxonomyLabels(tse[phylum,], with_rank = TRUE, make_unique = FALSE)) ## [1] &quot;Phylum:Crenarchaeota&quot; &quot;Phylum:Crenarchaeota&quot; &quot;Phylum:Crenarchaeota&quot; ## [4] &quot;Phylum:Actinobacteria&quot; &quot;Phylum:Actinobacteria&quot; &quot;Phylum:Spirochaetes&quot; To apply the loop resolving function resolveLoop from the TreeSummarizedExperiment package (Huang 2020) within getTaxonomyLabels, set resolve_loops = TRUE. The function getUniqueTaxa gives a list of unique taxa for the specified taxonomic rank. head(getUniqueTaxa(tse, rank = &quot;Phylum&quot;)) ## [1] &quot;Crenarchaeota&quot; &quot;Euryarchaeota&quot; &quot;Actinobacteria&quot; &quot;Spirochaetes&quot; ## [5] &quot;MVP-15&quot; &quot;Proteobacteria&quot; 6.2.1 Generate a taxonomic tree on the fly To create a taxonomic tree, taxonomyTree used the information and returns a phylo object. Duplicate information from the rowData is removed. taxonomyTree(tse) ## ## Phylogenetic tree with 1645 tips and 1089 internal nodes. ## ## Tip labels: ## Species:Cenarchaeumsymbiosum, Species:pIVWA5, Species:CandidatusNitrososphaeragargensis, Species:SCA1145, Species:SCA1170, Species:Sulfolobusacidocaldarius, ... ## Node labels: ## root:ALL, Kingdom:Archaea, Phylum:Crenarchaeota, Class:C2, Class:Sd-NA, Class:Thaumarchaeota, ... ## ## Rooted; includes branch lengths. tse &lt;- addTaxonomyTree(tse) tse ## class: TreeSummarizedExperiment ## dim: 19216 26 ## metadata(0): ## assays(1): counts ## rownames(19216): Class:Thermoprotei Class:Thermoprotei ... Phylum:SR1 ## Phylum:SR1 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (19216 rows) ## rowTree: 1 phylo tree(s) (1645 leaves) ## colLinks: NULL ## colTree: NULL The implementation is based on the toTree function from the TreeSummarizedExperiment package (Huang 2020). 6.3 Data agglomeration One of the main applications of taxonomic information in regards to count data is to agglomerate count data on taxonomic levels and track the influence of changing conditions through these levels. For this mia contains the agglomerateByRank function. The ideal location to store the agglomerated data is as an alternative experiment. tse &lt;- relAbundanceCounts(tse) altExp(tse, &quot;Family&quot;) &lt;- agglomerateByRank(tse, rank = &quot;Family&quot;, agglomerateTree = TRUE) altExp(tse, &quot;Family&quot;) ## class: TreeSummarizedExperiment ## dim: 603 26 ## metadata(1): agglomerated_by_rank ## assays(2): counts relabundance ## rownames(603): Class:Thermoprotei Family:Sulfolobaceae ... ## Family:Thermodesulfobiaceae Phylum:SR1 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (603 rows) ## rowTree: 1 phylo tree(s) (496 leaves) ## colLinks: NULL ## colTree: NULL If multiple assays (counts and relabundance) exist, both will be agglomerated. assayNames(tse) ## [1] &quot;counts&quot; &quot;relabundance&quot; assayNames(altExp(tse, &quot;Family&quot;)) ## [1] &quot;counts&quot; &quot;relabundance&quot; assay(altExp(tse, &quot;Family&quot;), &quot;relabundance&quot;)[1:5,1:7] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## Class:Thermoprotei 0.0000000 0.000e+00 0 0 0 0 0.000e+00 ## Family:Sulfolobaceae 0.0000000 0.000e+00 0 0 0 0 2.305e-06 ## Class:Sd-NA 0.0000000 0.000e+00 0 0 0 0 0.000e+00 ## Order:NRP-J 0.0001991 2.070e-04 0 0 0 0 6.914e-06 ## Family:SAGMA-X 0.0000000 6.165e-06 0 0 0 0 0.000e+00 assay(altExp(tse, &quot;Family&quot;), &quot;counts&quot;)[1:5,1:7] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Family:Sulfolobaceae 0 0 0 0 0 0 1 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Order:NRP-J 172 235 0 0 0 0 3 ## Family:SAGMA-X 0 7 0 0 0 0 0 altExpNames now consists of Family level data. This can be extended to use any level present in Kingdom, Phylum, Class, Order, Family, Genus, Species. 6.4 Data transformation Data transformation is a very common procedure in microbiome analysis. In transformation, each data point is replaced with transformed value that is calculated by applying transformation formula to the data point. Transformation can be used, for example, to normalize skewed data, or to reduce weight of bigger values compared to smaller values. In mia package, transformations are applied to abundance data. The transformed abundance table is stored back to ‘assays’. mia includes transformation functions for sample-wise or column-wise transformation (‘transformSamples()’), and for feature-wise or row-wise transformation (‘transformFeatures()’). For complete list of available transformations and parameters, see function help. tse &lt;- transformSamples(tse, method = &quot;relabundance&quot;) tse &lt;- transformSamples(x = tse, assay_name = &quot;relabundance&quot;, method = &quot;clr&quot;, pseudocount = 1, name = &quot;clr_transformation&quot;) head(assay(tse, &quot;clr_transformation&quot;)) ## CL3 CC1 SV1 M31Fcsw ## Class:Thermoprotei -5.19e-05 -5.192e-05 -5.194e-05 -5.035e-05 ## Class:Thermoprotei -5.19e-05 -5.192e-05 -5.194e-05 -5.035e-05 ## Species:Sulfolobusacidocaldarius -5.19e-05 -5.192e-05 -5.194e-05 -5.035e-05 ## Class:Sd-NA -5.19e-05 -5.192e-05 -5.194e-05 -5.035e-05 ## Class:Sd-NA -5.19e-05 -5.192e-05 -5.194e-05 -5.035e-05 ## Class:Sd-NA -5.19e-05 -5.192e-05 -5.194e-05 -5.035e-05 ## M11Fcsw M31Plmr M11Plmr F21Plmr ## Class:Thermoprotei -4.991e-05 -5.06e-05 -5.091e-05 -5.148e-05 ## Class:Thermoprotei -4.991e-05 -5.06e-05 -5.091e-05 -5.148e-05 ## Species:Sulfolobusacidocaldarius -4.991e-05 -5.06e-05 -4.860e-05 -5.148e-05 ## Class:Sd-NA -4.991e-05 -5.06e-05 -5.091e-05 -5.148e-05 ## Class:Sd-NA -4.991e-05 -5.06e-05 -5.091e-05 -5.148e-05 ## Class:Sd-NA -4.991e-05 -5.06e-05 -5.091e-05 -5.148e-05 ## M31Tong M11Tong LMEpi24M SLEpi20M ## Class:Thermoprotei -4.89e-05 -5.05e-05 -4.796e-05 -4.910e-05 ## Class:Thermoprotei -4.89e-05 -5.05e-05 -4.796e-05 -4.993e-05 ## Species:Sulfolobusacidocaldarius -4.89e-05 -5.05e-05 -4.796e-05 -4.993e-05 ## Class:Sd-NA -4.89e-05 -5.05e-05 -4.796e-05 -4.993e-05 ## Class:Sd-NA -4.89e-05 -5.05e-05 -4.796e-05 -4.993e-05 ## Class:Sd-NA -4.89e-05 -5.05e-05 -4.796e-05 -4.993e-05 ## AQC1cm AQC4cm AQC7cm NP2 ## Class:Thermoprotei -2.419e-05 -4.442e-06 2.822e-05 -4.900e-05 ## Class:Thermoprotei -4.731e-05 -4.602e-05 -4.475e-05 -5.091e-05 ## Species:Sulfolobusacidocaldarius -4.731e-05 -4.686e-05 -4.828e-05 -5.091e-05 ## Class:Sd-NA -4.731e-05 -3.753e-05 -3.121e-05 -5.091e-05 ## Class:Sd-NA -4.731e-05 -4.602e-05 -4.769e-05 -5.091e-05 ## Class:Sd-NA -4.731e-05 -4.644e-05 -4.651e-05 -5.091e-05 ## NP3 NP5 TRRsed1 TRRsed2 ## Class:Thermoprotei -5.133e-05 -5.141e-05 -5.185e-05 -5.116e-05 ## Class:Thermoprotei -5.133e-05 -5.141e-05 -5.185e-05 -5.116e-05 ## Species:Sulfolobusacidocaldarius -5.133e-05 -5.141e-05 -5.185e-05 -5.116e-05 ## Class:Sd-NA -5.133e-05 -5.141e-05 -5.185e-05 -5.116e-05 ## Class:Sd-NA -5.133e-05 -5.141e-05 -5.185e-05 -5.116e-05 ## Class:Sd-NA -5.133e-05 -5.141e-05 -5.185e-05 -5.116e-05 ## TRRsed3 TS28 TS29 Even1 ## Class:Thermoprotei -5.158e-05 -5.117e-05 -5.01e-05 -5.125e-05 ## Class:Thermoprotei -5.158e-05 -5.117e-05 -5.01e-05 -5.125e-05 ## Species:Sulfolobusacidocaldarius -5.158e-05 -5.117e-05 -5.01e-05 -5.125e-05 ## Class:Sd-NA -5.158e-05 -5.117e-05 -5.01e-05 -5.125e-05 ## Class:Sd-NA -5.158e-05 -5.117e-05 -5.01e-05 -5.125e-05 ## Class:Sd-NA -5.158e-05 -5.117e-05 -5.01e-05 -5.125e-05 ## Even2 Even3 ## Class:Thermoprotei -5.114e-05 -5.122e-05 ## Class:Thermoprotei -5.114e-05 -5.122e-05 ## Species:Sulfolobusacidocaldarius -5.114e-05 -5.122e-05 ## Class:Sd-NA -5.114e-05 -5.122e-05 ## Class:Sd-NA -5.114e-05 -5.122e-05 ## Class:Sd-NA -5.114e-05 -5.122e-05 In ‘pa’ transformation, ‘threshold’ specifies the value that divides observations to be absent or present. By default, it is 0. tse &lt;- transformFeatures(tse, method = &quot;pa&quot;, threshold = 10) head(assay(tse, &quot;pa&quot;)) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Species:Sulfolobusacidocaldarius 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## F21Plmr M31Tong M11Tong LMEpi24M SLEpi20M ## Class:Thermoprotei 0 0 0 0 0 ## Class:Thermoprotei 0 0 0 0 0 ## Species:Sulfolobusacidocaldarius 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 ## AQC1cm AQC4cm AQC7cm NP2 NP3 NP5 TRRsed1 ## Class:Thermoprotei 1 1 1 0 0 0 0 ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Species:Sulfolobusacidocaldarius 0 0 0 0 0 0 0 ## Class:Sd-NA 0 1 1 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## TRRsed2 TRRsed3 TS28 TS29 Even1 Even2 Even3 ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Species:Sulfolobusacidocaldarius 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 # list of abundance tables that assays slot contains assays(tse) ## List of length 4 ## names(4): counts relabundance clr_transformation pa 6.5 Pick specific Retrieving of specific elements that are required for specific analysis. For instance, extracting abundances for a specific taxa in all samples or all taxa in one sample. 6.5.1 Abundances of all taxa in specific sample taxa.abund.cc1 &lt;- getAbundanceSample(tse, sample_id = &quot;CC1&quot;, assay_name = &quot;counts&quot;) taxa.abund.cc1[1:10] ## Class:Thermoprotei Class:Thermoprotei ## 0 0 ## Species:Sulfolobusacidocaldarius Class:Sd-NA ## 0 0 ## Class:Sd-NA Class:Sd-NA ## 0 0 ## Order:NRP-J Order:NRP-J ## 1 0 ## Order:NRP-J Order:NRP-J ## 194 5 6.5.2 Abundances of specific taxa in all samples taxa.abundances &lt;- getAbundanceFeature(tse, feature_id = &quot;Phylum:Bacteroidetes&quot;, assay_name = &quot;counts&quot;) taxa.abundances[1:10] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr F21Plmr M31Tong M11Tong ## 2 18 2 0 0 0 0 1 0 0 Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] mia_1.5.17 MultiAssayExperiment_1.24.0 [3] TreeSummarizedExperiment_2.1.4 Biostrings_2.66.0 [5] XVector_0.38.0 SingleCellExperiment_1.20.0 [7] SummarizedExperiment_1.28.0 Biobase_2.58.0 [9] GenomicRanges_1.50.1 GenomeInfoDb_1.34.2 [11] IRanges_2.32.0 S4Vectors_0.36.0 [13] BiocGenerics_0.44.0 MatrixGenerics_1.10.0 [15] matrixStats_0.62.0-9005 BiocStyle_2.24.0 [17] rebook_1.6.0 loaded via a namespace (and not attached): [1] ggbeeswarm_0.6.0 colorspace_2.0-3 [3] scuttle_1.8.0 BiocNeighbors_1.16.0 [5] ggrepel_0.9.2 bit64_4.0.5 [7] fansi_1.0.3 decontam_1.18.0 [9] splines_4.2.1 codetools_0.2-18 [11] sparseMatrixStats_1.10.0 cachem_1.0.6 [13] knitr_1.40 scater_1.26.0 [15] jsonlite_1.8.3 cluster_2.1.4 [17] graph_1.74.0 BiocManager_1.30.19 [19] compiler_4.2.1 assertthat_0.2.1 [21] Matrix_1.5-1 fastmap_1.1.0 [23] lazyeval_0.2.2 cli_3.4.1 [25] BiocSingular_1.14.0 htmltools_0.5.3 [27] tools_4.2.1 rsvd_1.0.5 [29] gtable_0.3.1 glue_1.6.2 [31] GenomeInfoDbData_1.2.9 reshape2_1.4.4 [33] dplyr_1.0.10 Rcpp_1.0.9 [35] jquerylib_0.1.4 vctrs_0.5.0 [37] ape_5.6-2 nlme_3.1-160 [39] DECIPHER_2.26.0 DelayedMatrixStats_1.20.0 [41] xfun_0.34 stringr_1.4.1 [43] beachmat_2.14.0 lifecycle_1.0.3 [45] irlba_2.3.5.1 XML_3.99-0.12 [47] zlibbioc_1.44.0 MASS_7.3-58.1 [49] scales_1.2.1 parallel_4.2.1 [51] yaml_2.3.6 memoise_2.0.1 [53] gridExtra_2.3 ggplot2_3.4.0 [55] yulab.utils_0.0.5 sass_0.4.2 [57] stringi_1.7.8 RSQLite_2.2.18 [59] ScaledMatrix_1.6.0 permute_0.9-7 [61] tidytree_0.4.1 filelock_1.0.2 [63] BiocParallel_1.32.1 rlang_1.0.6 [65] pkgconfig_2.0.3 bitops_1.0-7 [67] evaluate_0.18 lattice_0.20-45 [69] purrr_0.3.5 treeio_1.22.0 [71] CodeDepends_0.6.5 bit_4.0.4 [73] tidyselect_1.2.0 plyr_1.8.7 [75] magrittr_2.0.3 bookdown_0.29 [77] R6_2.5.1 generics_0.1.3 [79] DelayedArray_0.24.0 DBI_1.1.3 [81] withr_2.5.0 mgcv_1.8-41 [83] pillar_1.8.1 RCurl_1.98-1.9 [85] tibble_3.1.8 dir.expiry_1.4.0 [87] crayon_1.5.2 utf8_1.2.2 [89] rmarkdown_2.17 viridis_0.6.2 [91] grid_4.2.1 blob_1.2.3 [93] vegan_2.6-4 digest_0.6.30 [95] tidyr_1.2.1 munsell_0.5.0 [97] DirichletMultinomial_1.40.0 beeswarm_0.4.0 [99] viridisLite_0.4.1 vipor_0.4.5 [101] bslib_0.4.1 Bibliography "],["community-diversity.html", "Chapter 7 Community diversity 7.1 Estimation 7.2 Visualization Session Info", " Chapter 7 Community diversity .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } Diversity estimates are a central topic in microbiome data analysis. There are three commonly employed levels of diversity measurements, which are trying to put a number on different aspects of the questions associated with diversity (Whittaker 1960). Many different ways for estimating such diversity measurements have been described in the literature. Which measurement is best or applicable for your samples, is not the aim of the following sections. library(mia) data(&quot;GlobalPatterns&quot;, package=&quot;mia&quot;) tse &lt;- GlobalPatterns Alpha diversity, also sometimes interchangeably used with the term species diversity, summarizes the distribution of species abundances in a given sample into a single number that depends on species richness and evenness. Diversity indices measure the overall community heterogeneity. A number of ecological diversity measures are available. The Hill coefficient combines many standard indices into a single equation that provides observed richness, inverse Simpson, and Shannon diversity, and generalized diversity as special cases. In general, diversity increases together with increasing richness and evenness. Sometimes richness, phylogenetic diversity, evenness, dominance, and rarity are considered to be variants of alpha diversity. Richness refers to the total number of species in a community (sample). The simplest richness index is the number of observed species (observed richness). Assuming limited sampling from the community, however, this may underestimate the true species richness. Several estimators are available, including for instance ACE (A and SM 1992) and Chao1 (A 1984). Richness estimates are unaffected by species abundances. Phylogenetic diversity was first proposed by (Faith 1992). Unlike the diversity measures mentioned above, Phylogenetic diversity (PD) measure incorporates information from phylogenetic relationships stored in phylo tree between species in a community (sample). The Faith’s PD is calculated as the sum of branch length of all species in a community (sample). Evenness focuses on species abundances, and can thus complement the number of species. A typical evenness index is the Pielou’s evenness, which is Shannon diversity normalized by the observed richness. Dominance indices are in general negatively correlated with diversity, and sometimes used in ecological literature. High dominance is obtained when one or few species have a high share of the total species abundance in the community. Rarity indices characterize the concentration of taxa at low abundance. Prevalence and detection thresholds determine rare taxa whose total concentration is represented as a rarity index. 7.1 Estimation Alpha diversity can be estimated with wrapper functions that interact with other packages implementing the calculation, such as vegan (Oksanen et al. 2020). 7.1.1 Richness Richness gives the number of features present within a community and can be calculated with estimateRichness. Each of the estimate diversity/richness/evenness/dominance functions adds the calculated measure(s) to the colData of the SummarizedExperiment under the given column name. Here, we calculate observed features as a measure of richness. tse &lt;- mia::estimateRichness(tse, assay_name = &quot;counts&quot;, index = &quot;observed&quot;, name=&quot;observed&quot;) head(colData(tse)$observed) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr ## 6964 7679 5729 2667 2574 3214 This allows access to the values to be analyzed directly from the colData, for example by plotting them using plotColData from the scater package (McCarthy et al. 2020). library(scater) plotColData(tse, &quot;observed&quot;, &quot;SampleType&quot;, colour_by = &quot;Final_Barcode&quot;) + theme(axis.text.x = element_text(angle=45,hjust=1)) + ylab(expression(Richness[Observed])) Figure 7.1: Shannon diversity estimates plotted grouped by sample type with colour-labeled barcode. 7.1.2 Diversity The main function, estimateDiversity, calculates the selected diversity index based on the selected assay data. tse &lt;- mia::estimateDiversity(tse, assay_name = &quot;counts&quot;, index = &quot;shannon&quot;, name = &quot;shannon&quot;) head(colData(tse)$shannon) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr ## 6.577 6.777 6.498 3.828 3.288 4.289 Alpha diversities can be visualized with boxplot. Here, Shannon index is compared between different sample type groups. Individual data points are visualized by plotting them as points with geom_jitter. geom_signif is used to test whether these differences are statistically significant. It adds p-values to plot. if( !require(ggsignif) ){ install.packages(ggsignif) } library(ggplot2) library(patchwork) library(ggsignif) # Subsets the data. Takes only those samples that are from feces, skin, or tongue, # and creates data frame from the collected data df &lt;- as.data.frame(colData(tse)[colData(tse)$SampleType %in% c(&quot;Feces&quot;, &quot;Skin&quot;, &quot;Tongue&quot;), ]) # Changes old levels with new levels df$SampleType &lt;- factor(df$SampleType) # For significance testing, all different combinations are determined comb &lt;- split(t(combn(levels(df$SampleType), 2)), seq(nrow(t(combn(levels(df$SampleType), 2))))) ggplot(df, aes(x = SampleType, y = shannon)) + # Outliers are removed, because otherwise each data point would be plotted twice; # as an outlier of boxplot and as a point of dotplot. geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2) + geom_signif(comparisons = comb, map_signif_level = FALSE) + theme(text = element_text(size = 10)) 7.1.3 Faith phylogenetic diversity The Faith index is returned by the function estimateFaith. tse &lt;- mia::estimateFaith(tse, assay_name = &quot;counts&quot;) head(colData(tse)$faith) ## [1] 250.5 262.3 208.5 117.9 119.8 135.8 Note: because tse is a TreeSummarizedExperiment object, its phylogenetic tree is used by default. However, the optional argument tree must be provided if tse does not contain one. Below a visual comparison between shannon and faith indices is shown with a violin plot. plots &lt;- lapply(c(&quot;shannon&quot;, &quot;faith&quot;), plotColData, object = tse, colour_by = &quot;SampleType&quot;) plots[[1]] + plots[[2]] + plot_layout(guides = &quot;collect&quot;) Alternatively, the phylogenetic diversity can be calculated by mia::estimateDiversity. This is a faster re-implementation of the widely used function in picante W et al. (2010). Load picante R package and get the phylo stored in rowTree. tse &lt;- mia::estimateDiversity(tse, assay_name = &quot;counts&quot;, index = &quot;faith&quot;, name = &quot;faith&quot;) 7.1.4 Evenness Evenness can be calculated with estimateEvenness. tse &lt;- estimateEvenness(tse, assay_name = &quot;counts&quot;, index=&quot;simpson&quot;) head(colData(tse)$simpson) ## [1] 0.026871 0.027197 0.047049 0.005179 0.004304 0.005011 7.1.5 Dominance Dominance can be calculated with estimateDominance. Here, the Relative index is calculated which is the relative abundance of the most dominant species in the sample. tse &lt;- estimateDominance(tse, assay_name = &quot;counts&quot;, index=&quot;relative&quot;) head(colData(tse)$relative) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr ## 0.03910 0.03226 0.01690 0.22981 0.21778 0.22329 7.1.6 Rarity mia package provides one rarity index called log-modulo skewness. It can be calculated with estimateDiversity. tse &lt;- mia::estimateDiversity(tse, assay_name = &quot;counts&quot;, index = &quot;log_modulo_skewness&quot;) head(colData(tse)$log_modulo_skewness) ## [1] 2.061 2.061 2.061 2.061 2.061 2.061 7.1.7 Divergence Divergence can be evaluated with estimateDivergence. Reference and algorithm for the calculation of divergence can be specified as reference and FUN, respectively. tse &lt;- mia::estimateDivergence(tse, assay_name = &quot;counts&quot;, reference = &quot;median&quot;, FUN = vegan::vegdist) 7.2 Visualization A plot comparing all the diversity measures calculated above and stored in colData can then be constructed directly. plots &lt;- lapply(c(&quot;observed&quot;, &quot;shannon&quot;, &quot;simpson&quot;, &quot;relative&quot;, &quot;faith&quot;, &quot;log_modulo_skewness&quot;), plotColData, object = tse, x = &quot;SampleType&quot;, colour_by = &quot;SampleType&quot;) plots &lt;- lapply(plots, &quot;+&quot;, theme(axis.text.x = element_blank(), axis.title.x = element_blank(), axis.ticks.x = element_blank())) ((plots[[1]] | plots[[2]] | plots[[3]]) / (plots[[4]] | plots[[5]] | plots[[6]])) + plot_layout(guides = &quot;collect&quot;) Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] patchwork_1.1.2 ggsignif_0.6.4 [3] scater_1.26.0 ggplot2_3.4.0 [5] scuttle_1.8.0 mia_1.5.17 [7] MultiAssayExperiment_1.24.0 TreeSummarizedExperiment_2.1.4 [9] Biostrings_2.66.0 XVector_0.38.0 [11] SingleCellExperiment_1.20.0 SummarizedExperiment_1.28.0 [13] Biobase_2.58.0 GenomicRanges_1.50.1 [15] GenomeInfoDb_1.34.2 IRanges_2.32.0 [17] S4Vectors_0.36.0 BiocGenerics_0.44.0 [19] MatrixGenerics_1.10.0 matrixStats_0.62.0-9005 [21] BiocStyle_2.24.0 rebook_1.6.0 loaded via a namespace (and not attached): [1] ggbeeswarm_0.6.0 colorspace_2.0-3 [3] BiocNeighbors_1.16.0 farver_2.1.1 [5] ggrepel_0.9.2 bit64_4.0.5 [7] fansi_1.0.3 decontam_1.18.0 [9] splines_4.2.1 codetools_0.2-18 [11] sparseMatrixStats_1.10.0 cachem_1.0.6 [13] knitr_1.40 jsonlite_1.8.3 [15] cluster_2.1.4 graph_1.74.0 [17] BiocManager_1.30.19 compiler_4.2.1 [19] assertthat_0.2.1 Matrix_1.5-1 [21] fastmap_1.1.0 lazyeval_0.2.2 [23] cli_3.4.1 BiocSingular_1.14.0 [25] htmltools_0.5.3 tools_4.2.1 [27] rsvd_1.0.5 gtable_0.3.1 [29] glue_1.6.2 GenomeInfoDbData_1.2.9 [31] reshape2_1.4.4 dplyr_1.0.10 [33] Rcpp_1.0.9 jquerylib_0.1.4 [35] vctrs_0.5.0 ape_5.6-2 [37] nlme_3.1-160 DECIPHER_2.26.0 [39] DelayedMatrixStats_1.20.0 xfun_0.34 [41] stringr_1.4.1 beachmat_2.14.0 [43] lifecycle_1.0.3 irlba_2.3.5.1 [45] XML_3.99-0.12 zlibbioc_1.44.0 [47] MASS_7.3-58.1 scales_1.2.1 [49] parallel_4.2.1 yaml_2.3.6 [51] memoise_2.0.1 gridExtra_2.3 [53] yulab.utils_0.0.5 sass_0.4.2 [55] stringi_1.7.8 RSQLite_2.2.18 [57] highr_0.9 ScaledMatrix_1.6.0 [59] permute_0.9-7 tidytree_0.4.1 [61] filelock_1.0.2 BiocParallel_1.32.1 [63] rlang_1.0.6 pkgconfig_2.0.3 [65] bitops_1.0-7 evaluate_0.18 [67] lattice_0.20-45 purrr_0.3.5 [69] labeling_0.4.2 treeio_1.22.0 [71] CodeDepends_0.6.5 cowplot_1.1.1 [73] bit_4.0.4 tidyselect_1.2.0 [75] plyr_1.8.7 magrittr_2.0.3 [77] bookdown_0.29 R6_2.5.1 [79] generics_0.1.3 DelayedArray_0.24.0 [81] DBI_1.1.3 withr_2.5.0 [83] mgcv_1.8-41 pillar_1.8.1 [85] RCurl_1.98-1.9 tibble_3.1.8 [87] dir.expiry_1.4.0 crayon_1.5.2 [89] utf8_1.2.2 rmarkdown_2.17 [91] viridis_0.6.2 grid_4.2.1 [93] blob_1.2.3 vegan_2.6-4 [95] digest_0.6.30 tidyr_1.2.1 [97] munsell_0.5.0 DirichletMultinomial_1.40.0 [99] beeswarm_0.4.0 viridisLite_0.4.1 [101] vipor_0.4.5 bslib_0.4.1 .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } Bibliography "],["community-similarity.html", "Chapter 8 Community similarity 8.1 Explained variance 8.2 Community comparisons by beta diversity analysis 8.3 Other ordination methods 8.4 Visualizing the most dominant genus on PCoA 8.5 Further reading Session Info", " Chapter 8 Community similarity Where alpha diversity focuses on community variation within a community (sample), beta diversity quantifies (dis-)similarites between communities (samples). Some of the most popular beta diversity measures in microbiome research include Bray-Curtis index (for compositional data), Jaccard index (for presence / absence data, ignoring abundance information), Aitchison distance (Euclidean distance for clr transformed abundances, aiming to avoid the compositionality bias), and the Unifrac distances (that take into account the phylogenetic tree information). Only some of the commonly used beta diversity measures are actual distances; this is a mathematically well-defined concept and many ecological beta diversity measures, such as Bray-Curtis index, are not proper distances. Therefore, the term dissimilarity or beta diversity is commonly used. Technically, beta diversities are usually represented as dist objects, which contain triangular data describing the distance between each pair of samples. These distances can be further subjected to ordination. Ordination is a common concept in ecology that aims to reduce the dimensionality of the data for further evaluation or visualization. Ordination techniques aim to capture as much of essential information in the data as possible in a lower dimensional representation. Dimension reduction is bound to loose information but the common ordination techniques aim to preserve relevant information of sample similarities in an optimal way, which is defined in different ways by different methods. [TODO add references and/or link to ordination chapter instead?] Some of the most common ordination methods in microbiome research include Principal Component Analysis (PCA), metric and non-metric multi-dimensional scaling (MDS, NMDS), The MDS methods are also known as Principal Coordinates Analysis (PCoA). Other recently popular techniques include t-SNE and UMAP. 8.1 Explained variance The percentage of explained variance is typically shown for PCA ordination plots. This quantifies the proportion of overall variance in the data that is captured by the PCA axes, or how well the ordination axes reflect the original distances. Sometimes a similar measure is shown for MDS/PCoA. The interpretation is generally different, however, and hence we do not recommend using it. PCA is a special case of PCoA with Euclidean distances. With non-Euclidean dissimilarities PCoA uses a trick where the pointwise dissimilarities are first cast into similarities in a Euclidean space (with some information loss i.e. stress) and then projected to the maximal variance axes. In this case, the maximal variance axes do not directly reflect the correspondence of the projected distances and original distances, as they do for PCA. In typical use cases, we would like to know how well the ordination reflects the original similarity structures; then the quantity of interest is the so-called “stress” function, which measures the difference in pairwise similarities between the data points in the original (high-dimensional) vs. projected (low-dimensional) space. Hence, we propose that for PCoA and other ordination methods, users would report relative stress (varies in the unit interval; the smaller the better). This can be calculated as shown below. For further examples, check the note from Huber lab. # Example data library(mia) data(GlobalPatterns, package=&quot;mia&quot;) # Data matrix (features x samples) tse &lt;- GlobalPatterns tse &lt;- transformCounts(tse, method = &quot;relabundance&quot;) # Add group information Feces yes/no colData(tse)$Group &lt;- colData(tse)$SampleType==&quot;Feces&quot; # Quantify dissimilarities in the original feature space library(vegan) x &lt;- assay(tse, &quot;relabundance&quot;) # Pick relabunance assay separately d0 &lt;- as.matrix(vegdist(t(x), &quot;bray&quot;)) # PCoA Ordination pcoa &lt;- as.data.frame(cmdscale(d0, k = 2)) names(pcoa) &lt;- c(&quot;PCoA1&quot;, &quot;PCoA2&quot;) # Quantify dissimilarities in the ordination space dp &lt;- as.matrix(dist(pcoa)) # Calculate stress i.e. relative difference in the original and # projected dissimilarities stress &lt;- sum((dp - d0)^2)/sum(d0^2) Shepard plot visualizes the original versus projected (ordination) dissimilarities between the data points: ord &lt;- order(as.vector(d0)) df &lt;- data.frame(d0 = as.vector(d0)[ord], dmds = as.vector(dp)[ord]) library(ggplot2) ggplot(aes(x = d0, y = dmds), data=df) + geom_smooth() + geom_point() + labs(title = &quot;Shepard plot&quot;, x = &quot;Original distance&quot;, y = &quot;MDS distance&quot;, subtitle = paste(&quot;Stress:&quot;, round(stress, 2))) + theme_bw() 8.2 Community comparisons by beta diversity analysis A typical comparison of community composition starts with a visual comparison of the groups on a 2D ordination. Then we estimate relative abundances and MDS ordination based on Bray-Curtis (BC) dissimilarity between the groups, and visualize the results. In the following examples dissimilarities are calculated by functions supplied to the FUN argument. This function can be defined by the user. It must return a dist function, which can then be used to calculate reduced dimensions either via ordination methods (such as MDS or NMDS), and the results can be stored in the reducedDim. This entire process is wrapped in the runMDS and runNMDS functions. library(scater) # Bray-Curtis is usually applied to relative abundances tse &lt;- transformSamples(tse, method = &quot;relabundance&quot;) # Perform PCoA tse &lt;- runMDS(tse, FUN = vegan::vegdist, method = &quot;bray&quot;, name = &quot;PCoA_BC&quot;, exprs_values = &quot;relabundance&quot;) Sample similarities can be visualized on a lower-dimensional display (typically 2D) using the plotReducedDim function in the scater package. This provides also further tools to incorporate additional information using variations in color, shape or size. Are there visible differences between the groups? # Create ggplot object p &lt;- plotReducedDim(tse, &quot;PCoA_BC&quot;, colour_by = &quot;Group&quot;) # Add explained variance for each axis e &lt;- attr(reducedDim(tse, &quot;PCoA_BC&quot;), &quot;eig&quot;); rel_eig &lt;- e/sum(e[e&gt;0]) p &lt;- p + labs(x = paste(&quot;PCoA 1 (&quot;, round(100 * rel_eig[[1]],1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;), y = paste(&quot;PCoA 2 (&quot;, round(100 * rel_eig[[2]],1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;)) print(p) Figure 8.1: MDS plot based on the Bray-Curtis distances on the GlobalPattern dataset. With additional tools from the ggplot2 universe, comparisons can be performed informing on the applicability to visualize sample similarities in a meaningful way. tse &lt;- runMDS(tse, FUN = vegan::vegdist, name = &quot;MDS_euclidean&quot;, method = &quot;euclidean&quot;, exprs_values = &quot;counts&quot;) tse &lt;- runNMDS(tse, FUN = vegan::vegdist, name = &quot;NMDS_BC&quot;) ## initial value 47.733208 ## iter 5 value 33.853364 ## iter 10 value 32.891200 ## final value 32.823570 ## converged tse &lt;- runNMDS(tse, FUN = vegan::vegdist, name = &quot;NMDS_euclidean&quot;, method = &quot;euclidean&quot;) ## initial value 31.882673 ## final value 31.882673 ## converged plots &lt;- lapply(c(&quot;PCoA_BC&quot;, &quot;MDS_euclidean&quot;, &quot;NMDS_BC&quot;, &quot;NMDS_euclidean&quot;), plotReducedDim, object = tse, colour_by = &quot;Group&quot;) library(patchwork) plots[[1]] + plots[[2]] + plots[[3]] + plots[[4]] + plot_layout(guides = &quot;collect&quot;) Figure 8.2: Comparison of MDS and NMDS plots based on the Bray-Curtis or euclidean distances on the GlobalPattern dataset. The Unifrac method is a special case, as it requires data on the relationship of features in form on a phylo tree. calculateUnifrac performs the calculation to return a dist object, which can again be used within runMDS. library(scater) tse &lt;- runMDS(tse, FUN = mia::calculateUnifrac, name = &quot;Unifrac&quot;, tree = rowTree(tse), ntop = nrow(tse), exprs_values = &quot;counts&quot;) plotReducedDim(tse, &quot;Unifrac&quot;, colour_by = &quot;Group&quot;) Figure 8.3: Unifrac distances scaled by MDS of the GlobalPattern dataset. 8.3 Other ordination methods Other dimension reduction methods, such as PCA, t-SNE and UMAP are inherited directly from the scater package. tse &lt;- runPCA(tse, name = &quot;PCA&quot;, exprs_values = &quot;counts&quot;, ncomponents = 10) plotReducedDim(tse, &quot;PCA&quot;, colour_by = &quot;Group&quot;) Figure 8.4: PCA plot on the GlobalPatterns data set containing sample from different sources. As mentioned before, applicability of the different methods depends on your sample set. FIXME: let us switch to UMAP for the examples? tse &lt;- runTSNE(tse, name = &quot;TSNE&quot;, exprs_values = &quot;counts&quot;, ncomponents = 3) plotReducedDim(tse, &quot;TSNE&quot;, colour_by = &quot;Group&quot;, ncomponents = c(1:3)) Figure 8.5: t-SNE plot on the GlobalPatterns data set containing sample from different sources. As a final note, mia provides functions for the evaluation of additional dissimilarity indices, such as: * calculateJSD, runJSD (Jensen-Shannon divergence) * calculateNMDS, plotNMDS (non-metric multi-dimensional scaling) * calculateCCA, runCCA (Canonical Correspondence Analysis) * calculateRDA, runRDA (Redundancy Analysis) * calculateOverlap, runOverlap () * calculateDPCoA, runDPCoA (Double Principal Coordinate Analysis) Redundancy analysis is similar to PCA, however, it takes into account covariates. It aims to maximize the variance in respect of covariates. The results shows how much each covariate affects. # Load required packages if(!require(&quot;vegan&quot;)){ install.packages(&quot;vegan&quot;) library(&quot;vegan&quot;) } if(!require(&quot;stringr&quot;)){ install.packages(&quot;stringr&quot;) library(&quot;stringr&quot;) } if(!require(&quot;knitr&quot;)){ install.packages(&quot;knitr&quot;) library(&quot;knitr&quot;) } # Load data data(enterotype) # Covariates that are being analyzed variable_names &lt;- c(&quot;ClinicalStatus&quot;, &quot;Gender&quot;, &quot;Age&quot;) # Apply relative transform enterotype &lt;- transformSamples(enterotype, method = &quot;relabundance&quot;) # Get assay assay &lt;- t(assay(enterotype, &quot;relabundance&quot;)) # Get colData coldata &lt;- colData(enterotype) # Create a formula formula &lt;- as.formula(paste0(&quot;assay ~ &quot;, str_c(variable_names, collapse = &quot; + &quot;)) ) # # Perform RDA rda &lt;- rda(formula, data = coldata, scale = TRUE, na.action = na.exclude) # Initialize list for p-values rda_info &lt;- list() # Name for storing the result variable_name &lt;- &quot;all&quot; # Calculate and store p-value, and other information rda_info[[variable_name]] &lt;- c(constrained = rda$CCA$tot.chi, unconstrainded = rda$CA$tot.chi, proportion = rda$CCA$tot.chi/rda$CA$tot.chi, p_value = anova.cca(rda)[&quot;Model&quot;, &quot;Pr(&gt;F)&quot;] ) # Loop through variables permutations &lt;- 999 for( variable_name in variable_names ){ # Create a formula formula &lt;- as.formula(paste0(&quot;assay ~ &quot;, variable_name) ) # Perform RDA rda_temp &lt;- rda(formula, data = coldata, scale = TRUE, na.action = na.exclude) # Add Info to list rda_info[[variable_name]] &lt;- c(constrained = rda_temp$CCA$tot.chi, unconstrainded = rda_temp$CA$tot.chi, proportion = rda_temp$CCA$tot.chi/rda$CA$tot.chi, p_value = anova.cca(rda_temp, permutations = permutations )[&quot;Model&quot;, &quot;Pr(&gt;F)&quot;] ) } # Convert into data.frame rda_info &lt;- t(as.data.frame(rda_info)) rda_info_clean &lt;- rda_info # Adjust names colnames(rda_info_clean) &lt;- c(&quot;Explained by variables&quot;, &quot;Unexplained by variables&quot;, &quot;Proportion expl by vars&quot;, paste0(&quot;P-value (PERMANOVA &quot;, permutations, &quot; permutations)&quot;) ) # Print info kable(rda_info_clean) Explained by variables Unexplained by variables Proportion expl by vars P-value (PERMANOVA 999 permutations) all 35.30 191.7 0.1842 0.630 ClinicalStatus 19.08 209.9 0.0996 0.835 Gender 5.31 223.7 0.0277 0.921 Age 10.59 216.4 0.0552 0.001 # Load ggord for plotting if(!require(&quot;ggord&quot;)){ if(!require(&quot;devtools&quot;)){ install.packages(&quot;devtools&quot;) library(&quot;devtools&quot;) } install_github(&quot;https://github.com/fawda123/ggord/&quot;) library(&quot;ggord&quot;) } ## ## * checking for file ‘/tmp/RtmpRTS5WY/remotes2ea3796c6206/fawda123-ggord-e3ef3be/DESCRIPTION’ ... OK ## * preparing ‘ggord’: ## * checking DESCRIPTION meta-information ... OK ## * checking for LF line-endings in source and make files and shell scripts ## * checking for empty or unneeded directories ## Omitted ‘LazyData’ from DESCRIPTION ## * building ‘ggord_1.1.7.tar.gz’ if(!require(&quot;ggplot2&quot;)){ install.packages(&quot;ggplot2&quot;) library(&quot;ggplot2&quot;) } # Since na.exclude was used, if there were rows missing information, they were # dropped off. Subset coldata so that it matches with rda. coldata &lt;- coldata[ rownames(rda$CCA$wa), ] # Adjust names # Get labels of vectors vec_lab_old &lt;- rownames(rda$CCA$biplot) # Loop through vector labels vec_lab &lt;- sapply(vec_lab_old, FUN = function(name){ # Get the variable name variable_name &lt;- variable_names[ str_detect(name, variable_names) ] # If the vector label includes also group name if( !any(name %in% variable_names) ){ # Get the group names group_name &lt;- unique( coldata[[variable_name]] )[ which( paste0(variable_name, unique( coldata[[variable_name]] )) == name ) ] # Modify vector so that group is separated from variable name new_name &lt;- paste0(variable_name, &quot; \\U2012 &quot;, group_name) } else{ new_name &lt;- name } # Add percentage how much this variable explains, and p-value new_name &lt;- expr(paste(!!new_name, &quot; (&quot;, !!format(round( rda_info[variable_name, &quot;proportion&quot;]*100, 1), nsmall = 1), &quot;%, &quot;,italic(&quot;P&quot;), &quot; = &quot;, !!gsub(&quot;0\\\\.&quot;,&quot;\\\\.&quot;, format(round( rda_info[variable_name, &quot;p_value&quot;], 3), nsmall = 3)), &quot;)&quot;)) return(new_name) }) # Add names names(vec_lab) &lt;- vec_lab_old # Create labels for axis xlab &lt;- paste0(&quot;RDA1 (&quot;, format(round( rda$CCA$eig[[1]]/rda$CCA$tot.chi*100, 1), nsmall = 1 ), &quot;%)&quot;) ylab &lt;- paste0(&quot;RDA2 (&quot;, format(round( rda$CCA$eig[[2]]/rda$CCA$tot.chi*100, 1), nsmall = 1 ), &quot;%)&quot;) # Create a plot plot &lt;- ggord(rda, grp_in = coldata[[&quot;ClinicalStatus&quot;]], vec_lab = vec_lab, alpha = 0.5, size = 4, addsize = -4, #ext= 0.7, txt = 3.5, repel = TRUE, #coord_fix = FALSE ) + # Adjust titles and labels guides(colour = guide_legend(&quot;ClinicalStatus&quot;), fill = guide_legend(&quot;ClinicalStatus&quot;), group = guide_legend(&quot;ClinicalStatus&quot;), shape = guide_legend(&quot;ClinicalStatus&quot;), x = guide_axis(xlab), y = guide_axis(ylab)) + theme( axis.title = element_text(size = 10) ) plot From RDA plot, we can see that only age has significant affect on microbial profile. 8.4 Visualizing the most dominant genus on PCoA In this section we visualize most dominant genus on PCoA. A similar visualization was proposed in Taxonomic signatures of cause-specific mortality risk in human gut microbiome, Salosensaari et al. (2021). Let us agglomerate the data at a Genus level and getting the dominant taxa per sample. # Agglomerate to genus level tse_Genus &lt;- agglomerateByRank(tse, rank=&quot;Genus&quot;) # Convert to relative abundances tse_Genus &lt;- transformSamples(tse, method = &quot;relabundance&quot;, assay_name=&quot;counts&quot;) # Add info on dominant genus per sample tse_Genus &lt;- addPerSampleDominantTaxa(tse_Genus, assay_name=&quot;relabundance&quot;, name = &quot;dominant_taxa&quot;) Performing PCoA with Bray-Curtis dissimilarity. tse_Genus &lt;- runMDS(tse_Genus, FUN = vegan::vegdist, name = &quot;PCoA_BC&quot;, exprs_values = &quot;relabundance&quot;) Getting top taxa and visualizing the abundance on PCoA. # Getting the top taxa top_taxa &lt;- getTopTaxa(tse_Genus,top = 6, assay_name = &quot;relabundance&quot;) # Naming all the rest of non top-taxa as &quot;Other&quot; most_abundant &lt;- lapply(colData(tse_Genus)$dominant_taxa, function(x){if (x %in% top_taxa) {x} else {&quot;Other&quot;}}) # Storing the previous results as a new column within colData colData(tse_Genus)$most_abundant &lt;- as.character(most_abundant) # Calculating percentage of the most abundant most_abundant_freq &lt;- table(as.character(most_abundant)) most_abundant_percent &lt;- round(most_abundant_freq/sum(most_abundant_freq)*100, 1) # Retrieving the explained variance e &lt;- attr(reducedDim(tse_Genus, &quot;PCoA_BC&quot;), &quot;eig&quot;); var_explained &lt;- e/sum(e[e&gt;0])*100 # Visualization plot &lt;-plotReducedDim(tse_Genus,&quot;PCoA_BC&quot;, colour_by = &quot;most_abundant&quot;) + scale_colour_manual(values = c(&quot;black&quot;, &quot;blue&quot;, &quot;lightblue&quot;, &quot;darkgray&quot;, &quot;magenta&quot;, &quot;darkgreen&quot;, &quot;red&quot;), labels=paste0(names(most_abundant_percent),&quot;(&quot;,most_abundant_percent,&quot;%)&quot;))+ labs(x=paste(&quot;PC 1 (&quot;,round(var_explained[1],1),&quot;%)&quot;), y=paste(&quot;PC 2 (&quot;,round(var_explained[2],1),&quot;%)&quot;), color=&quot;&quot;) plot Note: A 3D interactive version of the earlier plot can be found from here. Similarly let’s visualize and compare the sub-population. # Calculating the frequencies and percentages for both categories freq_TRUE &lt;- table(as.character(most_abundant[colData(tse_Genus)$Group==TRUE])) freq_FALSE &lt;- table(as.character(most_abundant[colData(tse_Genus)$Group==FALSE])) percent_TRUE &lt;- round(freq_TRUE/sum(freq_TRUE)*100, 1) percent_FALSE &lt;- round(freq_FALSE/sum(freq_FALSE)*100, 1) # Visualization plotReducedDim(tse_Genus[,colData(tse_Genus)$Group==TRUE], &quot;PCoA_BC&quot;, colour_by = &quot;most_abundant&quot;) + scale_colour_manual(values = c(&quot;black&quot;, &quot;blue&quot;, &quot;lightblue&quot;, &quot;darkgray&quot;, &quot;magenta&quot;, &quot;darkgreen&quot;, &quot;red&quot;), labels=paste0(names(percent_TRUE),&quot;(&quot;,percent_TRUE,&quot;%)&quot;))+ labs(x=paste(&quot;PC 1 (&quot;,round(var_explained[1],1),&quot;%)&quot;), y=paste(&quot;PC 2 (&quot;,round(var_explained[2],1),&quot;%)&quot;), title = &quot;Group = TRUE&quot;, color=&quot;&quot;) plotReducedDim(tse_Genus[,colData(tse_Genus)$Group==FALSE], &quot;PCoA_BC&quot;, colour_by = &quot;most_abundant&quot;) + scale_colour_manual(values = c(&quot;black&quot;, &quot;blue&quot;, &quot;lightblue&quot;, &quot;darkgray&quot;, &quot;magenta&quot;, &quot;darkgreen&quot;, &quot;red&quot;), labels=paste0(names(percent_FALSE),&quot;(&quot;,percent_FALSE,&quot;%)&quot;))+ labs(x=paste(&quot;PC 1 (&quot;,round(var_explained[1],1),&quot;%)&quot;), y=paste(&quot;PC 2 (&quot;,round(var_explained[2],1),&quot;%)&quot;), title = &quot;Group = FALSE&quot;, color=&quot;&quot;) 8.4.1 Testing differences in community composition between sample groups The permutational analysis of variance (PERMANOVA) (Anderson 2001) is a widely used non-parametric multivariate method that can be used to estimate the actual statistical significance of differences in the observed community composition between two groups of samples. PERMANOVA evaluates the hypothesis that the centroids and dispersion of the community are equivalent between the compared groups. A small p-value indicates that the compared groups have, on average, a different community composition. This method is implemented in the vegan package in the function adonis2. Note: It is recommended to by = \"margin\". It specifies that each variable’s marginal effect is analyzed individually. When by = \"terms\" (the default) the order of variables matters; each variable is analyzed sequentially, and the result is different when more than 1 variable is introduced and their order is differs. (Check comparison) We can perform PERMANOVA with adonis2 function or by first performing distance-based redundancy analysis (dbRDA), and then applying permutational test for result of redundancy analysis. Advantage of the latter approach is that by doing so we can get coefficients: how much each taxa affect to the result. if( !require(vegan) ){ BiocManager::install(&quot;vegan&quot;) library(&quot;vegan&quot;) } # Agglomerate data to Species level tse &lt;- agglomerateByRank(tse, rank = &quot;Species&quot;) # Set seed for reproducibility set.seed(1576) # We choose 99 random permutations. Consider applying more (999 or 9999) in your # analysis. permanova &lt;- adonis2(t(assay(tse,&quot;relabundance&quot;)) ~ Group, by = &quot;margin&quot;, # each term (here only &#39;Group&#39;) analyzed individually data = colData(tse), method = &quot;euclidean&quot;, permutations = 99) # Set seed for reproducibility set.seed(1576) # Perform dbRDA dbrda &lt;- dbrda(t(assay(tse,&quot;relabundance&quot;)) ~ Group, data = colData(tse)) # Perform permutational analysis permanova2 &lt;- anova.cca(dbrda, by = &quot;margin&quot;, # each term (here only &#39;Group&#39;) analyzed individually method = &quot;euclidean&quot;, permutations = 99) # Get p-values p_values &lt;- c( permanova[&quot;Group&quot;, &quot;Pr(&gt;F)&quot;], permanova2[&quot;Group&quot;, &quot;Pr(&gt;F)&quot;] ) p_values &lt;-as.data.frame(p_values) rownames(p_values) &lt;- c(&quot;adonis2&quot;, &quot;dbRDA+anova.cca&quot;) p_values ## p_values ## adonis2 0.02 ## dbRDA+anova.cca 0.02 As we can see, the community composition is significantly different between the groups (p &lt; 0.05), and these two methods give equal p-values. Let us visualize the model coefficients for species that exhibit the largest differences between the groups. This gives some insights into how the groups tend to differ from each other in terms of community composition. # Add taxa info sppscores(dbrda) &lt;- t(assay(tse,&quot;relabundance&quot;)) # Get coefficients coef &lt;- dbrda$CCA$v # Get the taxa with biggest weights top.coef &lt;- head( coef[rev(order(abs(coef))), , drop = FALSE], 20) # Sort weights in increasing order top.coef &lt;- top.coef[ order(top.coef), ] # Get top names top_names &lt;- names(top.coef)[ order(abs(top.coef), decreasing = TRUE) ] ggplot(data.frame(x = top.coef, y = factor(names(top.coef), unique(names(top.coef)))), aes(x = x, y = y)) + geom_bar(stat=&quot;identity&quot;) + labs(x=&quot;&quot;,y=&quot;&quot;,title=&quot;Top Taxa&quot;) + theme_bw() In the above example, the largest differences between the two groups can be attributed to Genus:Bacteroides (elevated in the first group) and Family:Ruminococcaceae (elevated in the second group), and many other co-varying species. 8.4.2 Checking the homogeneity condition It is important to note that the application of PERMANOVA assumes homogeneous group dispersions (variances). This can be tested with the PERMDISP2 method (Anderson 2006) by using the same assay and distance method than in PERMANOVA. anova( betadisper(vegdist(t(assay(tse, &quot;counts&quot;))), colData(tse)$Group) ) ## Analysis of Variance Table ## ## Response: Distances ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Groups 1 0.2385 0.2385 103 3.6e-10 *** ## Residuals 24 0.0554 0.0023 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 If the groups have similar dispersion, PERMANOVA can be seen as an appropriate choice for comparing community compositions. 8.5 Further reading How to extract information from clusters Chapter 10 on community typing Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] ggord_1.1.7 devtools_2.4.5 [3] usethis_2.1.6 knitr_1.40 [5] stringr_1.4.1 patchwork_1.1.2 [7] scater_1.26.0 scuttle_1.8.0 [9] ggplot2_3.4.0 vegan_2.6-4 [11] lattice_0.20-45 permute_0.9-7 [13] mia_1.5.17 MultiAssayExperiment_1.24.0 [15] TreeSummarizedExperiment_2.1.4 Biostrings_2.66.0 [17] XVector_0.38.0 SingleCellExperiment_1.20.0 [19] SummarizedExperiment_1.28.0 Biobase_2.58.0 [21] GenomicRanges_1.50.1 GenomeInfoDb_1.34.2 [23] IRanges_2.32.0 S4Vectors_0.36.0 [25] BiocGenerics_0.44.0 MatrixGenerics_1.10.0 [27] matrixStats_0.62.0-9005 BiocStyle_2.24.0 [29] rebook_1.6.0 loaded via a namespace (and not attached): [1] plyr_1.8.7 lazyeval_0.2.2 [3] splines_4.2.1 BiocParallel_1.32.1 [5] digest_0.6.30 yulab.utils_0.0.5 [7] htmltools_0.5.3 viridis_0.6.2 [9] fansi_1.0.3 magrittr_2.0.3 [11] memoise_2.0.1 ScaledMatrix_1.6.0 [13] cluster_2.1.4 DECIPHER_2.26.0 [15] remotes_2.4.2 prettyunits_1.1.1 [17] colorspace_2.0-3 blob_1.2.3 [19] ggrepel_0.9.2 xfun_0.34 [21] dplyr_1.0.10 callr_3.7.3 [23] crayon_1.5.2 RCurl_1.98-1.9 [25] jsonlite_1.8.3 graph_1.74.0 [27] ape_5.6-2 glue_1.6.2 [29] gtable_0.3.1 zlibbioc_1.44.0 [31] DelayedArray_0.24.0 pkgbuild_1.3.1 [33] BiocSingular_1.14.0 scales_1.2.1 [35] DBI_1.1.3 miniUI_0.1.1.1 [37] Rcpp_1.0.9 viridisLite_0.4.1 [39] xtable_1.8-4 decontam_1.18.0 [41] tidytree_0.4.1 bit_4.0.4 [43] rsvd_1.0.5 profvis_0.3.7 [45] htmlwidgets_1.5.4 dir.expiry_1.4.0 [47] ellipsis_0.3.2 urlchecker_1.0.1 [49] pkgconfig_2.0.3 XML_3.99-0.12 [51] farver_2.1.1 CodeDepends_0.6.5 [53] sass_0.4.2 utf8_1.2.2 [55] tidyselect_1.2.0 labeling_0.4.2 [57] rlang_1.0.6 reshape2_1.4.4 [59] later_1.3.0 munsell_0.5.0 [61] tools_4.2.1 cachem_1.0.6 [63] cli_3.4.1 DirichletMultinomial_1.40.0 [65] generics_0.1.3 RSQLite_2.2.18 [67] evaluate_0.18 fastmap_1.1.0 [69] yaml_2.3.6 processx_3.8.0 [71] bit64_4.0.5 fs_1.5.2 [73] purrr_0.3.5 nlme_3.1-160 [75] sparseMatrixStats_1.10.0 mime_0.12 [77] compiler_4.2.1 curl_4.3.3 [79] beeswarm_0.4.0 filelock_1.0.2 [81] treeio_1.22.0 tibble_3.1.8 [83] bslib_0.4.1 stringi_1.7.8 [85] ps_1.7.2 highr_0.9 [87] Matrix_1.5-1 vctrs_0.5.0 [89] pillar_1.8.1 lifecycle_1.0.3 [91] BiocManager_1.30.19 jquerylib_0.1.4 [93] BiocNeighbors_1.16.0 cowplot_1.1.1 [95] bitops_1.0-7 irlba_2.3.5.1 [97] httpuv_1.6.6 R6_2.5.1 [99] bookdown_0.29 promises_1.2.0.1 [101] gridExtra_2.3 vipor_0.4.5 [103] sessioninfo_1.2.2 codetools_0.2-18 [105] pkgload_1.3.1 MASS_7.3-58.1 [107] assertthat_0.2.1 rprojroot_2.0.3 [109] withr_2.5.0 GenomeInfoDbData_1.2.9 [111] mgcv_1.8-41 parallel_4.2.1 [113] grid_4.2.1 beachmat_2.14.0 [115] tidyr_1.2.1 rmarkdown_2.17 [117] DelayedMatrixStats_1.20.0 Rtsne_0.16 [119] shiny_1.7.3 ggbeeswarm_0.6.0 Bibliography "],["microbiome-community.html", "Chapter 9 Community composition 9.1 Visualizing taxonomic composition Session Info", " Chapter 9 Community composition .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } library(mia) data(&quot;GlobalPatterns&quot;, package=&quot;mia&quot;) tse &lt;- GlobalPatterns 9.1 Visualizing taxonomic composition 9.1.1 Composition barplot A typical way to visualize microbiome composition is by using composition barplot. In the following, relative abundance is calculated and top taxa are retrieved for the Phylum rank. Thereafter, the barplot is visualized ordering rank by abundance values and samples by “Bacteroidetes”: library(miaViz) # Computing relative abundance tse &lt;- relAbundanceCounts(tse) # Getting top taxa on a Phylum level tse_phylum &lt;- agglomerateByRank(tse, rank =&quot;Phylum&quot;, onRankOnly=TRUE) top_taxa &lt;- getTopTaxa(tse_phylum,top = 5, assay_name = &quot;relabundance&quot;) # Renaming the &quot;Phylum&quot; rank to keep only top taxa and the rest to &quot;Other&quot; phylum_renamed &lt;- lapply(rowData(tse)$Phylum, function(x){if (x %in% top_taxa) {x} else {&quot;Other&quot;}}) rowData(tse)$Phylum &lt;- as.character(phylum_renamed) # Visualizing the composition barplot, with samples order by &quot;Bacteroidetes&quot; plotAbundance(tse, assay_name=&quot;relabundance&quot;, rank = &quot;Phylum&quot;, order_rank_by=&quot;abund&quot;, order_sample_by = &quot;Bacteroidetes&quot;) 9.1.2 Composition heatmap Community composition can be visualized with heatmap, where the horizontal axis represents samples and the vertical axis the taxa. Color of each intersection point represents abundance of a taxon in a specific sample. Here, abundances are first CLR (centered log-ratio) transformed to remove compositionality bias. Then Z transformation is applied to CLR-transformed data. This shifts all taxa to zero mean and unit variance, allowing visual comparison between taxa that have different absolute abundance levels. After these rough visual exploration techniques, we can visualize the abundances at Phylum level. library(ggplot2) # Add clr-transformation on samples tse_phylum &lt;- transformSamples(tse_phylum, method = &quot;relabundance&quot;, pseudocount = 1) tse_phylum &lt;- transformSamples(tse_phylum, assay_name = &quot;relabundance&quot;, method = &quot;clr&quot;) # Add z-transformation on features (taxa) tse_phylum &lt;- transformFeatures(tse_phylum, assay_name = &quot;clr&quot;, method = &quot;z&quot;, name = &quot;clr_z&quot;) # Melts the assay df &lt;- meltAssay(tse_phylum, assay_name = &quot;clr_z&quot;) # Determines the scaling of colours maxval &lt;- round(max(abs(df$clr_z))) limits &lt;- c(-maxval, maxval) breaks &lt;- seq(from = min(limits), to = max(limits), by = 0.5) colours &lt;- c(&quot;darkblue&quot;, &quot;blue&quot;, &quot;white&quot;, &quot;red&quot;, &quot;darkred&quot;) # Creates a ggplot object ggplot(df, aes(x = SampleID, y = FeatureID, fill = clr_z)) + geom_tile() + scale_fill_gradientn(name = &quot;CLR + Z transform&quot;, breaks = breaks, limits = limits, colours = colours) + theme(text = element_text(size=10), axis.text.x = element_text(angle=45, hjust=1), legend.key.size = unit(1, &quot;cm&quot;)) + labs(x = &quot;Samples&quot;, y = &quot;Taxa&quot;) In addition, there are also other packages that provide functions for more complex heatmaps, such as iheatmapr and ComplexHeatmap. sechm package provides wrapper for ComplexHeatmap and its usage is explained in chapter 14 along with the pheatmap package for clustered heatmaps. Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] miaViz_1.5.4 ggraph_2.1.0 [3] ggplot2_3.4.0 mia_1.5.17 [5] MultiAssayExperiment_1.24.0 TreeSummarizedExperiment_2.1.4 [7] Biostrings_2.66.0 XVector_0.38.0 [9] SingleCellExperiment_1.20.0 SummarizedExperiment_1.28.0 [11] Biobase_2.58.0 GenomicRanges_1.50.1 [13] GenomeInfoDb_1.34.2 IRanges_2.32.0 [15] S4Vectors_0.36.0 BiocGenerics_0.44.0 [17] MatrixGenerics_1.10.0 matrixStats_0.62.0-9005 [19] BiocStyle_2.24.0 rebook_1.6.0 loaded via a namespace (and not attached): [1] plyr_1.8.7 igraph_1.3.5 [3] lazyeval_0.2.2 splines_4.2.1 [5] BiocParallel_1.32.1 scater_1.26.0 [7] digest_0.6.30 yulab.utils_0.0.5 [9] htmltools_0.5.3 viridis_0.6.2 [11] fansi_1.0.3 magrittr_2.0.3 [13] memoise_2.0.1 ScaledMatrix_1.6.0 [15] cluster_2.1.4 DECIPHER_2.26.0 [17] graphlayouts_0.8.3 colorspace_2.0-3 [19] blob_1.2.3 ggrepel_0.9.2 [21] xfun_0.34 dplyr_1.0.10 [23] crayon_1.5.2 RCurl_1.98-1.9 [25] jsonlite_1.8.3 graph_1.74.0 [27] ape_5.6-2 glue_1.6.2 [29] polyclip_1.10-4 gtable_0.3.1 [31] zlibbioc_1.44.0 DelayedArray_0.24.0 [33] BiocSingular_1.14.0 scales_1.2.1 [35] DBI_1.1.3 Rcpp_1.0.9 [37] viridisLite_0.4.1 decontam_1.18.0 [39] gridGraphics_0.5-1 tidytree_0.4.1 [41] bit_4.0.4 rsvd_1.0.5 [43] dir.expiry_1.4.0 ellipsis_0.3.2 [45] pkgconfig_2.0.3 XML_3.99-0.12 [47] farver_2.1.1 scuttle_1.8.0 [49] CodeDepends_0.6.5 sass_0.4.2 [51] utf8_1.2.2 ggplotify_0.1.0 [53] tidyselect_1.2.0 labeling_0.4.2 [55] rlang_1.0.6 reshape2_1.4.4 [57] munsell_0.5.0 tools_4.2.1 [59] cachem_1.0.6 cli_3.4.1 [61] DirichletMultinomial_1.40.0 generics_0.1.3 [63] RSQLite_2.2.18 evaluate_0.18 [65] stringr_1.4.1 fastmap_1.1.0 [67] yaml_2.3.6 ggtree_3.4.4 [69] knitr_1.40 bit64_4.0.5 [71] tidygraph_1.2.2 purrr_0.3.5 [73] nlme_3.1-160 sparseMatrixStats_1.10.0 [75] aplot_0.1.8 compiler_4.2.1 [77] beeswarm_0.4.0 filelock_1.0.2 [79] treeio_1.22.0 tibble_3.1.8 [81] tweenr_2.0.2 bslib_0.4.1 [83] stringi_1.7.8 highr_0.9 [85] lattice_0.20-45 Matrix_1.5-1 [87] vegan_2.6-4 permute_0.9-7 [89] vctrs_0.5.0 pillar_1.8.1 [91] lifecycle_1.0.3 BiocManager_1.30.19 [93] jquerylib_0.1.4 BiocNeighbors_1.16.0 [95] bitops_1.0-7 irlba_2.3.5.1 [97] patchwork_1.1.2 R6_2.5.1 [99] bookdown_0.29 gridExtra_2.3 [101] vipor_0.4.5 codetools_0.2-18 [103] MASS_7.3-58.1 assertthat_0.2.1 [105] withr_2.5.0 GenomeInfoDbData_1.2.9 [107] mgcv_1.8-41 parallel_4.2.1 [109] grid_4.2.1 ggfun_0.0.8 [111] beachmat_2.14.0 tidyr_1.2.1 [113] rmarkdown_2.17 DelayedMatrixStats_1.20.0 [115] ggnewscale_0.4.8 ggforce_0.4.1 [117] ggbeeswarm_0.6.0 "],["clustering.html", "Chapter 10 Community typing (clustering) 10.1 Hiearchical clustering 10.2 K-means clustering 10.3 Dirichlet Multinomial Mixtures (DMM) 10.4 Community Detection 10.5 Biclustering 10.6 Additional Community Typing", " Chapter 10 Community typing (clustering) .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } library(mia) data(&quot;GlobalPatterns&quot;, package=&quot;mia&quot;) tse &lt;- GlobalPatterns Clustering is an unsupervised machine learning technique. The idea of it is to find clusters from the data. A cluster is a group of features/samples that share pattern. For example, with clustering, we can find group of samples that share similar community composition. There are multiple clustering algorithms available. 10.1 Hiearchical clustering Hiearchical clustering is a clustering method that aims to find hiearchy between samples/features. There are to approaches: agglomerative (“bottom-up”) and divisive (“top-down”). In agglomerative approach, each observation is first unique cluster. Algorithm continues by agglomerating similar clusters. Divisive approach starts with one cluster that contains all the observations. Clusters are splitted recursively to clusters that differ the most. Clustering ends when each cluster contains only one observation. Hiearchical clustering can be visualized with dendrogram tree. In each splitting point, the three is divided into two clusters leading to hierarchy. Let’s load data from mia package. library(mia) library(vegan) # Load experimental data data(peerj13075) (tse &lt;- peerj13075) ## class: TreeSummarizedExperiment ## dim: 674 58 ## metadata(0): ## assays(1): counts ## rownames(674): OTU1 OTU2 ... OTU2567 OTU2569 ## rowData names(6): kingdom phylum ... family genus ## colnames(58): ID1 ID2 ... ID57 ID58 ## colData names(5): Sample Geographical_location Gender Age Diet ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: NULL ## rowTree: NULL ## colLinks: NULL ## colTree: NULL Hierarchical clustering requires 2 steps. In the fist step, dissimilarities are calculated. In prior to that, data transformation is applied if needed. Since sequencing data is compositional, relative transformation is applied. In the second step, clustering is performed based on dissimilarities. # Apply transformation tse &lt;- transformSamples(tse, method = &quot;relabundance&quot;) # Get the assay assay &lt;- assay(tse, &quot;relabundance&quot;) # Transpose assay --&gt; samples are now in rows --&gt; we are clustering samples assay &lt;- t(assay) # Calculate distances diss &lt;- vegdist(assay, method = &quot;bray&quot;) # Perform hierarchical clustering hc &lt;- hclust(diss, method = &quot;complete&quot;) # To visualize, convert hclust object into dendrogram object dendro &lt;- as.dendrogram(hc) # Plot dendrogram plot(dendro) We can use dendrogram to determine the number of clusters. Usually, the tree is splitted where the length of branches are the longest. However, as we can see from the dendrogram, clusters are no clear. Let’s use an algorithm to solve the best number of clusters. if( !require(NbClust) ){ install.packages(&quot;NbClust&quot;) library(NbClust) } # Determine the optimal number of clusters res &lt;- NbClust(diss = diss, distance = NULL, method = &quot;ward.D2&quot;, index = &quot;silhouette&quot;) ## ## Only frey, mcclain, cindex, sihouette and dunn can be computed. To compute the other indices, data matrix is needed res$Best.nc ## Number_clusters Value_Index ## 15.0000 0.4543 Based on the result, let’s divide observations into 15 clusters. if( !require(dendextend) ){ install.packages(&quot;dendextend&quot;) library(dendextend) } # Find clusters cutree(hc, k = 15) ## ID1 ID2 ID3 ID4 ID5 ID6 ID7 ID8 ID9 ID10 ID11 ID12 ID13 ID14 ID15 ID16 ## 1 2 3 4 5 5 2 2 2 6 5 5 2 5 2 5 ## ID17 ID18 ID19 ID20 ID21 ID22 ID23 ID24 ID25 ID26 ID27 ID28 ID29 ID30 ID31 ID32 ## 5 4 5 5 7 8 9 5 3 1 8 8 8 3 1 2 ## ID33 ID34 ID35 ID36 ID37 ID38 ID39 ID40 ID41 ID42 ID43 ID44 ID45 ID46 ID47 ID48 ## 2 2 2 2 2 9 10 11 6 5 4 2 9 1 12 2 ## ID49 ID50 ID51 ID52 ID53 ID54 ID55 ID56 ID57 ID58 ## 4 4 2 8 7 13 14 3 8 15 # Making colors for 6 clusters col_val_map &lt;- randomcoloR::distinctColorPalette(15) %&gt;% as.list() %&gt;% setNames(paste0(&quot;clust_&quot;,seq(15))) dend &lt;- color_branches(dendro, k=15, col=unlist(col_val_map)) labels(dend) &lt;- NULL plot(dend) 10.2 K-means clustering Because, we were not able to find clusters with hierarchical clustering, let’s try k-means clustering. In k-means clustering, observations are divided into clusters so that the mean distances between observations and cluster centers are minimized; an observation belongs to cluster whose center is the nearest. The algorithm starts by dividing observation to random clusters whose number is defined by user. The centroids of clusters are then calculated. After that, observations’ allocation to clusters are updated so that the means are minimized. Again, centroid are calculated, and algorithm continues iteratively until the assignments do not change. The number of clusters can be determined based on algorithm. Here we utilize silhouette analysis. if( !require(factoextra) ){ install.packages(&quot;factoextra&quot;) library(factoextra) } # Convert dist object into matrix diss &lt;- as.matrix(diss) # Perform silhouette analysis and plot the result fviz_nbclust(diss, kmeans, method = &quot;silhouette&quot;) Based on the result of silhouette analysis, we choose 3 to be the number of clusters in k-means clustering. library(scater) # The first step is random, add seed for reproducibility set.seed(15463) # Perform k-means clustering with 3 clusters km &lt;- kmeans(diss, 3, nstart = 25) # Add the result to colData colData(tse)$clusters &lt;- as.factor(km$cluster) # Perform PCoA so that we can visualize clusters tse &lt;- runMDS(tse, exprs_values = &quot;relabundance&quot;, FUN = vegan::vegdist, method = &quot;bray&quot;) # Plot PCoA and color clusters plotReducedDim(tse, &quot;MDS&quot;, colour_by = &quot;clusters&quot;) 10.3 Dirichlet Multinomial Mixtures (DMM) This section focus on DMM analysis. One technique that allows to search for groups of samples that are similar to each other is the Dirichlet-Multinomial Mixture Model. In DMM, we first determine the number of clusters (k) that best fit the data (model evidence) using Laplace approximation. After fitting the model with k clusters, we obtain for each sample k probabilities that reflect the probability that a sample belongs to the given cluster. Let’s cluster the data with DMM clustering. # Runs model and calculates the most likely number of clusters from 1 to 7. # Since this is a large dataset it takes long computational time. # For this reason we use only a subset of the data; agglomerated by Phylum as a rank. tse &lt;- GlobalPatterns tse &lt;- agglomerateByRank(tse, rank = &quot;Phylum&quot;, agglomerateTree=TRUE) tse_dmn &lt;- mia::runDMN(tse, name = &quot;DMN&quot;, k = 1:7) # It is stored in metadata tse_dmn ## class: TreeSummarizedExperiment ## dim: 67 26 ## metadata(2): agglomerated_by_rank DMN ## assays(1): counts ## rownames(67): Phylum:Crenarchaeota Phylum:Euryarchaeota ... ## Phylum:Synergistetes Phylum:SR1 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (67 rows) ## rowTree: 1 phylo tree(s) (66 leaves) ## colLinks: NULL ## colTree: NULL Return information on metadata that the object contains. names(metadata(tse_dmn)) ## [1] &quot;agglomerated_by_rank&quot; &quot;DMN&quot; This returns a list of DMN objects for a closer investigation. getDMN(tse_dmn) ## [[1]] ## class: DMN ## k: 1 ## samples x taxa: 26 x 67 ## Laplace: 7715 BIC: 7802 AIC: 7760 ## ## [[2]] ## class: DMN ## k: 2 ## samples x taxa: 26 x 67 ## Laplace: 7673 BIC: 7927 AIC: 7842 ## ## [[3]] ## class: DMN ## k: 3 ## samples x taxa: 26 x 67 ## Laplace: 7683 BIC: 8069 AIC: 7942 ## ## [[4]] ## class: DMN ## k: 4 ## samples x taxa: 26 x 67 ## Laplace: 7751 BIC: 8274 AIC: 8103 ## ## [[5]] ## class: DMN ## k: 5 ## samples x taxa: 26 x 67 ## Laplace: 7854 BIC: 8553 AIC: 8340 ## ## [[6]] ## class: DMN ## k: 6 ## samples x taxa: 26 x 67 ## Laplace: 7926 BIC: 8796 AIC: 8540 ## ## [[7]] ## class: DMN ## k: 7 ## samples x taxa: 26 x 67 ## Laplace: 8003 BIC: 9051 AIC: 8752 Show Laplace approximation (model evidence) for each model of the k models. library(miaViz) plotDMNFit(tse_dmn, type = &quot;laplace&quot;) Return the model that has the best fit. getBestDMNFit(tse_dmn, type = &quot;laplace&quot;) ## class: DMN ## k: 2 ## samples x taxa: 26 x 67 ## Laplace: 7673 BIC: 7927 AIC: 7842 10.3.1 PCoA for ASV-level data with Bray-Curtis; with DMM clusters shown with colors Group samples and return DMNGroup object that contains a summary. Patient status is used for grouping. dmn_group &lt;- calculateDMNgroup(tse_dmn, variable = &quot;SampleType&quot;, exprs_values = &quot;counts&quot;, k = 2, seed=.Machine$integer.max) dmn_group ## class: DMNGroup ## summary: ## k samples taxa NLE LogDet Laplace BIC AIC ## Feces 2 4 67 1078.3 -106.26 901.1 1171.9 1213 ## Freshwater 2 2 67 889.6 -97.20 716.9 936.4 1025 ## Freshwater (creek) 2 3 67 1600.3 862.19 1907.3 1674.5 1735 ## Mock 2 3 67 1008.4 -55.40 856.6 1082.5 1143 ## Ocean 2 3 67 1096.7 -56.66 944.3 1170.9 1232 ## Sediment (estuary) 2 3 67 1195.5 18.63 1080.8 1269.7 1331 ## Skin 2 3 67 992.6 -85.05 826.1 1066.8 1128 ## Soil 2 3 67 1380.3 11.20 1261.8 1454.5 1515 ## Tongue 2 2 67 783.0 -107.79 605.0 829.8 918 Mixture weights (rough measure of the cluster size). DirichletMultinomial::mixturewt(getBestDMNFit(tse_dmn)) ## pi theta ## 1 0.5385 20.58 ## 2 0.4615 15.28 Samples-cluster assignment probabilities / how probable it is that sample belongs to each cluster head(DirichletMultinomial::mixture(getBestDMNFit(tse_dmn))) ## [,1] [,2] ## CL3 1.000e+00 5.050e-17 ## CC1 1.000e+00 3.903e-22 ## SV1 1.000e+00 1.957e-12 ## M31Fcsw 7.886e-26 1.000e+00 ## M11Fcsw 1.132e-16 1.000e+00 ## M31Plmr 1.124e-13 1.000e+00 Contribution of each taxa to each component head(DirichletMultinomial::fitted(getBestDMNFit(tse_dmn))) ## [,1] [,2] ## Phylum:Crenarchaeota 0.30382 0.1354654 ## Phylum:Euryarchaeota 0.23114 0.1468632 ## Phylum:Actinobacteria 1.21371 1.0600245 ## Phylum:Spirochaetes 0.21393 0.1318415 ## Phylum:MVP-15 0.02982 0.0007669 ## Phylum:Proteobacteria 6.84469 1.8153216 Get the assignment probabilities prob &lt;- DirichletMultinomial::mixture(getBestDMNFit(tse_dmn)) # Add column names colnames(prob) &lt;- c(&quot;comp1&quot;, &quot;comp2&quot;) # For each row, finds column that has the highest value. Then extract the column # names of highest values. vec &lt;- colnames(prob)[max.col(prob,ties.method = &quot;first&quot;)] Computing the euclidean PCoA and storing it as a data frame # Does clr transformation. Pseudocount is added, because data contains zeros. tse &lt;- transformCounts(tse, method = &quot;relabundance&quot;, pseudocount = 1) tse &lt;- transformCounts(tse, &quot;relabundance&quot;, method = &quot;clr&quot;) library(scater) # Does principal coordinate analysis df &lt;- calculateMDS(tse, exprs_values = &quot;clr&quot;, method = &quot;euclidean&quot;) # Creates a data frame from principal coordinates euclidean_pcoa_df &lt;- data.frame(pcoa1 = df[,1], pcoa2 = df[,2]) # Creates a data frame that contains principal coordinates and DMM information euclidean_dmm_pcoa_df &lt;- cbind(euclidean_pcoa_df, dmm_component = vec) # Creates a plot euclidean_dmm_plot &lt;- ggplot(data = euclidean_dmm_pcoa_df, aes(x=pcoa1, y=pcoa2, color = dmm_component)) + geom_point() + labs(x = &quot;Coordinate 1&quot;, y = &quot;Coordinate 2&quot;, title = &quot;PCoA with Aitchison distances&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_dmm_plot 10.4 Community Detection Another approach for discovering communities within the samples of the data, is to run community detection algorithms after building a graph. The following demonstration builds a graph based on the k nearest-neighbors and performs the community detection on the fly. bluster (Lun 2021) package offers several clustering methods, among which graph-based are present, enabling the community detection task. Installing package: if(!require(bluster)){ BiocManager::install(&quot;bluster&quot;) } The algorithm used is “short random walks” (Pons and Latapy 2006). Graph is constructed using different k values (the number of nearest neighbors to consider during graph construction) using the robust centered log ratio (rclr) assay data. Then plotting the communities using UMAP (McInnes, Healy, and Melville 2018) ordination as a visual exploration aid. In the following demonstration we use the enterotype dataset from the (Ernst, Shetty, and Lahti 2020) package. library(bluster) library(patchwork) # For arranging several plots as a grid library(scater) data(&quot;enterotype&quot;, package=&quot;mia&quot;) tse &lt;- enterotype tse &lt;- transformCounts(tse, method = &quot;rclr&quot;) # Performing and storing UMAP tse &lt;- runUMAP(tse, name=&quot;UMAP&quot;, exprs_values=&quot;rclr&quot;) k &lt;- c(2,3,5,10) ClustAndPlot &lt;- function(x) { # Creating the graph and running the short random walks algorithm graph_clusters &lt;- clusterRows(t(assays(tse)$rclr), NNGraphParam(k=x)) # Results of the clustering as a color for each sample plotUMAP(tse, colour_by = I(graph_clusters)) + labs(title = paste0(&quot;k = &quot;, x)) } # Applying the function for different k values plots &lt;- lapply(k,ClustAndPlot) # Displaying plots in a grid (plots[[1]] + plots[[2]]) / (plots[[3]] + plots[[4]]) Similarly, the bluster (Lun 2021) package offers clustering diagnostics that can be used for judging the clustering quality (see Assorted clustering diagnostics). In the following, Silhouette width as a diagnostic tool is computed and results are visualized for each case presented earlier. For more about Silhouettes read (Rousseeuw 1987). ClustDiagPlot &lt;- function(x) { # Getting the clustering results graph_clusters &lt;- clusterRows(t(assays(tse)$rclr), NNGraphParam(k=x)) # Computing the diagnostic info sil &lt;- approxSilhouette(t(assays(tse)$rclr), graph_clusters) # Plotting as a boxlpot to observe cluster separation boxplot(split(sil$width, graph_clusters), main=paste0(&quot;k = &quot;, x)) } # Applying the function for different k values res &lt;- lapply(k,ClustDiagPlot) 10.5 Biclustering Biclustering methods cluster rows and columns simultaneously in order to find subsets of correlated features/samples. Here, we use following packages: biclust cobiclust cobiclust is especially developed for microbiome data whereas biclust is more general method. In this section, we show three different cases and example solutions to apply biclustering to them. Taxa vs samples Taxa vs biomolecule/biomarker Taxa vs taxa Biclusters can be visualized using heatmap or boxplot, for instance. For checking purposes, also scatter plot might be valid choice. Check more ideas for heatmaps from chapters 14 and @ref(microbiome-community. 10.5.1 Taxa vs samples When you have microbial abundance matrices, we suggest to use cobiclust which is designed for microbial data. Load example data library(mia) data(&quot;HintikkaXOData&quot;) mae &lt;- HintikkaXOData Only the most prevalent taxa are included in analysis. # Subset data in the first experiment mae[[1]] &lt;- subsetByPrevalentTaxa(mae[[1]], rank = &quot;Genus&quot;, prevalence = 0.2, detection = 0.001) # clr-transform in the first experiment mae[[1]] &lt;- transformSamples(mae[[1]], method = &quot;relabundance&quot;, pseudocount = 1) mae[[1]] &lt;- transformSamples(mae[[1]], &quot;relabundance&quot;, method = &quot;clr&quot;) cobiclust takes counts table as an input and gives cobiclust object as an output. It includes clusters for taxa and samples. if(!require(cobiclust)){ install.packages(&quot;cobiclust&quot;) library(cobiclust) } # Do clustering; use counts table´ clusters &lt;- cobiclust(assay(mae[[1]], &quot;counts&quot;)) # Get clusters row_clusters &lt;- clusters$classification$rowclass col_clusters &lt;- clusters$classification$colclass # Add clusters to rowdata and coldata rowData(mae[[1]])$clusters &lt;- factor(row_clusters) colData(mae[[1]])$clusters &lt;- factor(col_clusters) # Order data based on clusters mae[[1]] &lt;- mae[[1]][order(rowData(mae[[1]])$clusters), order(colData(mae[[1]])$clusters)] # Print clusters clusters$classification ## $rowclass ## [1] 1 1 1 1 2 2 1 1 1 1 1 1 2 2 2 2 1 2 1 1 2 1 2 2 1 1 2 1 1 1 1 1 2 1 1 2 1 1 ## [39] 1 1 1 1 1 1 1 1 1 2 1 2 1 1 1 2 1 1 1 ## ## $colclass ## C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 C11 C12 C13 C14 C15 C16 C17 C18 C19 C20 ## 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## C21 C22 C23 C24 C25 C26 C27 C28 C29 C30 C31 C32 C33 C34 C35 C36 C37 C38 C39 C40 ## 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 Next we can plot clusters. Commonly used plot is heatmap with annotations. if(!require(pheatmap)){ install.packages(&quot;pheatmap&quot;) library(pheatmap) } # z-transform for heatmap mae[[1]] &lt;- transformFeatures(mae[[1]], assay_name = &quot;clr&quot;, method = &quot;z&quot;, name = &quot;clr_z&quot;) # Create annotations. When column names are equal, they should share levels. # Here samples include 3 clusters, and taxa 2. That is why we have to make # column names unique. annotation_col &lt;- data.frame(colData(mae[[1]])[, &quot;clusters&quot;, drop = F]) colnames(annotation_col) &lt;- &quot;col_clusters&quot; annotation_row &lt;- data.frame(rowData(mae[[1]])[, &quot;clusters&quot;, drop = F]) colnames(annotation_row) &lt;- &quot;row_clusters&quot; # Create a heatmap pheatmap(assay(mae[[1]], &quot;clr_z&quot;), cluster_rows = F, cluster_cols = F, annotation_col = annotation_col, annotation_row = annotation_row) Boxplot is commonly used to summarize the results: if(!require(ggplot2)){ install.packages(&quot;ggplot2&quot;) library(ggplot2) } if(!require(patchwork)){ install.packages(&quot;patchwork&quot;) library(patchwork) } # ggplot requires data in melted format melt_assay &lt;- meltAssay(mae[[1]], assay_name = &quot;clr&quot;, add_col_data = T, add_row_data = T) # patchwork two plots side-by-side p1 &lt;- ggplot(melt_assay) + geom_boxplot(aes(x = clusters.x, y = clr)) + labs(x = &quot;Taxa clusters&quot;) p2 &lt;- ggplot(melt_assay) + geom_boxplot(aes(x = clusters.y, y = clr)) + labs(x = &quot;Sample clusters&quot;) p1 + p2 10.5.2 Taxa vs biomolecules Here, we analyze cross-correlation between taxa and metabolites. This is a case, where we use biclust method which is suitable for numeric matrices in general. # Samples must be in equal order # (Only 1st experiment was ordered in cobiclust step leading to unequal order) mae[[1]] &lt;- mae[[1]][ , colnames(mae[[2]]) ] # Make rownames unique since it is require by other steps rownames(mae[[1]]) &lt;- make.unique(rownames(mae[[1]])) # Calculate correlations corr &lt;- getExperimentCrossCorrelation(mae, 1, 2, assay_name1 = &quot;clr&quot;, assay_name2 = &quot;nmr&quot;, mode = &quot;matrix&quot;, cor_threshold = 0.2) biclust takes matrix as an input and returns biclust object. # Load package if(!require(biclust)){ install.packages(&quot;biclust&quot;) library(biclust) } # Set seed for reproducibility set.seed(3973) # Find biclusters bc &lt;- biclust(corr, method=BCPlaid(), fit.model = y ~ m, background = TRUE, shuffle = 100, back.fit = 0, max.layers = 10, iter.startup = 10, iter.layer = 100, verbose = FALSE) bc ## ## An object of class Biclust ## ## call: ## biclust(x = corr, method = BCPlaid(), fit.model = y ~ m, background = TRUE, ## shuffle = 100, back.fit = 0, max.layers = 10, iter.startup = 10, ## iter.layer = 100, verbose = FALSE) ## ## There was no cluster found The object includes cluster information. However compared to cobiclust, biclust object includes only information about clusters that were found, not general cluster. Meaning that if one cluster size of 5 features was found out of 20 features, those 15 features do not belong to any cluster. That is why we have to create an additional cluster for features/samples that are not assigned into any cluster. # Functions for obtaining biclust information # Get clusters for rows and columns .get_biclusters_from_biclust &lt;- function(bc, assay){ # Get cluster information for columns and rows bc_columns &lt;- t(bc@NumberxCol) bc_columns &lt;- data.frame(bc_columns) bc_rows &lt;- bc@RowxNumber bc_rows &lt;- data.frame(bc_rows) # Get data into right format bc_columns &lt;- .manipulate_bc_data(bc_columns, assay, &quot;col&quot;) bc_rows &lt;- .manipulate_bc_data(bc_rows, assay, &quot;row&quot;) return(list(bc_columns = bc_columns, bc_rows = bc_rows)) } # Input clusters, and how many observations there should be, i.e., the number of samples or features .manipulate_bc_data &lt;- function(bc_clusters, assay, row_col){ # Get right dimension dim &lt;- ifelse(row_col == &quot;col&quot;, ncol(assay), nrow(assay)) # Get column/row names if( row_col == &quot;col&quot; ){ names &lt;- colnames(assay) } else{ names &lt;- rownames(assay) } # If no clusters were found, create one. Otherwise create additional cluster which # contain those samples that are not included in clusters that were found. if( nrow(bc_clusters) != dim ){ bc_clusters &lt;- data.frame(cluster = rep(TRUE, dim)) } else { # Create additional cluster that includes those samples/features that # are not included in other clusters. vec &lt;- ifelse(rowSums(bc_clusters) &gt; 0, FALSE, TRUE) # If additional cluster contains samples, then add it if ( any(vec) ){ bc_clusters &lt;- cbind(bc_clusters, vec) } } # Adjust row and column names rownames(bc_clusters) &lt;- names colnames(bc_clusters) &lt;- paste0(&quot;cluster_&quot;, 1:ncol(bc_clusters)) return(bc_clusters) } # Get biclusters bcs &lt;- .get_biclusters_from_biclust(bc, corr) bicluster_rows &lt;- bcs$bc_rows bicluster_columns &lt;- bcs$bc_columns # Print biclusters for rows head(bicluster_rows) ## cluster_1 ## D_5__Ruminiclostridium 5 TRUE ## D_5__uncultured TRUE ## D_5__Lactococcus TRUE ## D_5__Lachnoclostridium TRUE ## D_5__Holdemania TRUE ## D_5__Anaerostipes TRUE Let’s collect information for the scatter plot. # Function for obtaining sample-wise sum, mean, median, and mean variance for each cluster .sum_mean_median_var &lt;- function(tse1, tse2, assay_name1, assay_name2, clusters1, clusters2){ list &lt;- list() # Create a data frame that includes all the information for(i in 1:ncol(clusters1) ){ # Subset data based on cluster tse_subset1 &lt;- tse1[clusters1[,i], ] tse_subset2 &lt;- tse2[clusters2[,i], ] # Get assay assay1 &lt;- assay(tse_subset1, assay_name1) assay2 &lt;- assay(tse_subset2, assay_name2) # Calculate sum, mean, median, and mean variance sum1 &lt;- colSums2(assay1, na.rm = T) mean1 &lt;- colMeans2(assay1, na.rm = T) median1 &lt;- colMedians(assay1, na.rm = T) var1 &lt;- colVars(assay1, na.rm = T) sum2 &lt;- colSums2(assay2, na.rm = T) mean2 &lt;- colMeans2(assay2, na.rm = T) median2 &lt;- colMedians(assay2, na.rm = T) var2 &lt;- colVars(assay2, na.rm = T) list[[i]] &lt;- data.frame(sample = colnames(tse1), sum1, sum2, mean1, mean2, median1, median2, var1, var2) } return(list) } # Calculate info df &lt;- .sum_mean_median_var(mae[[1]], mae[[2]], &quot;clr&quot;, &quot;nmr&quot;, bicluster_rows, bicluster_columns) Now we can create a scatter plot. X-axis includes median clr abundance of microbiome and y-axis median absolute concentration of each metabolite. Each data point represents a single sample. From the plots, we can see that there is low negative correlation in both cluster 1 and 3. This means that when abundance of bacteria belonging to cluster 1 or 3 is higher, the concentration of metabolites of cluster 1 or 3 is lower, and vice versa. pics &lt;- list() for(i in seq_along(df)){ pics[[i]] &lt;- ggplot(df[[i]]) + geom_point(aes(x = median1, y = median2)) + labs(title = paste0(&quot;Cluster &quot;, i), x = &quot;Taxa (clr median)&quot;, y = &quot;Metabolites (abs. median)&quot;) print(pics[[i]]) } # pics[[1]] + pics[[2]] + pics[[3]] pheatmap does not allow boolean values, so they must be converted into factors. bicluster_columns &lt;- data.frame(apply(bicluster_columns, 2, as.factor)) bicluster_rows &lt;- data.frame(apply(bicluster_rows, 2, as.factor)) Again, we can plot clusters with heatmap. # Adjust colors for all clusters if( ncol(bicluster_rows) &gt; ncol(bicluster_columns) ){ cluster_names &lt;- colnames(bicluster_rows) } else { cluster_names &lt;- colnames(bicluster_columns) } annotation_colors &lt;- list() for(name in cluster_names){ annotation_colors[[name]] &lt;- c(&quot;TRUE&quot; = &quot;red&quot;, &quot;FALSE&quot; = &quot;white&quot;) } # Create a heatmap pheatmap(corr, cluster_cols = F, cluster_rows = F, annotation_col = bicluster_columns, annotation_row = bicluster_rows, annotation_colors = annotation_colors) 10.5.3 Taxa vs taxa Third and final example deals with situation where we want to analyze correlation between taxa. biclust is suitable for this. # Calculate cross-correlation corr &lt;- getExperimentCrossCorrelation(mae, 1, 1, assay_name1 = &quot;clr&quot;, assay_name2 = &quot;clr&quot;, mode = &quot;matrix&quot;, cor_threshold = 0.2, verbose = F, show_warning = F) # Find biclusters bc &lt;- biclust(corr, method=BCPlaid(), fit.model = y ~ m, background = TRUE, shuffle = 100, back.fit = 0, max.layers = 10, iter.startup = 10, iter.layer = 100, verbose = FALSE) # Get biclusters bcs &lt;- .get_biclusters_from_biclust(bc, corr) bicluster_rows &lt;- bcs$bc_rows bicluster_columns &lt;- bcs$bc_columns # Create a column that combines information # If row/column includes in multiple clusters, cluster numbers are separated with &quot;_&amp;_&quot; bicluster_columns$clusters &lt;- apply(bicluster_columns, 1, function(x){paste(paste(which(x)), collapse = &quot;_&amp;_&quot;) }) bicluster_columns &lt;- bicluster_columns[, &quot;clusters&quot;, drop = FALSE] bicluster_rows$clusters &lt;- apply(bicluster_rows, 1, function(x){paste(paste(which(x)), collapse = &quot;_&amp;_&quot;) }) bicluster_rows &lt;- bicluster_rows[, &quot;clusters&quot;, drop = FALSE] # Convert boolean values into factor bicluster_columns &lt;- data.frame(apply(bicluster_columns, 2, as.factor)) bicluster_rows &lt;- data.frame(apply(bicluster_rows, 2, as.factor)) pheatmap(corr, cluster_cols = F, cluster_rows = F, annotation_col = bicluster_columns, annotation_row = bicluster_rows) 10.6 Additional Community Typing For more community typing techniques applied to the ‘SprockettTHData’ data set, see the attached .Rmd file. Link: Rmd Bibliography "],["differential-abundance.html", "Chapter 11 Differential abundance 11.1 Differential abundance analysis 11.2 Tree-based methods Session Info", " Chapter 11 Differential abundance .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 11.1 Differential abundance analysis This section provides an overview and examples of differential abundance analysis (DAA) based on one of the openly available datasets in mia to illustrate how to perform differential abundance analysis (DAA). DAA identifies differences in the abundances of individual taxonomic groups between two or more groups (e.g. treatment vs control). This can be performed at any phylogenetic level. We perform DAA to identify biomarkers and/or gain understanding of a complex system by looking at its isolated components. For example, identifying that a bacterial taxon is different between a patient group with disease X vs a healthy control group might lead to important insights into the pathophysiology. Changes in the microbiota might be cause or a consequence of a disease. Either way, it can help to understand the system as a whole. Be aware that this approach has also been criticized recently (Quinn, Gordon-Rodriguez, and Erb 2021). 11.1.1 Examples and tools There are many tools to perform DAA. The most popular tools, without going into evaluating whether or not they perform well for this task, are: - ALDEx2 - ANCOM-BC - corncob - DESeq2 - edgeR - LEFse - limma voom - LinDA - MaAsLin2 - metagenomeSeq - t-test - Wilcoxon test We recommend to have a look at Nearing et al. (2022) who compared all these listed methods across 38 different datasets. Because different methods use different approaches (parametric vs non-parametric, different normalization techiniques, assumptions etc.), results can differ between methods. Unfortunately, as Nearing et al. (2022) point out, they can differ substantially. Therefore, it is highly recommended to pick several methods to get an idea about how robust and potentially reproducible your findings are depending on the method. In this section we demonstrate 4 methods that can be recommended based on recent literature (ANCOM-BC, ALDEx2, Maaslin2 and LinDA) and we will compare the results between them. Note that the purpose of this section is to show how to perform DAA in R, not how to correctly do causal inference. Depending on your experimental setup and your theory, you must determine how to specify any model exactly. E.g., there might be confounding factors that might drive (the absence of) differences between the shown groups that we ignore here for simplicity. However, we will show how you could include covariates in those models. Furthermore, we picked a dataset that merely has microbial abundances in a TSE object as well as a grouping variable in the sample data. We simplify the analysis by only including 2 of the 3 groups. library(mia) library(patchwork) library(tidySummarizedExperiment) library(ALDEx2) library(Maaslin2) library(MicrobiomeStat) library(knitr) library(tidyverse) # For ANCOMBC we need development version # Can be installed with: # remotes::install_github(&quot;FrederickHuangLin/ANCOMBC&quot;) library(ANCOMBC) # we use the dmn_se dataset and restrict it to # obese vs lean for easy illustration data(dmn_se) se &lt;- dmn_se # To enable all features and advantages of TreeSE, we convert the object from SE to TreeSE tse &lt;- as(se, &quot;TreeSummarizedExperiment&quot;) tse &lt;- tse[ ,colData(tse)$pheno != &quot;Overwt&quot;] colData(tse)$pheno &lt;- fct_drop(colData(tse)$pheno, &quot;Overwt&quot;) # how many observations do we have per group? count(as.data.frame(colData(tse)), pheno) %&gt;% kable() pheno n Lean 61 Obese 193 # set a seed because some tools can randomly vary and then produce # different results: set.seed(1) 11.1.2 Prevalence Filtering Before we jump to our analyses, we may want to perform prevalence filtering. Nearing et al. (2022) found that applying a 10% threshold for the prevalence of the taxa generally resulted in more robust results. Some tools have builtin arguments for that. By applying the threshold to our input data, we can make sure it is applied for all tools. Below we show how to do this in mia: tse &lt;- subsetByPrevalentTaxa(tse, detection = 0, prevalence = 0.1) 11.1.3 ALDEx2 In this section, we will show how to perform a simple ALDEx2 analysis. If you wanted to pick a single method, this method could be recommended to use. According to the developers experience, it tends to identify the common features identified by other methods. This statement is in line with a recent independent evaluation by Nearing et al. (2022). Please also have a look at the more extensive vignette that covers this flexible tool in more depth. ALDEx2 estimates technical variation within each sample per taxon by utilizing the Dirichlet distribution. It furthermore applies the centered-log-ratio transformation (or closely related log-ratio transforms). Depending on the experimental setup, it will perform a two sample Welch’s T-test and Wilcoxon-test or a one-way ANOVA and Kruskal-Wallis-test. For more complex study designs, there is a possibility to utilize the glm functionality within ALDEx2. The Benjamini-Hochberg procedure is applied in any case to correct for multiple testing. Below we show a simple example that illustrates the workflow. # Generate Monte Carlo samples of the Dirichlet distribution for each sample. # Convert each instance using the centred log-ratio transform. # This is the input for all further analyses. x &lt;- aldex.clr( reads = assay(tse), conds = colData(tse)$pheno, # 128 recommened for ttest, 1000 for rigorous effect size calculation mc.samples = 128, denom = &quot;all&quot;, verbose = FALSE ) # calculates expected values of the Welch&#39;s t-test and Wilcoxon rank test on # the data returned by aldex.clr x_tt &lt;- aldex.ttest( x, paired.test = FALSE, verbose = FALSE) # determines the median clr abundance of the feature in all samples and in # groups, the median difference between the two groups, the median variation # within each group and the effect size, which is the median of the ratio # of the between group difference and the larger of the variance within groups x_effect &lt;- aldex.effect(x, CI = TRUE, verbose = FALSE) # combine all outputs aldex_out &lt;- data.frame(x_tt, x_effect) Now, we can create a so called Bland-Altman or MA plot (left). It shows the association between the relative abundance and the magnitude of the difference per sample. Next to that, we can also create a plot that shows the dispersion on the x-axis instead of log-ratio abundance. Red dots represent genera that are differentially abundant (\\(q \\leq 0.1\\)) between the 2 groups. Black points are rare taxa and grey ones are abundant taxa. The dashed line represent an effect size of 1. See Gloor, Macklaim, and Fernandes (2016) to learn more about these plots. par(mfrow = c(1, 2)) aldex.plot( aldex_out, type = &quot;MA&quot;, test = &quot;welch&quot;, xlab = &quot;Log-ratio abundance&quot;, ylab = &quot;Difference&quot;, cutoff = 0.05 ) aldex.plot( aldex_out, type = &quot;MW&quot;, test = &quot;welch&quot;, xlab = &quot;Dispersion&quot;, ylab = &quot;Difference&quot;, cutoff = 0.05 ) The evaluation as differential abundant in above plots is based on the corrected pvalue. According to the ALDEx2 developers, the safest approach is to identify those features where the 95% CI of the effect size does not cross 0. As we can see in below table, this is not the case for any of the identified genera (see overlap column, which indicates the proportion of overlap). Also, the authors recommend to focus on effect sizes and CIs rather than interpreting the pvalue. To keep the comparison simple, we will here use the pvalue as decision criterion. But please be aware that the effect size together with the CI is a better answer to the question we are typically interested in (see also this article). rownames_to_column(aldex_out, &quot;genus&quot;) %&gt;% filter(wi.eBH &lt;= 0.05) %&gt;% # here we chose the wilcoxon output rather than tt select(genus, we.eBH, wi.eBH, effect, overlap) %&gt;% kable() genus we.eBH wi.eBH effect overlap Alistipes 0.0009 0.0001 -0.3823 0.2979 Barnesiella 0.0442 0.0066 -0.3229 0.3489 Catenibacterium 0.0266 0.0330 0.2713 0.3718 Lactobacillus 0.0282 0.0183 0.2983 0.3537 Megasphaera 0.0000 0.0001 0.5249 0.2758 Oscillibacter 0.0004 0.0014 -0.3681 0.3291 Parabacteroides 0.0541 0.0133 -0.2832 0.3509 Phascolarctobacterium 0.0238 0.0077 -0.3491 0.3404 Uknown 0.0786 0.0439 -0.2474 0.3852 11.1.4 ANCOM-BC The analysis of composition of microbiomes with bias correction (ANCOM-BC) (Lin and Peddada 2020) is a recently developed method for differential abundance testing. It is based on an earlier published approach (Mandal et al. 2015). The previous version of ANCOM was among the methods that produced the most consistent results and is probably a conservative approach (Nearing et al. 2022). However, the new ANCOM-BC method operates quite differently compared to the former ANCOM method. As the only method, ANCOM-BC incorporates the so called sampling fraction into the model. The latter term could be empirically estimated by the ratio of the library size to the microbial load. According to the authors, variations in this sampling fraction would bias differential abundance analyses if ignored. Furthermore, this method provides p-values and confidence intervals for each taxon. It also controls the FDR and it is computationally simple to implement. As we will see below, to obtain results, all that is needed is to pass a tse object to the ancombc() function. Below, we first specify a formula. In this formula, other covariates could potentially be included to adjust for confounding. We show this further below. Please check the function documentation to learn about the additional arguments that we specify below. # perform the analysis out &lt;- ancombc( data = tse, formula = &quot;pheno&quot;, p_adj_method = &quot;fdr&quot;, prv_cut = 0, # no prev filtering necessary anymore lib_cut = 0, group = &quot;pheno&quot;, struc_zero = TRUE, neg_lb = TRUE, tol = 1e-5, max_iter = 100, conserve = TRUE, alpha = 0.05, global = TRUE # multi group comparison will be deactivated automatically ) # store the results in res res &lt;- out$res The object out contains all model output. Again, see the documentation of the function under Value for an explanation of all the output objects. Our question whether taxa are differentially abundant can be answered by looking at the res object, which now contains dataframes with the coefficients, standard errors, p-values and q-values. Conveniently, there is a dataframe diff_abn. Here, for each taxon it is indicated whether it is differentially abundant between the groups (again, keep in mind that the answer is not black-white). Below we show the first 6 entries of this dataframe: kable(head(res$diff_abn)) taxon (Intercept) phenoObese Acetanaerobacterium FALSE TRUE Acetivibrio TRUE FALSE Acidaminococcus TRUE TRUE Akkermansia FALSE FALSE Alistipes TRUE TRUE Allisonella TRUE FALSE 11.1.5 MaAsLin2 Next, we will illustrate how to use MaAsLin2, which is the next generation of MaAsLin. As it is based on generalized linear models, it is flexible for different study designs and covariate structures. The official package tutorial can be found here. # maaslin expects features as columns and samples as rows # for both the asv/otu table as well as meta data asv &lt;- t(assay(tse)) meta_data &lt;- data.frame(colData(tse)) # you can specifiy different GLMs/normalizations/transforms. We used similar # settings as in Nearing et al. (2021) here: fit_data &lt;- Maaslin2( asv, meta_data, output = &quot;DAA example&quot;, transform = &quot;AST&quot;, fixed_effects = &quot;pheno&quot;, # random_effects = c(...), # you can also fit MLM by specifying random effects # specifying a ref is especially important if you have more than 2 levels reference = &quot;pheno,Lean&quot;, normalization = &quot;TSS&quot;, standardize = FALSE, min_prevalence = 0 # prev filterin already done ) # which genera are identified as differentially abundant? (leave out &quot;head&quot; to # see all) kable(head(filter(fit_data$results, qval &lt;= 0.05))) feature metadata value coef stderr pval name qval N N.not.zero Megasphaera pheno Obese 0.0489 0.0093 0 phenoObese 0e+00 254 78 Barnesiella pheno Obese -0.0297 0.0068 0 phenoObese 2e-04 254 111 Parabacteroides pheno Obese -0.0219 0.0050 0 phenoObese 2e-04 254 163 Phascolarctobacterium pheno Obese -0.0325 0.0072 0 phenoObese 2e-04 254 99 Alistipes pheno Obese -0.0523 0.0123 0 phenoObese 3e-04 254 227 Desulfovibrio pheno Obese -0.0134 0.0032 0 phenoObese 3e-04 254 72 # A folder will be created that is called like the above specified output. # It contains also figures to visualize the difference between genera # for the significant ones. 11.1.6 LinDA Lastly, we cover linear models for differential abundance analysis of microbiome compositional data (Zhou et al. (2022)). This tool is very similar to ANCOMBC with few differences: 1) LinDA correct for the compositional bias differently using the mode of all regression coefficients. 2) The authors claim that it runs 100-1000x faster than ANCOMBC and 3) it support hierarchical models. The latter could be ignored as ANCOMBC will be supporting hierarchical models with the next release. Nevertheless, LinDA seems a promising tool that achieves the best power/fdr trade-off together with ANCOMBC according to the authors. The speed might make it the choice for bigger datasets or datasets with a very high number of features. otu.tab &lt;- as.data.frame(assay(tse)) meta &lt;- as.data.frame(colData(tse)) %&gt;% select(pheno) res &lt;- linda( otu.tab, meta, formula = &#39;~pheno&#39;, alpha = 0.05, prev.filter = 0, mean.abund.filter = 0) ## 0 features are filtered! ## The filtered data has 254 samples and 55 features will be tested! ## Imputation approach is used. ## Fit linear models ... ## Completed. # to scan the table for genera where H0 could be rejected: kable(head(filter(as.data.frame(res$output), phenoObese.reject))) phenoObese.baseMean phenoObese.log2FoldChange phenoObese.lfcSE phenoObese.stat phenoObese.pvalue phenoObese.padj phenoObese.reject phenoObese.df Acetanaerobacterium 918.5 -0.7591 0.1619 -4.687 0.0000 0.0000 TRUE 252 Acidaminococcus 372.9 0.7394 0.2327 3.178 0.0017 0.0051 TRUE 252 Akkermansia 827.6 -0.5110 0.2168 -2.357 0.0192 0.0422 TRUE 252 Alistipes 23944.9 -1.7646 0.3127 -5.644 0.0000 0.0000 TRUE 252 Asaccharobacter 621.0 -0.4913 0.1467 -3.350 0.0009 0.0039 TRUE 252 Bacteroides 272640.7 -0.8874 0.2686 -3.304 0.0011 0.0040 TRUE 252 11.1.7 Comparison of the methods When we compare the methods in the context of a research question, we could look at e.g. at whether they agree based on the applied decision criterion (e.g. adjusted p value &lt; 0.05). That is what we illustrate here. First we will look at how many taxa were identified by each method to begin with. In the next step we will look at the intersection of identified taxa. To achieve that, we first create a dataframe that summarises the decision criterion for each method and shows a score from 0 to 3 indicating how many methods agreed on a particular taxon. # Rename &quot;taxon&quot; column from ancombc results so that it match with others colnames(out$res$diff_abn)[colnames(out$res$diff_abn) == &quot;taxon&quot;] &lt;- &quot;genus&quot; summ &lt;- full_join( rownames_to_column(aldex_out, &quot;genus&quot;) %&gt;% select(genus, aldex2 = wi.eBH), out$res$diff_abn %&gt;% select(genus, ancombc = phenoObese), by = &quot;genus&quot;) %&gt;% full_join( select(fit_data$results, genus = feature, maaslin2 = qval), by = &quot;genus&quot;) %&gt;% full_join( rownames_to_column(as.data.frame(res$output), &quot;genus&quot;) %&gt;% select(genus, LinDA = phenoObese.reject), by = &quot;genus&quot;) %&gt;% mutate( across(c(aldex2, maaslin2), ~ .x &lt;= 0.05), # the following line would be necessary without prevalence filtering # as some methods output NA #across(-genus, function(x) ifelse(is.na(x), FALSE, x)), score = rowSums(across(c(aldex2, ancombc, maaslin2, LinDA))) ) # This is how it looks like: kable(head(summ)) genus aldex2 ancombc maaslin2 LinDA score Acetanaerobacterium FALSE TRUE TRUE TRUE 3 Acetivibrio FALSE FALSE FALSE FALSE 0 Acidaminococcus FALSE TRUE TRUE TRUE 3 Akkermansia FALSE FALSE FALSE TRUE 1 Alistipes TRUE TRUE TRUE TRUE 4 Allisonella FALSE FALSE FALSE FALSE 0 Now we can answer our questions: # how many genera were identified by each method? summarise(summ, across(where(is.logical), sum)) %&gt;% kable() aldex2 ancombc maaslin2 LinDA 9 22 16 25 # which genera are identified by all methods? filter(summ, score == 4) %&gt;% kable() genus aldex2 ancombc maaslin2 LinDA score Alistipes TRUE TRUE TRUE TRUE 4 Barnesiella TRUE TRUE TRUE TRUE 4 Catenibacterium TRUE TRUE TRUE TRUE 4 Lactobacillus TRUE TRUE TRUE TRUE 4 Megasphaera TRUE TRUE TRUE TRUE 4 Oscillibacter TRUE TRUE TRUE TRUE 4 Parabacteroides TRUE TRUE TRUE TRUE 4 Phascolarctobacterium TRUE TRUE TRUE TRUE 4 We see that each method identified at least 9 genera as differentially abundant. Eight of those that were identified by ALDEx2, were also identified by the other methods. We could plot the data for any method or for those taxa that were identified by all methods: plot_data &lt;- data.frame(t(assay(tse))) plot_data$pheno &lt;- colData(tse)$pheno # create a plot for each genus where the score is indicated in the title plots &lt;- pmap(select(summ, genus, score), function(genus, score) { ggplot(plot_data, aes_string(&quot;pheno&quot;, genus)) + geom_boxplot(aes(fill = pheno), outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.5) + ggtitle(glue::glue(&quot;Score {score}&quot;)) + theme_bw() + theme(legend.position = &quot;none&quot;) }) # now we can show only those genera that have at least score 3 (or 2 or 1) robust_plots &lt;- plots[summ$score == 4] # to display this nicely in the book we use patchwork here: # (we show first 8) robust_plots[[1]] + robust_plots[[2]] + robust_plots[[3]] + robust_plots[[4]] + robust_plots[[5]] + robust_plots[[6]] + robust_plots[[7]] + robust_plots[[8]] + plot_layout(nrow = 2) # or if we have most trust in any specific method we can show genera that # are differentially abundant according to that method and then look in the # title how many methods also identified it (we only show first 6 here): ancombc_plots &lt;- plots[summ$ancombc] ancombc_plots[[1]] + ancombc_plots[[2]] + ancombc_plots[[3]] + ancombc_plots[[4]] + ancombc_plots[[5]] + ancombc_plots[[6]] 11.1.8 Confounding variables To perform causal inference, it is crucial that the method is able to include covariates in the model. This is not possible with e.g. the Wilcoxon test. Other methods such as both ANCOM methods, ALDEx2, LinDA, MaAsLin2 and others allow this. Below we show how to include a covariate in ANCOM-BC. It is very similar for all the methods that allow this. Since in this dataset there are no covariates, I first simulate a new variable and add it to the TSE object. # Add random age variable for demonstration colData(tse)$age &lt;- sample(18:64, ncol(tse), replace = TRUE) out_cov = ancombc( data = tse, formula = &quot;pheno + age&quot;, # here we add age to the model p_adj_method = &quot;fdr&quot;, prv_cut = 0, # we did that already lib_cut = 0, group = &quot;pheno&quot;, struc_zero = TRUE, neg_lb = TRUE, tol = 1e-5, max_iter = 100, conserve = TRUE, alpha = 0.05, global = TRUE ) # now the model answers the question: holding age constant, are # bacterial taxa differentially abundant? Or, if that is of interest, # holding phenotype constant, is age associated with bacterial abundance? # Again we only show the first 6 entries. kable(head(out_cov$res$diff_abn)) taxon (Intercept) phenoObese age Acetanaerobacterium FALSE TRUE FALSE Acetivibrio FALSE FALSE FALSE Acidaminococcus FALSE TRUE FALSE Akkermansia FALSE FALSE FALSE Alistipes TRUE TRUE FALSE Allisonella TRUE FALSE FALSE In the next section of this book chapter we cover methods that can also take into account the phylogenetic information of bacterial taxa to perform group-wise associations. 11.2 Tree-based methods 11.2.1 Group-wise associations testing based on balances with fido TreeSummarizedExperiment frequently includes a Phylogenetic tree along with associated data about the experiment (at colData), that holds covariates which can be used for analyzing group-wise associations. Such an analysis could be performed with the function pibble from the fido package, that offers a Multinomial Logistic-Normal Linear Regression model; see vignette of package. The following presents such an exemplary analysis based on the data of Sprockett et al. (2020) available through microbiomeDataSets package. if (!require(fido)){ # installing the fido package devtools::install_github(&quot;jsilve24/fido&quot;) } ## distribut... (NA -&gt; 0.3.1 ) [CRAN] ## tensorA (NA -&gt; 0.36.2) [CRAN] ## svUnit (NA -&gt; 1.0.6 ) [CRAN] ## HDInterval (NA -&gt; 0.2.2 ) [CRAN] ## posterior (NA -&gt; 1.3.1 ) [CRAN] ## arrayhelpers (NA -&gt; 1.1-0 ) [CRAN] ## ggdist (NA -&gt; 3.2.0 ) [CRAN] ## RcppNumer... (NA -&gt; 0.4-0 ) [CRAN] ## tidybayes (NA -&gt; 3.0.2 ) [CRAN] ## * checking for file ‘/tmp/RtmpkK4QPs/remotes2fe7574bd5fe/jsilve24-fido-260856d/DESCRIPTION’ ... OK ## * preparing ‘fido’: ## * checking DESCRIPTION meta-information ... OK ## * cleaning src ## * running ‘cleanup’ ## * checking for LF line-endings in source and make files and shell scripts ## * checking for empty or unneeded directories ## * building ‘fido_1.0.3.tar.gz’ Loading the libraries and importing data: library(fido) library(mia) library(microbiomeDataSets) tse &lt;- SprockettTHData() We pick three covariates (“Sex”,“Age_Years”,“Delivery_Mode”) during this analysis as an example, and beforehand we check for missing data: cov_names &lt;- c(&quot;Sex&quot;,&quot;Age_Years&quot;,&quot;Delivery_Mode&quot;) na_counts &lt;- apply(is.na(colData(tse)[,cov_names]), 2, sum) na_summary&lt;-as.data.frame(na_counts,row.names=cov_names) We drop samples with na values at the covariates (features) under analysis: tse &lt;- tse[ , !is.na(colData(tse)$Delivery_Mode) ] tse &lt;- tse[ , !is.na(colData(tse)$Age_Years) ] We agglomerate the data at a Phylum rank. Note: Large assay data (along with the covariates/features data) could prevent the analysis later, since the computation will construct matrices that would not always fit memory. tse_phylum &lt;- agglomerateByRank(tse, &quot;Phylum&quot;) We extract the counts assay and feature data to build the model matrix having an extra row of ones presenting the intercept for the regression task later: Y &lt;- assays(tse_phylum)$counts # design matrix # taking 3 covariates sample_data&lt;-as.data.frame(colData(tse_phylum)[,cov_names]) X &lt;- t(model.matrix(~Sex+Age_Years+Delivery_Mode,data=sample_data)) Building the parameters for the pibble call to build the model; see more at vignette: n_taxa&lt;-nrow(Y) upsilon &lt;- n_taxa+3 Omega &lt;- diag(n_taxa) G &lt;- cbind(diag(n_taxa-1), -1) Xi &lt;- (upsilon-n_taxa)*G%*%Omega%*%t(G) Theta &lt;- matrix(0, n_taxa-1, nrow(X)) Gamma &lt;- diag(nrow(X)) Automatically initializing the priors and visualizing their distributions: priors &lt;- pibble(NULL, X, upsilon, Theta, Gamma, Xi) names_covariates(priors) &lt;- rownames(X) plot(priors, pars=&quot;Lambda&quot;) + ggplot2::xlim(c(-5, 5)) Estimating the posterior by including the data at Y. Note: Some computational failures could occur (see discussion) the arguments multDirichletBoot calcGradHess could be passed in such case. priors$Y &lt;- Y posterior &lt;- refit(priors, optim_method=&quot;adam&quot;, multDirichletBoot=0.5) # ,, calcGradHess=FALSE Printing a summary about the posterior predictive distribution: ppc_summary(posterior) ## Proportions of Observations within 95% Credible Interval: 0.998 Plotting the summary of the posterior distributions of the regression parameters: names_categories(posterior) &lt;- rownames(Y) plot(posterior,par=&quot;Lambda&quot;,focus.cov=rownames(X)[2:4]) Seemingly the covariate “Age_Years” does not have effect on the model as “Delivery_Mode” would, and “Sex” to some extent. Let’s take a closer look at the two latter ones: plot(posterior, par=&quot;Lambda&quot;, focus.cov = rownames(X)[c(2,4)]) Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] fido_1.0.3 ANCOMBC_2.1.1 [3] forcats_0.5.2 stringr_1.4.1 [5] dplyr_1.0.10 purrr_0.3.5 [7] readr_2.1.3 tidyr_1.2.1 [9] tibble_3.1.8 ggplot2_3.4.0 [11] tidyverse_1.3.2 knitr_1.40 [13] MicrobiomeStat_1.1 Maaslin2_1.10.0 [15] ALDEx2_1.28.1 zCompositions_1.4.0-1 [17] truncnorm_1.0-8 NADA_1.6-1.1 [19] survival_3.4-0 MASS_7.3-58.1 [21] tidySummarizedExperiment_1.6.1 patchwork_1.1.2 [23] mia_1.5.17 MultiAssayExperiment_1.24.0 [25] TreeSummarizedExperiment_2.1.4 Biostrings_2.66.0 [27] XVector_0.38.0 SingleCellExperiment_1.20.0 [29] SummarizedExperiment_1.28.0 Biobase_2.58.0 [31] GenomicRanges_1.50.1 GenomeInfoDb_1.34.2 [33] IRanges_2.32.0 S4Vectors_0.36.0 [35] BiocGenerics_0.44.0 MatrixGenerics_1.10.0 [37] matrixStats_0.62.0-9005 BiocStyle_2.24.0 [39] rebook_1.6.0 loaded via a namespace (and not attached): [1] rsvd_1.0.5 Hmisc_4.7-1 [3] ps_1.7.2 class_7.3-20 [5] rprojroot_2.0.3 foreach_1.5.2 [7] crayon_1.5.2 rbibutils_2.2.9 [9] rhdf5filters_1.8.0 nlme_3.1-160 [11] backports_1.4.1 fBasics_4021.93 [13] posterior_1.3.1 reprex_2.0.2 [15] rlang_1.0.6 readxl_1.4.1 [17] irlba_2.3.5.1 callr_3.7.3 [19] nloptr_2.0.3 optparse_1.7.3 [21] scater_1.26.0 filelock_1.0.2 [23] BiocParallel_1.32.1 bit64_4.0.5 [25] glue_1.6.2 rngtools_1.5.2 [27] processx_3.8.0 parallel_4.2.1 [29] vipor_0.4.5 haven_2.5.1 [31] tidyselect_1.2.0 usethis_2.1.6 [33] phyloseq_1.40.0 XML_3.99-0.12 [35] distributional_0.3.1 xtable_1.8-4 [37] magrittr_2.0.3 evaluate_0.18 [39] Rdpack_2.4 scuttle_1.8.0 [41] cli_3.4.1 zlibbioc_1.44.0 [43] rstudioapi_0.14 doRNG_1.8.2 [45] miniUI_0.1.1.1 bslib_0.4.1 [47] rpart_4.1.19 treeio_1.22.0 [49] svUnit_1.0.6 shiny_1.7.3 [51] BiocSingular_1.14.0 xfun_0.34 [53] clue_0.3-62 pkgbuild_1.3.1 [55] multtest_2.52.0 cluster_2.1.4 [57] stable_1.1.6 biomformat_1.24.0 [59] expm_0.999-6 ggrepel_0.9.2 [61] logging_0.10-108 ape_5.6-2 [63] stabledist_0.7-1 png_0.1-7 [65] permute_0.9-7 withr_2.5.0 [67] bitops_1.0-7 plyr_1.8.7 [69] cellranger_1.1.0 pcaPP_2.0-3 [71] RcppZiggurat_0.1.6 e1071_1.7-12 [73] coda_0.19-4 pillar_1.8.1 [75] cachem_1.0.6 Rmpfr_0.8-9 [77] fs_1.5.2 rmutil_1.1.10 [79] hash_2.2.6.2 DelayedMatrixStats_1.20.0 [81] vctrs_0.5.0 ellipsis_0.3.2 [83] generics_0.1.3 devtools_2.4.5 [85] tools_4.2.1 foreign_0.8-83 [87] beeswarm_0.4.0 munsell_0.5.0 [89] emmeans_1.8.2 proxy_0.4-27 [91] DelayedArray_0.24.0 abind_1.4-5 [93] pkgload_1.3.1 fastmap_1.1.0 [95] compiler_4.2.1 httpuv_1.6.6 [97] sessioninfo_1.2.2 DescTools_0.99.47 [99] plotly_4.10.1 decontam_1.18.0 [101] GenomeInfoDbData_1.2.9 gridExtra_2.3 [103] arrayhelpers_1.1-0 lattice_0.20-45 [105] dir.expiry_1.4.0 deldir_1.0-6 [107] utf8_1.2.2 later_1.3.0 [109] jsonlite_1.8.3 scales_1.2.1 [111] gld_2.6.6 statip_0.2.3 [113] graph_1.74.0 ScaledMatrix_1.6.0 [115] tidytree_0.4.1 pbapply_1.5-0 [117] sparseMatrixStats_1.10.0 estimability_1.4.1 [119] lazyeval_0.2.2 promises_1.2.0.1 [121] doParallel_1.0.17 latticeExtra_0.6-30 [123] checkmate_2.1.0 rmarkdown_2.17 [125] statmod_1.4.37 igraph_1.3.5 [127] numDeriv_2016.8-1.1 yaml_2.3.6 [129] htmltools_0.5.3 memoise_2.0.1 [131] profvis_0.3.7 viridisLite_0.4.1 [133] gmp_0.6-7 digest_0.6.30 [135] assertthat_0.2.1 mime_0.12 [137] RSQLite_2.2.18 Rfast_2.0.6 [139] yulab.utils_0.0.5 Exact_3.2 [141] remotes_2.4.2 data.table_1.14.4 [143] urlchecker_1.0.1 blob_1.2.3 [145] vegan_2.6-4 lpsymphony_1.24.0 [147] modeest_2.4.0 splines_4.2.1 [149] Formula_1.2-4 labeling_0.4.2 [151] DECIPHER_2.26.0 Rhdf5lib_1.18.2 [153] googledrive_2.0.0 RCurl_1.98-1.9 [155] broom_1.0.1 hms_1.1.2 [157] modelr_0.1.9 rhdf5_2.40.0 [159] colorspace_2.0-3 base64enc_0.1-3 [161] BiocManager_1.30.19 ggbeeswarm_0.6.0 [163] nnet_7.3-18 sass_0.4.2 [165] Rcpp_1.0.9 bookdown_0.29 [167] mvtnorm_1.1-3 fansi_1.0.3 [169] tzdb_0.3.0 R6_2.5.1 [171] grid_4.2.1 lifecycle_1.0.3 [173] rootSolve_1.8.2.3 curl_4.3.3 [175] googlesheets4_1.0.1 minqa_1.2.5 [177] getopt_1.20.3 jquerylib_0.1.4 [179] robustbase_0.95-0 Matrix_1.5-1 [181] RColorBrewer_1.1-3 iterators_1.0.14 [183] htmlwidgets_1.5.4 beachmat_2.14.0 [185] timechange_0.1.1 timeSeries_4021.105 [187] rvest_1.0.3 mgcv_1.8-41 [189] CVXR_1.0-11 tensorA_0.36.2 [191] lmom_2.9 htmlTable_2.4.1 [193] codetools_0.2-18 lubridate_1.9.0 [195] prettyunits_1.1.1 dbplyr_2.2.1 [197] ggdist_3.2.0 gtable_0.3.1 [199] DBI_1.1.3 httr_1.4.4 [201] highr_0.9 tidybayes_3.0.2 [203] stringi_1.7.8 reshape2_1.4.4 [205] farver_2.1.1 spatial_7.3-15 [207] viridis_0.6.2 timeDate_4021.106 [209] xml2_1.3.3 boot_1.3-28 [211] BiocNeighbors_1.16.0 lme4_1.1-31 [213] interp_1.1-3 ade4_1.7-20 [215] energy_1.7-10 DEoptimR_1.0-11 [217] bit_4.0.4 jpeg_0.1-9 [219] pkgconfig_2.0.3 gargle_1.2.1 [221] lmerTest_3.1-3 gsl_2.1-7.1 [223] DirichletMultinomial_1.40.0 biglm_0.9-2.1 [225] CodeDepends_0.6.5 Bibliography "],["machine_learning.html", "Chapter 12 Machine learning 12.1 Supervised machine learning 12.2 Unsupervised machine learning Session Info", " Chapter 12 Machine learning .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } Machine learning (ML) is a part of artificial intelligence. There are multiple definitions, but “machine” refers to computation and “learning” to improving performance based on the data by finding patterns from it. Machine learning includes wide variety of methods from simple statistical methods to more complex methods such as neural-networks. Machine learning can be divided into supervised and unsupervised machine learning. Supervised ML is used to predict outcome based on the data. Unsupervised ML is used, for example, to reduce dimensionality (e.g. PCA) and to find clusters from the data (e.g., k-means clustering). 12.1 Supervised machine learning “Supervised” means that the training data is introduced before. The training data contains labels (e.g., patient status), and the model is fitted based on the training data. After fitting, the model is utilized to predict labels of data whose labels are not known. library(mia) # Load experimental data data(peerj13075) (tse &lt;- peerj13075) ## class: TreeSummarizedExperiment ## dim: 674 58 ## metadata(0): ## assays(1): counts ## rownames(674): OTU1 OTU2 ... OTU2567 OTU2569 ## rowData names(6): kingdom phylum ... family genus ## colnames(58): ID1 ID2 ... ID57 ID58 ## colData names(5): Sample Geographical_location Gender Age Diet ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: NULL ## rowTree: NULL ## colLinks: NULL ## colTree: NULL Let’s first preprocess the data. # Agglomerate data tse &lt;- agglomerateByRank(tse, rank = &quot;order&quot;) # Apply CLR transform tse &lt;- transformSamples(tse, method = &quot;relabundance&quot;, pseudocount = 1) tse &lt;- transformSamples(tse, assay_name = &quot;relabundance&quot;, method = &quot;clr&quot;) # Get assay assay &lt;- assay(tse, &quot;clr&quot;) # Transpose assay assay &lt;- t(assay) # Convert into data.frame df &lt;- as.data.frame(assay) # Add labels to assay labels &lt;- colData(tse)$Diet labels &lt;- as.factor(labels) df$diet &lt;- labels df[5, 5] ## [1] -0.4612 In the example below, we use mikropml package. We try to predict the diet type based on the data. if( !require(&quot;mikropml&quot;) ){ install.packages(&quot;mikropml&quot;) library(mikropml) } # Run random forest results &lt;- run_ml(df, &quot;rf&quot;, outcome_colname = &#39;diet&#39;, kfold = 2, cv_times = 5, training_frac = 0.8) # Print result confusionMatrix(data = results$trained_model$finalModel$predicted, reference = results$trained_model$finalModel$y) ## Confusion Matrix and Statistics ## ## Reference ## Prediction Mixed Veg ## Mixed 12 11 ## Veg 11 13 ## ## Accuracy : 0.532 ## 95% CI : (0.381, 0.679) ## No Information Rate : 0.511 ## P-Value [Acc &gt; NIR] : 0.443 ## ## Kappa : 0.063 ## ## Mcnemar&#39;s Test P-Value : 1.000 ## ## Sensitivity : 0.522 ## Specificity : 0.542 ## Pos Pred Value : 0.522 ## Neg Pred Value : 0.542 ## Prevalence : 0.489 ## Detection Rate : 0.255 ## Detection Prevalence : 0.489 ## Balanced Accuracy : 0.532 ## ## &#39;Positive&#39; Class : Mixed ## mikropml offers easier interface to caret package. However, we can also use it directly. Let’s use xgboost model which is another commonly used algorithm in bioinformatics. # Set seed for reproducibility set.seed(6358) # Specify train control train_control &lt;- trainControl(method = &quot;cv&quot;, number = 5, classProbs = TRUE, savePredictions = &quot;final&quot;, allowParallel = TRUE) # Specify hyperparameter tuning grid tune_grid &lt;- expand.grid(nrounds = c(50, 100, 200), max_depth = c(6, 8, 10), colsample_bytree = c(0.6, 0.8, 1), eta = c(0.1, 0.3), gamma = 0, min_child_weight = c(3, 4, 5), subsample = c(0.6, 0.8) ) # Train the model, use LOOCV to evaluate performance model &lt;- train(x = assay, y = labels, method = &quot;xgbTree&quot;, objective = &quot;binary:logistic&quot;, trControl = train_control, tuneGrid = tune_grid, metric = &quot;AUC&quot;, verbosity = 0 ) Let’s create ROC curve which is a commonly used method in binary classification. For unbalanced data, you might want to plot precision-recall curve. if( !require(MLeval) ){ install.packages(&quot;MLeval&quot;) library(MLeval) } # Calculate different evaluation metrics res &lt;- evalm(model, showplots = FALSE) # Use patchwork to plot ROC and precision-recall curve side-by-side library(patchwork) res$roc + res$proc + plot_layout(guides = &quot;collect&quot;) &amp; theme(legend.position = &#39;bottom&#39;) 12.2 Unsupervised machine learning “Unsupervised” means that the labels (e.g., patient status is not known), and patterns are learned based only the abundance table, for instance. Unsupervised ML is also known as a data mining where patterns are extracted from big datasets. For unsupervised machine learning, please refer to chapters that are listed below: Chapter 10 Chapter 8 Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] patchwork_1.1.2 MLeval_0.3 [3] caret_6.0-93 lattice_0.20-45 [5] ggplot2_3.4.0 mikropml_1.4.0 [7] mia_1.5.17 MultiAssayExperiment_1.24.0 [9] TreeSummarizedExperiment_2.1.4 Biostrings_2.66.0 [11] XVector_0.38.0 SingleCellExperiment_1.20.0 [13] SummarizedExperiment_1.28.0 Biobase_2.58.0 [15] GenomicRanges_1.50.1 GenomeInfoDb_1.34.2 [17] IRanges_2.32.0 S4Vectors_0.36.0 [19] BiocGenerics_0.44.0 MatrixGenerics_1.10.0 [21] matrixStats_0.62.0-9005 BiocStyle_2.24.0 [23] rebook_1.6.0 loaded via a namespace (and not attached): [1] plyr_1.8.7 lazyeval_0.2.2 [3] splines_4.2.1 BiocParallel_1.32.1 [5] listenv_0.8.0 scater_1.26.0 [7] digest_0.6.30 foreach_1.5.2 [9] yulab.utils_0.0.5 htmltools_0.5.3 [11] viridis_0.6.2 fansi_1.0.3 [13] magrittr_2.0.3 memoise_2.0.1 [15] MLmetrics_1.1.1 ScaledMatrix_1.6.0 [17] cluster_2.1.4 ROCR_1.0-11 [19] DECIPHER_2.26.0 recipes_1.0.2 [21] globals_0.16.1 gower_1.0.0 [23] timechange_0.1.1 hardhat_1.2.0 [25] colorspace_2.0-3 blob_1.2.3 [27] ggrepel_0.9.2 xfun_0.34 [29] dplyr_1.0.10 crayon_1.5.2 [31] RCurl_1.98-1.9 jsonlite_1.8.3 [33] graph_1.74.0 survival_3.4-0 [35] iterators_1.0.14 ape_5.6-2 [37] glue_1.6.2 gtable_0.3.1 [39] ipred_0.9-13 zlibbioc_1.44.0 [41] DelayedArray_0.24.0 kernlab_0.9-31 [43] BiocSingular_1.14.0 shape_1.4.6 [45] future.apply_1.10.0 scales_1.2.1 [47] DBI_1.1.3 Rcpp_1.0.9 [49] viridisLite_0.4.1 decontam_1.18.0 [51] tidytree_0.4.1 proxy_0.4-27 [53] bit_4.0.4 rsvd_1.0.5 [55] lava_1.7.0 prodlim_2019.11.13 [57] glmnet_4.1-4 dir.expiry_1.4.0 [59] farver_2.1.1 pkgconfig_2.0.3 [61] XML_3.99-0.12 scuttle_1.8.0 [63] nnet_7.3-18 CodeDepends_0.6.5 [65] sass_0.4.2 utf8_1.2.2 [67] labeling_0.4.2 tidyselect_1.2.0 [69] rlang_1.0.6 reshape2_1.4.4 [71] munsell_0.5.0 tools_4.2.1 [73] cachem_1.0.6 xgboost_1.6.0.1 [75] cli_3.4.1 DirichletMultinomial_1.40.0 [77] generics_0.1.3 RSQLite_2.2.18 [79] evaluate_0.18 stringr_1.4.1 [81] fastmap_1.1.0 yaml_2.3.6 [83] ModelMetrics_1.2.2.2 knitr_1.40 [85] bit64_4.0.5 randomForest_4.7-1.1 [87] purrr_0.3.5 future_1.29.0 [89] nlme_3.1-160 sparseMatrixStats_1.10.0 [91] compiler_4.2.1 beeswarm_0.4.0 [93] filelock_1.0.2 e1071_1.7-12 [95] treeio_1.22.0 tibble_3.1.8 [97] bslib_0.4.1 stringi_1.7.8 [99] highr_0.9 Matrix_1.5-1 [101] vegan_2.6-4 permute_0.9-7 [103] vctrs_0.5.0 pillar_1.8.1 [105] lifecycle_1.0.3 BiocManager_1.30.19 [107] jquerylib_0.1.4 BiocNeighbors_1.16.0 [109] data.table_1.14.4 bitops_1.0-7 [111] irlba_2.3.5.1 R6_2.5.1 [113] bookdown_0.29 gridExtra_2.3 [115] parallelly_1.32.1 vipor_0.4.5 [117] codetools_0.2-18 MASS_7.3-58.1 [119] assertthat_0.2.1 withr_2.5.0 [121] GenomeInfoDbData_1.2.9 mgcv_1.8-41 [123] parallel_4.2.1 grid_4.2.1 [125] rpart_4.1.19 beachmat_2.14.0 [127] timeDate_4021.106 tidyr_1.2.1 [129] class_7.3-20 rmarkdown_2.17 [131] DelayedMatrixStats_1.20.0 pROC_1.18.0 [133] lubridate_1.9.0 ggbeeswarm_0.6.0 "],["multi-assay_analyses.html", "Chapter 13 Multi-assay analyses 13.1 Cross-correlation Analysis 13.2 Multi-Omics Factor Analysis Session Info", " Chapter 13 Multi-assay analyses .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } library(mia) Multi-omics means that we integrate data from multiple sources. For example, we can integrate microbial abundances in the gut with biomolecular profiling data from blood samples. This kind of integrative multi-omic approaches can support the analysis of microbiome dysbiosis and facilitate the discovery of novel biomarkers for health and disease. With cross-correlation analysis, we can analyze how strongly and how differently variables are associated between each other. For instance, we can analyze if higher presence of a specific taxon equals to higher levels of a biomolecule. The data containers that the miaverse utilizes are scalable and they can contain different types of data in a same container. Because of that, the miaverse is well-suitable for multi-assay microbiome data which incorporates different types of complementary data sources in a single reproducible workflow. Another experiment can be stored in altExp slot of SE data container or both experiments can be stored side-by-side in MAE data container. Different experiments are first imported into SE or TreeSE data container similarly to the case when only one experiment is present. After that different experiments are combined into the same data container. Result is one TreeSE object with alternative experiment in altExp slot, or MAE object with multiple experiment in its experiment slot. As an example data, we use data from following publication: Hintikka L et al. (2021) Xylo-oligosaccharides in prevention of hepatic steatosis and adipose tissue inflammation: associating taxonomic and metabolomic patterns in fecal microbiotas with biclustering. In this article, mice were fed with high-fat and low-fat diets with or without prebiotics. The purpose of this was to study if prebiotics would reduce the negative impacts of high-fat diet. This example data can be loaded from microbiomeDataSets. The data is already in MAE format. It includes three different experiments: microbial abundance data, metabolite concentrations, and data about different biomarkers. Help for importing data into SE object you can find from here. # Load the data mae &lt;- microbiomeDataSets::HintikkaXOData() mae ## A MultiAssayExperiment object of 3 listed ## experiments with user-defined names and respective classes. ## Containing an ExperimentList class object of length 3: ## [1] microbiota: SummarizedExperiment with 12706 rows and 40 columns ## [2] metabolites: SummarizedExperiment with 38 rows and 40 columns ## [3] biomarkers: SummarizedExperiment with 39 rows and 40 columns ## Functionality: ## experiments() - obtain the ExperimentList instance ## colData() - the primary/phenotype DataFrame ## sampleMap() - the sample coordination DataFrame ## `$`, `[`, `[[` - extract colData columns, subset, or experiment ## *Format() - convert into a long or wide DataFrame ## assays() - convert ExperimentList to a SimpleList of matrices ## exportClass() - save data to flat files if(!require(stringr)){ install.packages(&quot;stringr&quot;) library(stringr) } # Drop off those bacteria that do not include information in Phylum or lower levels mae[[1]] &lt;- mae[[1]][!is.na(rowData(mae[[1]])$Phylum), ] # Clean taxonomy data, so that names do not include additional characters rowData(mae[[1]]) &lt;- DataFrame(apply(rowData(mae[[1]]), 2, str_remove, pattern = &quot;._[0-9]__&quot;)) # Microbiome data mae[[1]] ## class: SummarizedExperiment ## dim: 12613 40 ## metadata(0): ## assays(1): counts ## rownames(12613): GAYR01026362.62.2014 CVJT01000011.50.2173 ... ## JRJTB:03787:02429 JRJTB:03787:02478 ## rowData names(7): Phylum Class ... Species OTU ## colnames(40): C1 C2 ... C39 C40 ## colData names(0): # Metabolite data mae[[2]] ## class: SummarizedExperiment ## dim: 38 40 ## metadata(0): ## assays(1): nmr ## rownames(38): Butyrate Acetate ... Malonate 1,3-dihydroxyacetone ## rowData names(0): ## colnames(40): C1 C2 ... C39 C40 ## colData names(0): # Biomarker data mae[[3]] ## class: SummarizedExperiment ## dim: 39 40 ## metadata(0): ## assays(1): signals ## rownames(39): Triglycerides_liver CLSs_epi ... NPY_serum Glycogen_liver ## rowData names(0): ## colnames(40): C1 C2 ... C39 C40 ## colData names(0): 13.1 Cross-correlation Analysis Next we can do the cross-correlation analysis. Here we analyse if individual bacteria genera correlates with concentrations of individual metabolites. This helps as to answer the question: “If this bacteria is present, is this metabolite’s concentration then low or high”? # Agglomerate microbiome data at family level mae[[1]] &lt;- agglomerateByPrevalence(mae[[1]], rank = &quot;Family&quot;) # Does log10 transform for microbiome data mae[[1]] &lt;- transformSamples(mae[[1]], method = &quot;log10&quot;, pseudocount = 1) # Give unique names so that we do not have problems when we are creating a plot rownames(mae[[1]]) &lt;- getTaxonomyLabels(mae[[1]]) # Cross correlates data sets correlations &lt;- testExperimentCrossCorrelation(mae, experiment1 = 1, experiment2 = 2, assay_name1 = &quot;log10&quot;, assay_name2 = &quot;nmr&quot;, method = &quot;spearman&quot;, p_adj_threshold = NULL, cor_threshold = NULL, # Remove when mia is fixed mode = &quot;matrix&quot;, sort = TRUE, show_warnings = FALSE) Creates the heatmap if( !require(&quot;ComplexHeatmap&quot;) ){ BiocManager::install(&quot;ComplexHeatmap&quot;) library(&quot;ComplexHeatmap&quot;) } # Create a heatmap and store it plot &lt;- Heatmap(correlations$cor, # Print values to cells cell_fun = function(j, i, x, y, width, height, fill) { # If the p-value is under threshold if( !is.na(correlations$p_adj[i, j]) &amp; correlations$p_adj[i, j] &lt; 0.05 ){ # Print &quot;X&quot; grid.text(sprintf(&quot;%s&quot;, &quot;X&quot;), x, y, gp = gpar(fontsize = 8, col = &quot;black&quot;)) } }, heatmap_legend_param = list(title = &quot;&quot;, legend_height = unit(5, &quot;cm&quot;)) ) plot 13.2 Multi-Omics Factor Analysis Multi-Omics Factor Analysis (Argelaguet 2018) (MOFA) is an unsupervised method for integrating multi-omic data sets in a downstream analysis. It could be seen as a generalization of principal component analysis. Yet, with the ability to infer a latent (low-dimensional) representation, shared among the mutliple (-omics) data sets in hand. We use the R MOFA2 package for the analysis, and install the corresponding dependencies. if(!require(MOFA2)){ BiocManager::install(&quot;MOFA2&quot;) } # For inter-operability between Python and R, and setting Python dependencies, # reticulate package is needed if(!require(reticulate)){ install.packages(&quot;reticulate&quot;) } reticulate::install_miniconda(force = TRUE) ## [1] &quot;/github/home/.local/share/r-miniconda&quot; reticulate::use_miniconda(condaenv = &quot;env1&quot;, required = FALSE) reticulate::py_install(packages = c(&quot;mofapy2&quot;), pip = TRUE) The mae object could be used straight to create the MOFA model. Yet, we transform our assays since the model assumes normality per default. Other distributions that can be used, include Poisson or Bernoulli. library(MOFA2) # For simplicity, classify all high-fat diets as high-fat, and all the low-fat # diets as low-fat diets colData(mae)$Diet &lt;- ifelse(colData(mae)$Diet == &quot;High-fat&quot; | colData(mae)$Diet == &quot;High-fat + XOS&quot;, &quot;High-fat&quot;, &quot;Low-fat&quot;) # Removing duplicates at the microbiome data # which are also in form e.g. &quot;Ambiguous&quot; and &quot;uncultured&quot; taxa mae[[1]] &lt;- mae[[1]][!duplicated(rownames(assay(mae[[1]]))), ] # Transforming microbiome data with rclr mae[[1]] &lt;- transformCounts(mae[[1]], method = &quot;relabundance&quot;) mae[[1]] &lt;- transformCounts(mae[[1]], assay_name = &quot;relabundance&quot;, method = &quot;rclr&quot;) # Transforming metabolomic data with log10 mae[[2]] &lt;- transformSamples(mae[[2]], assay_name = &quot;nmr&quot;, method = &quot;log10&quot;) # Transforming biomarker data with z-transform mae[[3]] &lt;- transformFeatures(mae[[3]], assay_name = &quot;signals&quot;, method = &quot;z&quot;, pseudocount = 1) # Removing assays no longer needed assay(mae[[1]], &quot;counts&quot;) &lt;- NULL assay(mae[[1]], &quot;log10&quot;) &lt;- NULL assay(mae[[2]], &quot;nmr&quot;) &lt;- NULL assay(mae[[3]], &quot;signals&quot;) &lt;- NULL # Building our mofa model model &lt;- create_mofa_from_MultiAssayExperiment(mae, groups = &quot;Diet&quot;, extract_metadata = TRUE) model ## Untrained MOFA model with the following characteristics: ## Number of views: 3 ## Views names: microbiota metabolites biomarkers ## Number of features (per view): 38 38 39 ## Number of groups: 2 ## Groups names: High-fat Low-fat ## Number of samples (per group): 20 20 ## Model options could be defined as follows: model_opts &lt;- get_default_model_options(model) model_opts$num_factors &lt;- 5 head(model_opts) ## $likelihoods ## microbiota metabolites biomarkers ## &quot;gaussian&quot; &quot;gaussian&quot; &quot;gaussian&quot; ## ## $num_factors ## [1] 5 ## ## $spikeslab_factors ## [1] FALSE ## ## $spikeslab_weights ## [1] TRUE ## ## $ard_factors ## [1] TRUE ## ## $ard_weights ## [1] TRUE Model’s training options are defined with the following: train_opts &lt;- get_default_training_options(model) head(train_opts) ## $maxiter ## [1] 1000 ## ## $convergence_mode ## [1] &quot;fast&quot; ## ## $drop_factor_threshold ## [1] -1 ## ## $verbose ## [1] FALSE ## ## $startELBO ## [1] 1 ## ## $freqELBO ## [1] 5 Preparing and training the model: model.prepared &lt;- prepare_mofa( object = model, model_options = model_opts ) model.trained &lt;- run_mofa(model.prepared) Visualizing the variance explained: library(patchwork) library(ggplot2) wrap_plots( plot_variance_explained(model.trained, x=&quot;view&quot;, y=&quot;factor&quot;, plot_total = T), nrow = 2 ) + plot_annotation(title = &quot;Variance Explained per factor and assay&quot;, theme = theme(plot.title = element_text(hjust = 0.5))) The top weights for each assay using all 5 factors: plots &lt;- lapply(c(&quot;microbiota&quot;, &quot;metabolites&quot;,&quot;biomarkers&quot;), function(name) { plot_top_weights(model.trained, view = name, factors = &quot;all&quot;, nfeatures = 10) + labs(title = paste0(&quot;Top weights of the &quot;, name,&quot; assay&quot;)) }) wrap_plots(plots, nrow = 3) &amp; theme(text = element_text(size = 8)) More tutorials and examples of using the package are found at: link Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] grid stats4 stats graphics grDevices utils datasets [8] methods base other attached packages: [1] ggplot2_3.4.0 patchwork_1.1.2 [3] MOFA2_1.6.0 reticulate_1.26 [5] ComplexHeatmap_2.12.1 stringr_1.4.1 [7] microbiomeDataSets_1.1.7 mia_1.5.17 [9] MultiAssayExperiment_1.24.0 TreeSummarizedExperiment_2.1.4 [11] Biostrings_2.66.0 XVector_0.38.0 [13] SingleCellExperiment_1.20.0 SummarizedExperiment_1.28.0 [15] Biobase_2.58.0 GenomicRanges_1.50.1 [17] GenomeInfoDb_1.34.2 IRanges_2.32.0 [19] S4Vectors_0.36.0 BiocGenerics_0.44.0 [21] MatrixGenerics_1.10.0 matrixStats_0.62.0-9005 [23] BiocStyle_2.24.0 rebook_1.6.0 loaded via a namespace (and not attached): [1] utf8_1.2.2 tidyselect_1.2.0 [3] RSQLite_2.2.18 AnnotationDbi_1.58.0 [5] BiocParallel_1.32.1 Rtsne_0.16 [7] munsell_0.5.0 ScaledMatrix_1.6.0 [9] codetools_0.2-18 withr_2.5.0 [11] colorspace_2.0-3 filelock_1.0.2 [13] highr_0.9 knitr_1.40 [15] labeling_0.4.2 GenomeInfoDbData_1.2.9 [17] farver_2.1.1 bit64_4.0.5 [19] pheatmap_1.0.12 rhdf5_2.40.0 [21] rprojroot_2.0.3 basilisk_1.8.1 [23] vctrs_0.5.0 treeio_1.22.0 [25] generics_0.1.3 xfun_0.34 [27] BiocFileCache_2.4.0 R6_2.5.1 [29] doParallel_1.0.17 ggbeeswarm_0.6.0 [31] clue_0.3-62 rsvd_1.0.5 [33] bitops_1.0-7 rhdf5filters_1.8.0 [35] cachem_1.0.6 DelayedArray_0.24.0 [37] assertthat_0.2.1 promises_1.2.0.1 [39] scales_1.2.1 beeswarm_0.4.0 [41] gtable_0.3.1 beachmat_2.14.0 [43] Cairo_1.6-0 rlang_1.0.6 [45] GlobalOptions_0.1.2 splines_4.2.1 [47] lazyeval_0.2.2 BiocManager_1.30.19 [49] yaml_2.3.6 reshape2_1.4.4 [51] httpuv_1.6.6 tools_4.2.1 [53] bookdown_0.29 ellipsis_0.3.2 [55] decontam_1.18.0 jquerylib_0.1.4 [57] RColorBrewer_1.1-3 Rcpp_1.0.9 [59] plyr_1.8.7 sparseMatrixStats_1.10.0 [61] zlibbioc_1.44.0 purrr_0.3.5 [63] RCurl_1.98-1.9 basilisk.utils_1.8.0 [65] GetoptLong_1.0.5 viridis_0.6.2 [67] cowplot_1.1.1 ggrepel_0.9.2 [69] cluster_2.1.4 here_1.0.1 [71] DECIPHER_2.26.0 magrittr_2.0.3 [73] circlize_0.4.15 mime_0.12 [75] evaluate_0.18 xtable_1.8-4 [77] XML_3.99-0.12 gridExtra_2.3 [79] shape_1.4.6 compiler_4.2.1 [81] scater_1.26.0 tibble_3.1.8 [83] crayon_1.5.2 htmltools_0.5.3 [85] mgcv_1.8-41 later_1.3.0 [87] tidyr_1.2.1 DBI_1.1.3 [89] ExperimentHub_2.4.0 corrplot_0.92 [91] dbplyr_2.2.1 MASS_7.3-58.1 [93] rappdirs_0.3.3 Matrix_1.5-1 [95] permute_0.9-7 cli_3.4.1 [97] parallel_4.2.1 forcats_0.5.2 [99] pkgconfig_2.0.3 dir.expiry_1.4.0 [101] scuttle_1.8.0 foreach_1.5.2 [103] vipor_0.4.5 bslib_0.4.1 [105] DirichletMultinomial_1.40.0 yulab.utils_0.0.5 [107] digest_0.6.30 vegan_2.6-4 [109] graph_1.74.0 rmarkdown_2.17 [111] tidytree_0.4.1 uwot_0.1.14 [113] DelayedMatrixStats_1.20.0 curl_4.3.3 [115] shiny_1.7.3 rjson_0.2.21 [117] lifecycle_1.0.3 nlme_3.1-160 [119] jsonlite_1.8.3 Rhdf5lib_1.18.2 [121] BiocNeighbors_1.16.0 CodeDepends_0.6.5 [123] viridisLite_0.4.1 fansi_1.0.3 [125] pillar_1.8.1 lattice_0.20-45 [127] KEGGREST_1.36.3 fastmap_1.1.0 [129] httr_1.4.4 interactiveDisplayBase_1.34.0 [131] glue_1.6.2 png_0.1-7 [133] iterators_1.0.14 BiocVersion_3.15.2 [135] bit_4.0.4 stringi_1.7.8 [137] sass_0.4.2 HDF5Array_1.24.2 [139] BiocBaseUtils_1.0.0 blob_1.2.3 [141] BiocSingular_1.14.0 AnnotationHub_3.4.0 [143] memoise_2.0.1 dplyr_1.0.10 [145] irlba_2.3.5.1 ape_5.6-2 Bibliography "],["viz-chapter.html", "Chapter 14 Visualization 14.1 Pre-analysis exploration 14.2 Diversity estimation 14.3 Statistical analysis Session Info", " Chapter 14 Visualization .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } Whether a data set contains information on a microbial community or it originates from a different source, the way that data are visualized inevitably shapes how they will be interpreted, and motivates the next steps of the analysis. A large variety of graphing methods belong to microbial analysis, but only few are the choices that will return useful answers about the data. Therefore, knowledge on the available tools and their possible applications plays an important role in selecting the most suitable method for the asked question. This chapter introduces the reader to a number of visualization techniques found in this book, such as: bar plots box plots heatmaps ordination charts regression charts trees The toolkit which provides the essential plotting functionality includes the following packages: patchwork, cowplot, ggpubr and gridExtra: plot layout and multi-panel plotting miaViz: specific visualization tools for TreeSummaizedExperiment objects scater: specific visualization tools for SingleCellExperiment objects ggplot2, pheatmap, ggtree, sechm: composition heatmaps ANCOMBC, ALDEx2 and Maaslin2: visual differential abundance fido: tree-based methods for differential abundance plotly: animated and 3D plotting For systematic and extensive tutorials on the visual tools available in mia, readers can refer to the following material: microbiome tutorials 14.1 Pre-analysis exploration 14.1.1 Accessing row and column data SCE and TSE objects contain multiple layers of information in the form of rows, columns and meta data. The scater package supports in accessing, modifying and graphing the meta data related to features as well as samples. # list row meta data names(rowData(tse)) ## [1] &quot;Kingdom&quot; &quot;Phylum&quot; &quot;Class&quot; &quot;Order&quot; &quot;Family&quot; &quot;Genus&quot; &quot;Species&quot; # list column meta data names(colData(tse)) ## [1] &quot;X.SampleID&quot; &quot;Primer&quot; ## [3] &quot;Final_Barcode&quot; &quot;Barcode_truncated_plus_T&quot; ## [5] &quot;Barcode_full_length&quot; &quot;SampleType&quot; ## [7] &quot;Description&quot; Such meta data can be directly plotted with the functions plotRowData and plotColData. # obtain QC data tse &lt;- addPerCellQC(tse) tse &lt;- addPerFeatureQC(tse) # plot QC Mean against Species plotRowData(tse, &quot;mean&quot;, &quot;Species&quot;) + theme(axis.text.x = element_blank()) + labs(x = &quot;Species&quot;, y = &quot;QC Mean&quot;) # plot QC Sum against Sample ID, colour-labeled by Sample Type plotColData(tse, &quot;sum&quot;, &quot;X.SampleID&quot;, colour_by = &quot;SampleType&quot;) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(x = &quot;Sample ID&quot;, y = &quot;QC Sum&quot;) Alternatively, they can be converted to a data.frame object and passed to ggplot. # store colData into a data frame coldata &lt;- as.data.frame(colData(tse)) # plot Number of Samples against Sampling Site ggplot(coldata, aes(x = SampleType)) + geom_bar(width = 0.5) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(x = &quot;Sampling Site&quot;, y = &quot;Number of Samples&quot;) Further methods of application can be found in the chapters 5.3 and 7.1.1 and in a few external tutorials with open data. Additionally, rowData and colData allow manipulation and subsetting of large data sets into smaller units, as explained in chapter 4. 14.1.2 Viewing abundance and prevalence patterns Prior-to-analysis exploration may involve questions such as how microorganisms are distributed across samples (abundance) and what microorganisms are present in most of the samples (prevalence). The information on abundance and prevalence can be summarized into a jitter or density plot and a tree, respectively, with the miaViz package. Specifically, the functions plotAbundance, plotAbundanceDensity and plotRowTree are used, and examples on their usage are discussed throughout chapter 5. 14.2 Diversity estimation Alpha diversity is commonly measured as one of the diversity indices explained in chapter 7. Because the focus lies on each sample separately, one-dimensional plots, such as scatter, violin and box plots, are suitable. Beta diversity is generally evaluated as one of the dissimilarity indices reported in chapter 8. Unlike alpha diversity, samples are compared collectively to estimate the heterogeneity across them, therefore multidimensional plots, such as Shepard and ordination plots are suitable. alpha diversity beta diversity used metrics diversity indices dissimilarity indices metric dimensionality one-dimensional multidimensional suitable visualization scatter, violin, box plots Shepard, ordination plots As a conclusion, visualization techniques for alpha and beta diversity significantly differ from one another. 14.2.1 Alpha diversity with scatter, violin and box plots The basic method to visualize the diversity values assigned to the different samples in a TSE object includes the following, where each data point represents one sample: # estimate shannon diversity index tse &lt;- mia::estimateDiversity(tse, assay_name = &quot;counts&quot;, index = &quot;shannon&quot;, name = &quot;shannon&quot;) # plot shannon diversity index, colour-labeled by Sample Type plotColData(tse, &quot;shannon&quot;, colour_by = &quot;SampleType&quot;) The several indices available for the evaluation of alpha diversity often return slightly divergent results, which can be visually compared with a multiple violin or box plot. For this purpose, plotColData (for violin plots) or ggplot (for box plots) are recursively applied to a number of diversity indices with the function lapply and the multi-panel plotting functionality of the patchwork package is then exploited. # estimate faith diversity index tse &lt;- mia::estimateFaith(tse, assay_name = &quot;counts&quot;) # store colData into a data frame coldata &lt;- as.data.frame(colData(tse)) # generate plots for shannon and faith indices # and store them into a list plots &lt;- lapply(c(&quot;shannon&quot;, &quot;faith&quot;), function(i) ggplot(coldata, aes_string(y = i)) + geom_boxplot() + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())) # combine plots with patchwork plots[[1]] + plots[[2]] The analogous output in the form of a violin plot is obtained in chapter 7.1.3. In addition, box plots that group samples according to certain information, such as origin, sex, age and health condition, can be labeled with p-values for significant differences with the package ggsignif package, as shown in chapter 7.1.2. 14.2.2 Beta diversity with Shepard and coordination plots The scater package offers the general function plotReducedDim. In its basic form, it takes a TSE object and the results on sample similarity stored in the same object, which can be evaluated with the following coordination methods: runMDS runNMDS runPCA runTSNE runUMAP Since these clustering techniques allow for multiple coordinates or components, coordination plots can also span multiple dimensions, which is explained in chapter @ref{extras}. # perform NMDS coordination method tse &lt;- runNMDS(tse, FUN = vegan::vegdist, name = &quot;NMDS&quot;) ## initial value 47.733208 ## iter 5 value 33.853364 ## iter 10 value 32.891200 ## final value 32.823570 ## converged # plot results of a 2-component NMDS on tse, # coloured-scaled by shannon diversity index plotReducedDim(tse, &quot;NMDS&quot;, colour_by = &quot;shannon&quot;) Multiple combinations of coordinates or dimensions can also be integrated into a multi-panel arrangement. # perform MDS coordination method tse &lt;- runMDS(tse, FUN = vegan::vegdist, method = &quot;bray&quot;, name = &quot;MDS&quot;, exprs_values = &quot;counts&quot;, ncomponents = 3) # plot results of a 3-component MDS on tse, # coloured-scaled by faith diversity index plotReducedDim(tse, &quot;MDS&quot;, ncomponents = c(1:3), colour_by = &quot;faith&quot;) Similarly to iterating plotColData over indices of alpha diversity, lapply can be used in combination with patchwork to recursively apply plotReducedDim and visually compare results among various coordination methods. # generate plots for MDS and NMDS methods # and store them into a list plots &lt;- lapply(c(&quot;MDS&quot;, &quot;NMDS&quot;), plotReducedDim, object = tse, colour_by = &quot;shannon&quot;) # combine plots with patchwork plots[[1]] + plots[[2]] + plot_layout(guides = &quot;collect&quot;) For similar examples, readers are referred to chapter 8. Further material on the graphic capabilities of patchwork is available in its official package tutorial. 14.3 Statistical analysis 14.3.1 Heatmaps As described in chapter 9.1, bar plots and heatmaps can offer a useful insight into the composition of a community. Simple methods involve the functions plotAbundance and geom_tile in combination with scale_fill_gradientn from the packages miaViz and ggplot2, respectively. For instance, below the composition of multiple samples (x axis) is reported in terms of relative abundances (y axis) for the top 10 taxa at the Order rank. Bar plots and heatmaps with analogous information at the Phylum level are available in the aforementioned chapter. # agglomerate tse by Order tse_order &lt;- agglomerateByRank(tse, rank = &quot;Order&quot;, onRankOnly = TRUE) # transform counts into relative abundance tse_order &lt;- transformCounts(tse_order, assay_name = &quot;counts&quot;, method = &quot;relabundance&quot;) # get top orders top_taxa &lt;- getTopTaxa(tse_order, top = 10, assay_name = &quot;relabundance&quot;) # leave only names for top 10 orders and label the rest with &quot;Other&quot; order_renamed &lt;- lapply(rowData(tse_order)$Order, function(x){if (x %in% top_taxa) {x} else {&quot;Other&quot;}}) rowData(tse_order)$Order &lt;- as.character(order_renamed) # plot composition as a bar plot plotAbundance(tse_order, assay_name = &quot;relabundance&quot;, rank = &quot;Order&quot;, order_rank_by = &quot;abund&quot;, order_sample_by = &quot;Clostridiales&quot;) To add a sample annotation, you can combine plots that you get from the output pf plotAbundance. # Create plots plots &lt;- plotAbundance(tse_order, assay_name = &quot;relabundance&quot;, rank = &quot;Order&quot;, order_rank_by = &quot;abund&quot;, order_sample_by = &quot;Clostridiales&quot;, features = &quot;SampleType&quot;) # Modify the legend of the first plot to be smaller plots[[1]] &lt;- plots[[1]] + theme(legend.key.size = unit(0.3, &#39;cm&#39;), legend.text = element_text(size = 6), legend.title = element_text(size = 8)) # Modify the legend of the second plot to be smaller plots[[2]] &lt;- plots[[2]] + theme(legend.key.height = unit(0.3, &#39;cm&#39;), legend.key.width = unit(0.3, &#39;cm&#39;), legend.text = element_text(size = 6), legend.title = element_text(size = 8), legend.direction = &quot;vertical&quot;) # Load required packages if( !require(&quot;ggpubr&quot;) ){ install.packages(&quot;ggpubr&quot;) library(&quot;ggpubr&quot;) } # Load required packages if( !require(&quot;patchwork&quot;) ){ install.packages(&quot;patchwork&quot;) library(&quot;patchwork&quot;) } # Combine legends legend &lt;- wrap_plots(as_ggplot(get_legend(plots[[1]])), as_ggplot(get_legend(plots[[2]])), ncol = 1) # Remove legends from the plots plots[[1]] &lt;- plots[[1]] + theme(legend.position = &quot;none&quot;) plots[[2]] &lt;- plots[[2]] + theme(legend.position = &quot;none&quot;, axis.title.x=element_blank()) # Combine plots plot &lt;- wrap_plots(plots[[2]], plots[[1]], ncol = 1, heights = c(2, 10)) # Combine the plot with the legend wrap_plots(plot, legend, nrow = 1, widths = c(2, 1)) For more sophisticated visualizations than those produced with plotAbundance and ggplot2, the packages pheatmap and sechm provide methods to include feature and sample clusters in a heatmap, along with further functionality. # Agglomerate tse by phylum tse_phylum &lt;- agglomerateByRank(tse, rank = &quot;Phylum&quot;, onRankOnly = TRUE) # Add clr-transformation on samples tse_phylum &lt;- transformSamples(tse_phylum, method = &quot;relabundance&quot;, pseudocount = 1) tse_phylum &lt;- transformSamples(tse_phylum, method = &quot;clr&quot;, assay_name = &quot;relabundance&quot;) # Add z-transformation on features (taxa) tse_phylum &lt;- transformFeatures(tse_phylum, assay_name = &quot;clr&quot;, method = &quot;z&quot;, name = &quot;clr_z&quot;) # Takes subset: only samples from feces, skin, or tongue tse_phylum_subset &lt;- tse_phylum[ , colData(tse_phylum)$SampleType %in% c(&quot;Feces&quot;, &quot;Skin&quot;, &quot;Tongue&quot;) ] # Does clr-transformation tse_phylum_subset &lt;- transformSamples(tse_phylum_subset, method = &quot;relabundance&quot;, pseudocount = 1) tse_phylum_subset &lt;- transformSamples(tse_phylum_subset, method = &quot;clr&quot;, assay_name = &quot;relabundance&quot;) # Does z-transformation tse_phylum_subset &lt;- transformFeatures(tse_phylum_subset, assay_name = &quot;clr&quot;, method = &quot;z&quot;, name = &quot;clr_z&quot;) # Get n most abundant taxa, and subsets the data by them top_taxa &lt;- getTopTaxa(tse_phylum_subset, top = 20) tse_phylum_subset &lt;- tse_phylum_subset[top_taxa, ] # Gets the assay table mat &lt;- assay(tse_phylum_subset, &quot;clr_z&quot;) # Creates the heatmap pheatmap(mat) We can cluster both samples and features hierarchically and add them to the x and y axes of the heatmap, respectively. # Hierarchical clustering taxa_hclust &lt;- hclust(dist(mat), method = &quot;complete&quot;) # Creates a phylogenetic tree taxa_tree &lt;- as.phylo(taxa_hclust) # Plot taxa tree taxa_tree &lt;- ggtree(taxa_tree) + theme(plot.margin=margin(0,0,0,0)) # removes margins # Get order of taxa in plot taxa_ordered &lt;- get_taxa_name(taxa_tree) # to view the tree, run # taxa_tree Based on phylo tree, we decide to create three clusters. # Creates clusters taxa_clusters &lt;- cutree(tree = taxa_hclust, k = 3) # Converts into data frame taxa_clusters &lt;- data.frame(clusters = taxa_clusters) taxa_clusters$clusters &lt;- factor(taxa_clusters$clusters) # Order data so that it&#39;s same as in phylo tree taxa_clusters &lt;- taxa_clusters[taxa_ordered, , drop = FALSE] # Prints taxa and their clusters taxa_clusters ## clusters ## Chloroflexi 3 ## Actinobacteria 3 ## Crenarchaeota 3 ## Planctomycetes 3 ## Gemmatimonadetes 3 ## Thermi 3 ## Acidobacteria 3 ## Spirochaetes 2 ## Fusobacteria 2 ## SR1 2 ## Cyanobacteria 2 ## Proteobacteria 2 ## Synergistetes 2 ## Lentisphaerae 1 ## Bacteroidetes 1 ## Verrucomicrobia 1 ## Tenericutes 1 ## Firmicutes 1 ## Euryarchaeota 1 ## SAR406 1 The information on the clusters is then added to the feature meta data. # Adds information to rowData rowData(tse_phylum_subset)$clusters &lt;- taxa_clusters[order(match(rownames(taxa_clusters), rownames(tse_phylum_subset))), ] # Prints taxa and their clusters rowData(tse_phylum_subset)$clusters ## [1] 1 1 2 3 2 2 1 1 1 1 3 2 3 3 3 2 2 3 3 1 ## Levels: 1 2 3 Similarly, samples are hierarchically grouped into clusters, the most suitable number of clusters for the plot is selected and the new information is stored into the sample meta data. # Hierarchical clustering sample_hclust &lt;- hclust(dist(t(mat)), method = &quot;complete&quot;) # Creates a phylogenetic tree sample_tree &lt;- as.phylo(sample_hclust) # Plot sample tree sample_tree &lt;- ggtree(sample_tree) + layout_dendrogram() + theme(plot.margin=margin(0,0,0,0)) # removes margins # Get order of samples in plot samples_ordered &lt;- rev(get_taxa_name(sample_tree)) # to view the tree, run # sample_tree # Creates clusters sample_clusters &lt;- factor(cutree(tree = sample_hclust, k = 3)) # Converts into data frame sample_data &lt;- data.frame(clusters = sample_clusters) # Order data so that it&#39;s same as in phylo tree sample_data &lt;- sample_data[samples_ordered, , drop = FALSE] # Order data based on tse_phylum_subset &lt;- tse_phylum_subset[ , rownames(sample_data)] # Add sample type data sample_data$sample_types &lt;- unfactor(colData(tse_phylum_subset)$SampleType) sample_data ## clusters sample_types ## M11Plmr 2 Skin ## M31Plmr 2 Skin ## F21Plmr 2 Skin ## M31Fcsw 1 Feces ## M11Fcsw 1 Feces ## TS28 3 Feces ## TS29 3 Feces ## M31Tong 3 Tongue ## M11Tong 3 Tongue Now we can create heatmap with additional annotations. # Determines the scaling of colorss # Scale colors breaks &lt;- seq(-ceiling(max(abs(mat))), ceiling(max(abs(mat))), length.out = ifelse( max(abs(mat))&gt;5, 2*ceiling(max(abs(mat))), 10 ) ) colors &lt;- colorRampPalette(c(&quot;darkblue&quot;, &quot;blue&quot;, &quot;white&quot;, &quot;red&quot;, &quot;darkred&quot;))(length(breaks)-1) pheatmap(mat, annotation_row = taxa_clusters, annotation_col = sample_data, breaks = breaks, color = colors) The package sechm allows for further visual capabilities and flexibility. In this case, the clustering step is automatically performed by the plotting function and does not need to be executed in advance. # Stores annotation colros to metadata metadata(tse_phylum_subset)$anno_colors$SampleType &lt;- c(Feces = &quot;blue&quot;, Skin = &quot;red&quot;, Tongue = &quot;gray&quot;) # Create a plot sechm(tse_phylum_subset, features = rownames(tse_phylum_subset), assayName = &quot;clr&quot;, do.scale = TRUE, top_annotation = c(&quot;SampleType&quot;), gaps_at = &quot;SampleType&quot;, cluster_cols = TRUE, cluster_rows = TRUE) It is also possible to create an analogous heatmap by just using the ggplot2 package. However, a relatively long code is required to generate an identical output. # Add feature names to column as a factor taxa_clusters$Feature &lt;- rownames(taxa_clusters) taxa_clusters$Feature &lt;- factor(taxa_clusters$Feature, levels = taxa_clusters$Feature) # Create annotation plot row_annotation &lt;- ggplot(taxa_clusters) + geom_tile(aes(x = NA, y = Feature, fill = clusters)) + coord_equal(ratio = 1) + theme( axis.text.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.title.y=element_blank(), axis.title.x = element_text(angle = 90, vjust = 0.5, hjust=1), plot.margin=margin(0,0,0,0), ) + labs(fill = &quot;Clusters&quot;, x = &quot;Clusters&quot;) # to view the notation, run # row_annotation # Add sample names to one of the columns sample_data$sample &lt;- factor(rownames(sample_data), levels = rownames(sample_data)) # Create annotation plot sample_types_annotation &lt;- ggplot(sample_data) + scale_y_discrete(position = &quot;right&quot;, expand = c(0,0)) + geom_tile(aes(y = NA, x = sample, fill = sample_types)) + coord_equal(ratio = 1) + theme( axis.text.x=element_blank(), axis.text.y=element_blank(), axis.title.x=element_blank(), axis.ticks.x=element_blank(), plot.margin=margin(0,0,0,0), axis.title.y.right = element_text(angle=0, vjust = 0.5) ) + labs(fill = &quot;Sample types&quot;, y = &quot;Sample types&quot;) # to view the notation, run # sample_types_annotation # Create annotation plot sample_clusters_annotation &lt;- ggplot(sample_data) + scale_y_discrete(position = &quot;right&quot;, expand = c(0,0)) + geom_tile(aes(y = NA, x = sample, fill = clusters)) + coord_equal(ratio = 1) + theme( axis.text.x=element_blank(), axis.text.y=element_blank(), axis.title.x=element_blank(), axis.ticks.x=element_blank(), plot.margin=margin(0,0,0,0), axis.title.y.right = element_text(angle=0, vjust = 0.5) ) + labs(fill = &quot;Clusters&quot;, y = &quot;Clusters&quot;) # to view the notation, run # sample_clusters_annotation # Order data based on clusters and sample types mat &lt;- mat[unfactor(taxa_clusters$Feature), unfactor(sample_data$sample)] # ggplot requires data in melted format melted_mat &lt;- melt(mat) colnames(melted_mat) &lt;- c(&quot;Taxa&quot;, &quot;Sample&quot;, &quot;clr_z&quot;) # Determines the scaling of colorss maxval &lt;- round(max(abs(melted_mat$clr_z))) limits &lt;- c(-maxval, maxval) breaks &lt;- seq(from = min(limits), to = max(limits), by = 0.5) colours &lt;- c(&quot;darkblue&quot;, &quot;blue&quot;, &quot;white&quot;, &quot;red&quot;, &quot;darkred&quot;) heatmap &lt;- ggplot(melted_mat) + geom_tile(aes(x = Sample, y = Taxa, fill = clr_z)) + theme( axis.title.y=element_blank(), axis.title.x=element_blank(), axis.ticks.y=element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), plot.margin=margin(0,0,0,0), # removes margins legend.key.height= unit(1, &#39;cm&#39;) ) + scale_fill_gradientn(name = &quot;CLR + Z transform&quot;, breaks = breaks, limits = limits, colours = colours) + scale_y_discrete(position = &quot;right&quot;) heatmap # Create layout design &lt;- c( area(3, 1, 4, 1), area(1, 2, 1, 3), area(2, 2, 2, 3), area(3, 2, 4, 3) ) # to view the design, run # plot(design) # Combine plots plot &lt;- row_annotation + sample_clusters_annotation + sample_types_annotation + heatmap + plot_layout(design = design, guides = &quot;collect&quot;, # Specify layout, collect legends # Adjust widths and heights to align plots. # When annotation plot is larger, it might not fit into its column/row. # Then you need to make column/row larger. # Relative widths and heights of each column and row: # Currently, the width of the first column is 15 % and the height of # first two rows are 30 % the size of others # To get this work most of the times, you can adjust all sizes to be 1, i.e. equal, # but then the gaps between plots are larger. widths = c(0.15, 1, 1), heights = c(0.3, 0.3, 1, 1)) # plot # Create layout design &lt;- c( area(4, 1, 5, 1), area(4, 2, 5, 2), area(1, 3, 1, 4), area(2, 3, 2, 4), area(3, 3, 3, 4), area(4, 3, 5, 4) ) # to view the design, run # plot(design) # Combine plots plot &lt;- taxa_tree + row_annotation + sample_tree + sample_clusters_annotation + sample_types_annotation + heatmap + plot_layout(design = design, guides = &quot;collect&quot;, # Specify layout, collect legends widths = c(0.2, 0.15, 1, 1, 1), heights = c(0.1, 0.15, 0.15, 0.25, 1, 1)) plot Heatmaps find several other applications in biclustering and multi-assay analyses, that are discussed in chapters 10 and @ref(multi-assay_analyses), where the packages cobiclust and MOFA2 are of interest. Session Info View session info R version 4.2.1 (2022-06-23) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.4 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] ggpubr_0.4.0 ggtree_3.4.4 [3] ape_5.6-2 pheatmap_1.0.12 [5] reshape2_1.4.4 sechm_1.4.1 [7] miaViz_1.5.4 ggraph_2.1.0 [9] patchwork_1.1.2 scater_1.26.0 [11] scuttle_1.8.0 mia_1.5.17 [13] MultiAssayExperiment_1.24.0 TreeSummarizedExperiment_2.1.4 [15] Biostrings_2.66.0 XVector_0.38.0 [17] SingleCellExperiment_1.20.0 SummarizedExperiment_1.28.0 [19] Biobase_2.58.0 GenomicRanges_1.50.1 [21] GenomeInfoDb_1.34.2 IRanges_2.32.0 [23] S4Vectors_0.36.0 BiocGenerics_0.44.0 [25] MatrixGenerics_1.10.0 matrixStats_0.62.0-9005 [27] ggplot2_3.4.0 BiocStyle_2.24.0 [29] rebook_1.6.0 loaded via a namespace (and not attached): [1] utf8_1.2.2 tidyselect_1.2.0 [3] RSQLite_2.2.18 grid_4.2.1 [5] TSP_1.2-1 BiocParallel_1.32.1 [7] Rtsne_0.16 munsell_0.5.0 [9] ScaledMatrix_1.6.0 codetools_0.2-18 [11] withr_2.5.0 colorspace_2.0-3 [13] filelock_1.0.2 highr_0.9 [15] knitr_1.40 ggsignif_0.6.4 [17] ca_0.71.1 labeling_0.4.2 [19] GenomeInfoDbData_1.2.9 polyclip_1.10-4 [21] bit64_4.0.5 farver_2.1.1 [23] vctrs_0.5.0 treeio_1.22.0 [25] generics_0.1.3 xfun_0.34 [27] R6_2.5.1 doParallel_1.0.17 [29] ggbeeswarm_0.6.0 clue_0.3-62 [31] graphlayouts_0.8.3 rsvd_1.0.5 [33] seriation_1.4.0 bitops_1.0-7 [35] cachem_1.0.6 gridGraphics_0.5-1 [37] DelayedArray_0.24.0 assertthat_0.2.1 [39] scales_1.2.1 beeswarm_0.4.0 [41] gtable_0.3.1 beachmat_2.14.0 [43] Cairo_1.6-0 tidygraph_1.2.2 [45] rlang_1.0.6 GlobalOptions_0.1.2 [47] splines_4.2.1 rstatix_0.7.0 [49] lazyeval_0.2.2 broom_1.0.1 [51] BiocManager_1.30.19 yaml_2.3.6 [53] abind_1.4-5 backports_1.4.1 [55] tools_4.2.1 bookdown_0.29 [57] ggplotify_0.1.0 ellipsis_0.3.2 [59] decontam_1.18.0 jquerylib_0.1.4 [61] RColorBrewer_1.1-3 Rcpp_1.0.9 [63] plyr_1.8.7 sparseMatrixStats_1.10.0 [65] zlibbioc_1.44.0 purrr_0.3.5 [67] RCurl_1.98-1.9 GetoptLong_1.0.5 [69] viridis_0.6.2 cowplot_1.1.1 [71] ggrepel_0.9.2 cluster_2.1.4 [73] DECIPHER_2.26.0 magrittr_2.0.3 [75] circlize_0.4.15 ggnewscale_0.4.8 [77] randomcoloR_1.1.0.1 evaluate_0.18 [79] XML_3.99-0.12 gridExtra_2.3 [81] shape_1.4.6 compiler_4.2.1 [83] tibble_3.1.8 V8_4.2.2 [85] crayon_1.5.2 htmltools_0.5.3 [87] ggfun_0.0.8 mgcv_1.8-41 [89] tidyr_1.2.1 aplot_0.1.8 [91] DBI_1.1.3 tweenr_2.0.2 [93] ComplexHeatmap_2.12.1 MASS_7.3-58.1 [95] Matrix_1.5-1 car_3.1-1 [97] permute_0.9-7 cli_3.4.1 [99] parallel_4.2.1 igraph_1.3.5 [101] pkgconfig_2.0.3 dir.expiry_1.4.0 [103] registry_0.5-1 foreach_1.5.2 [105] vipor_0.4.5 bslib_0.4.1 [107] DirichletMultinomial_1.40.0 yulab.utils_0.0.5 [109] stringr_1.4.1 digest_0.6.30 [111] vegan_2.6-4 graph_1.74.0 [113] rmarkdown_2.17 tidytree_0.4.1 [115] DelayedMatrixStats_1.20.0 curl_4.3.3 [117] rjson_0.2.21 lifecycle_1.0.3 [119] nlme_3.1-160 jsonlite_1.8.3 [121] carData_3.0-5 BiocNeighbors_1.16.0 [123] CodeDepends_0.6.5 viridisLite_0.4.1 [125] fansi_1.0.3 pillar_1.8.1 [127] lattice_0.20-45 fastmap_1.1.0 [129] glue_1.6.2 png_0.1-7 [131] iterators_1.0.14 bit_4.0.4 [133] ggforce_0.4.1 stringi_1.7.8 [135] sass_0.4.2 blob_1.2.3 [137] BiocSingular_1.14.0 memoise_2.0.1 [139] dplyr_1.0.10 irlba_2.3.5.1 "],["resources.html", "Chapter 15 Resources 15.1 Data containers 15.2 R programming resources 15.3 Reproducible reporting with Rmarkdown", " Chapter 15 Resources .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 15.1 Data containers 15.1.1 Resources for TreeSummarizedExperiment SingleCellExperiment (Lun and Risso 2020) Online tutorial Project page SummarizedExperiment (Morgan et al. 2020) Online tutorial Project page TreeSummarizedExperiment (Huang 2020) Online tutorial Project page Publication: (Huang et al. 2021) 15.1.2 Other relevant containers DataFrame which behaves similarly to data.frame, yet efficient and fast when used with large datasets. DNAString along with DNAStringSet,RNAString and RNAStringSet efficient storage and handling of long biological sequences are offered within the Biostrings package. GenomicRanges offers an efficient representation and manipulation of genomic annotations and alignments, see e.g. GRanges and GRangesList at An Introduction to the GenomicRangesPackage. NGS Analysis Basics provides a walk-through of the above-mentioned features with detailed examples. 15.1.3 Alternative containers for microbiome data The phyloseq package and class became the first widely used data container for microbiome data science in R. Many methods for taxonomic profiling data are readily available for this class. We provide here a short description how phyloseq and *Experiment classes relate to each other. assays : This slot is similar to otu_table in phyloseq. In a SummarizedExperiment object multiple assays, raw counts, transformed counts can be stored. See also MultiAssayExperiment for storing data from multiple experiments such as RNASeq, Proteomics, etc. rowData : This slot is similar to tax_table in phyloseq to store taxonomic information. colData : This slot is similar to sample_data in phyloseq to store information related to samples. rowTree : This slot is similar to phy_tree in phyloseq to store phylogenetic tree. In this book, you will come across terms like FeatureIDs and SampleIDs. FeatureIDs : These are basically OTU/ASV ids which are row names in assays and rowData. SampleIDs : As the name suggests, these are sample ids which are column names in assays and row names in colData. FeatureIDs and SampleIDs are used but the technical terms rownames and colnames are encouraged to be used, since they relate to actual objects we work with. 15.1.4 Resources for phyloseq The (Tree)SummarizedExperiment objects can be converted into the alternative phyloseq format, for which further methods are available. List of R tools for microbiome analysis phyloseq microbiome tutorial microbiomeutilities Bioconductor Workflow for Microbiome Data Analysis: from raw reads to community analyses (Callahan et al. F1000, 2016). 15.2 R programming resources If you are new to R, you could try swirl for a kickstart to R programming. Further support resources are available through the Bioconductor project. R programming basics: Base R Basics of R programming: Base R R cheat sheets R visualization with ggplot2 R graphics cookbook Rmarkdown Rmarkdown tips RStudio RStudio cheat sheet 15.2.1 Bioconductor Classes S4 system S4 class system has brought several useful features to the object-oriented programming paradigm within R, and it is constantly deployed in R/Bioconductor packages.   Online Document: Hervé Pagès, A quick overview of the S4 class system. Laurent Gatto, A practical tutorial on S4 programming John M. Chambers. How S4 Methods Work   Books: John M. Chambers. Software for Data Analysis: Programming with R. Springer, New York, 2008. ISBN-13 978-0387759357. I Robert Gentleman. R Programming for Bioinformatics. Chapman &amp; Hall/CRC, New York, 2008. ISBN-13 978-1420063677 15.3 Reproducible reporting with Rmarkdown Reproducible reporting is the starting point for robust interactive data science. You can perform the following tasks to get started. If you are entirely new to Markdown, take this 10 minute tutorial to get introduced to the most important functions within Markdown. Then experiment with different options with Rmarkdown Create a Rmarkdown template in RStudio, and render it into a document (markdown, PDF, docx or other format). In case you are new to Rmarkdown Rstudio provides resources to learn about the use cases and the basics of Rmarkdown. Further examples are tips for Rmarkdown are available in the online tutorial to reproducible reporting by Dr. C Titus Brown. Figure sources: Original article - Huang R et al. (2021) TreeSummarizedExperiment: a S4 class for data with hierarchical structure. F1000Research 9:1246. Reference Sequence slot extension - Lahti L et al. (2020) Upgrading the R/Bioconductor ecosystem for microbiome research F1000Research 9:1464 (slides). Bibliography "],["extras.html", "Chapter 16 Extra material 16.1 Interactive 3D Plots 16.2 PERMANOVA comparison", " Chapter 16 Extra material 16.1 Interactive 3D Plots # Installing required packages if (!require(rgl)){ BiocManager::install(&quot;rgl&quot;) } if (!require(plotly)){ BiocManager::install(&quot;plotly&quot;) } library(knitr) library(rgl) knitr::knit_hooks$set(webgl = hook_webgl) In this section we make a 3D version of the earlier Visualizing the most dominant genus on PCoA, with the help of the plotly R package. # Importing necessary libraries library(curatedMetagenomicData) library(dplyr) library(DT) library(mia) library(scater) # Querying the data tse &lt;- sampleMetadata |&gt; filter(age &gt;= 18) |&gt; # taking only data of age 18 or above filter(!is.na(alcohol)) |&gt; # excluding missing values select(where(~ !all(is.na(.x)))) |&gt; returnSamples(&quot;relative_abundance&quot;) tse_Genus &lt;- agglomerateByRank(tse, rank=&quot;genus&quot;) tse_Genus &lt;- addPerSampleDominantTaxa(tse_Genus, assay_name=&quot;relative_abundance&quot;, name = &quot;dominant_taxa&quot;) # Performing PCoA with Bray-Curtis dissimilarity. tse_Genus &lt;- runMDS(tse_Genus, FUN = vegan::vegdist, ncomponents = 3, name = &quot;PCoA_BC&quot;, exprs_values = &quot;relative_abundance&quot;) # Getting the 6 top taxa top_taxa &lt;- getTopTaxa(tse_Genus,top = 6, assay_name = &quot;relative_abundance&quot;) # Naming all the rest of non top-taxa as &quot;Other&quot; most_abundant &lt;- lapply(colData(tse_Genus)$dominant_taxa, function(x){if (x %in% top_taxa) {x} else {&quot;Other&quot;}}) # Storing the previous results as a new column within colData colData(tse_Genus)$most_abundant &lt;- as.character(most_abundant) # Calculating percentage of the most abundant most_abundant_freq &lt;- table(as.character(most_abundant)) most_abundant_percent &lt;- round(most_abundant_freq/sum(most_abundant_freq)*100, 1) # Retrieving the explained variance e &lt;- attr(reducedDim(tse_Genus, &quot;PCoA_BC&quot;), &quot;eig&quot;); var_explained &lt;- e/sum(e[e&gt;0])*100 Interactive 3D visualization of the most dominant genus on PCoA. Note that labels at legend can be used to visualize one or more Genus separately (double click to isolate one from the others, or toggle to select multiple ones). library(plotly) # 3D Visualization reduced_data &lt;- as.data.frame(reducedDim(tse_Genus)[,]) names(reduced_data) &lt;- c(&quot;PC1&quot;,&quot;PC2&quot;,&quot;PC3&quot;) plot_ly(reduced_data, x=~PC1,y=~PC2,z=~PC3) %&gt;% add_markers(color=sapply(strsplit(colData(tse_Genus)$most_abundant, &quot;_&quot;), tail, 1), size=5, colors=c(&quot;black&quot;, &quot;blue&quot;, &quot;lightblue&quot;, &quot;darkgray&quot;, &quot;magenta&quot;, &quot;darkgreen&quot;, &quot;red&quot;)) %&gt;% layout(scene=list(xaxis=list(title = paste(&quot;PC1 (&quot;,round(var_explained[1],1),&quot;%)&quot;)), yaxis=list(title = paste(&quot;PC2 (&quot;,round(var_explained[2],1),&quot;%)&quot;)), zaxis=list(title = paste(&quot;PC3 (&quot;,round(var_explained[3],1),&quot;%)&quot;)))) 16.2 PERMANOVA comparison library(&quot;vegan&quot;) ## Loading required package: permute ## Loading required package: lattice ## This is vegan 2.6-4 data(&quot;enterotype&quot;) enterotype &lt;- transformSamples(enterotype, method = &quot;relabundance&quot;) # Drop those samples that do not have meta dtaa enterotype &lt;- enterotype[ , !rowSums(is.na(colData(enterotype)[, c(&quot;Nationality&quot;, &quot;Gender&quot;,&quot;ClinicalStatus&quot;)]) &gt; 0 ) ] # Multiple variables, by = &quot;margin&quot; set.seed(75) adonis2(t(assay(enterotype ,&quot;relabundance&quot;)) ~ Nationality + Gender + ClinicalStatus, by = &quot;margin&quot;, data = colData(enterotype), permutations = 99) ## Permutation test for adonis under reduced model ## Marginal effects of terms ## Permutation: free ## Number of permutations: 99 ## ## adonis2(formula = t(assay(enterotype, &quot;relabundance&quot;)) ~ Nationality + Gender + ClinicalStatus, data = colData(enterotype), permutations = 99, by = &quot;margin&quot;) ## Df SumOfSqs R2 F Pr(&gt;F) ## Nationality 4 0.7933 0.19338 2.0894 0.04 * ## Gender 1 0.1230 0.02999 1.2963 0.29 ## ClinicalStatus 3 0.2412 0.05879 0.8469 0.53 ## Residual 29 2.7527 0.67101 ## Total 38 4.1023 1.00000 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # Multiple variables, by = &quot;margin&quot; set.seed(75) adonis2(t(assay(enterotype ,&quot;relabundance&quot;)) ~ ClinicalStatus + Nationality + Gender, by = &quot;margin&quot;, data = colData(enterotype ), permutations = 99) ## Permutation test for adonis under reduced model ## Marginal effects of terms ## Permutation: free ## Number of permutations: 99 ## ## adonis2(formula = t(assay(enterotype, &quot;relabundance&quot;)) ~ ClinicalStatus + Nationality + Gender, data = colData(enterotype), permutations = 99, by = &quot;margin&quot;) ## Df SumOfSqs R2 F Pr(&gt;F) ## ClinicalStatus 3 0.2412 0.05879 0.8469 0.53 ## Nationality 4 0.7933 0.19338 2.0894 0.04 * ## Gender 1 0.1230 0.02999 1.2963 0.29 ## Residual 29 2.7527 0.67101 ## Total 38 4.1023 1.00000 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # Multiple variables, default: by = &quot;terms&quot; set.seed(75) adonis2(t(assay(enterotype ,&quot;relabundance&quot;)) ~ Nationality + Gender + ClinicalStatus, data = colData(enterotype ), permutations = 99) ## Permutation test for adonis under reduced model ## Terms added sequentially (first to last) ## Permutation: free ## Number of permutations: 99 ## ## adonis2(formula = t(assay(enterotype, &quot;relabundance&quot;)) ~ Nationality + Gender + ClinicalStatus, data = colData(enterotype), permutations = 99) ## Df SumOfSqs R2 F Pr(&gt;F) ## Nationality 5 1.0046 0.24490 2.1168 0.04 * ## Gender 1 0.1038 0.02530 1.0934 0.39 ## ClinicalStatus 3 0.2412 0.05879 0.8469 0.53 ## Residual 29 2.7527 0.67101 ## Total 38 4.1023 1.00000 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # Multiple variables, default: by = &quot;terms&quot; set.seed(75) adonis2(t(assay(enterotype ,&quot;relabundance&quot;)) ~ ClinicalStatus + Nationality + Gender, data = colData(enterotype), permutations = 99) ## Permutation test for adonis under reduced model ## Terms added sequentially (first to last) ## Permutation: free ## Number of permutations: 99 ## ## adonis2(formula = t(assay(enterotype, &quot;relabundance&quot;)) ~ ClinicalStatus + Nationality + Gender, data = colData(enterotype), permutations = 99) ## Df SumOfSqs R2 F Pr(&gt;F) ## ClinicalStatus 4 0.5000 0.12189 1.3169 0.20 ## Nationality 4 0.7265 0.17710 1.9135 0.05 * ## Gender 1 0.1230 0.02999 1.2963 0.29 ## Residual 29 2.7527 0.67101 ## Total 38 4.1023 1.00000 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 "],["acknowledgments.html", "Chapter 17 Acknowledgments", " Chapter 17 Acknowledgments .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } This work would not have been possible without the countless contributions and interactions with other researchers, developers, and users. We express our gratitude to the entire Bioconductor community for developing this high-quality open research software repository for life science analytics, continuously pushing the limits in emerging fields Huber et al. (2015). The base ecosystem of data containers, packages, and tutorials was set up as a collaborative effort by Tuomas Borman, Henrik Eckermann, Chouaib Benchraka, Chandler Ross, Shigdel Rajesh, Yağmur Şimşek, Giulio Benedetti, Sudarshan Shetty, Felix Ernst, and Leo Lahti, with further support from the COST Action network on Statistical and Machine Learning Techniques for Human Microbiome Studies (ML4microbiome) (Moreno-Indias et al. 2021). The framework is based on the TreeSummarizedExperiment data container created by Ruizhu Huang and others (Huang 2020), and on the MultiAssayExperiment by Marcel Ramos et al. (Ramos et al. 2017). The idea of using these containers as a basis for microbiome data science was initially advanced by the groundwork of Domenick Braccia, Héctor Corrada Bravo and others, and subsequently brought together with other microbiome data science developers (Shetty and Lahti 2019). Ample demonstration data resources have been made available as the curatedMetagenomicData project by Edoardo Pasolli, Lucas Schiffer, Levi Waldron and others (Pasolli et al. 2017) adding important support. A number of other contributors have advanced the ecosystem further, and will be acknowledged in the individual packages, pull requests, issues, and other work. The work has drawn inspiration from many sources, most notably from the work on phyloseq by Paul McMurdie and Susan Holmes (McMurdie and Holmes 2013) who pioneered the work on rigorous and reproducible microbiome data science ecosystems in R/Bioconductor. The phyloseq framework continues to provide a vast array of complementary packages and methods for microbiome studies, and we aim to support full interoperability. The open source books by Susan Holmes and Wolfgang Huber, Modern Statistics for Modern Biology (Holmes and Huber 2019) and by Garret Grolemund and Hadley Wickham, the R for Data Science (Grolemund and Wickham 2017), and Richard McElreath’s Statistical Rethinking and the associated online resources by Solomon Kurz (McElreath 2020) are key references that advanced reproducible data science training and dissemination. The Orchestrating Single-Cell Analysis with Bioconductor, or OSCA book by Robert Amezquita, Aaron Lun, Stephanie Hicks, and Raphael Gottardo (R. Amezquita et al. 2020) has implemented closely related work on the SummarizedExperiment data container and its derivatives in the field of single cell sequencing studies. Many approaches used in this book have been derived from the OSCA framework, with various adjustments and extensions dedicated to microbiome data science. Bibliography "],["exercises.html", "Chapter 18 Exercises 18.1 Workflows 18.2 Data containers 18.3 Data manipulation 18.4 Differential abundance 18.5 Alpha diversity 18.6 Community composition 18.7 Visualization 18.8 Multiomics", " Chapter 18 Exercises Here you can find assignments on different topics. Tips for exercises: Add comments that explain what each line or lines of code do. This helps you and others to understand your code and find bugs. Furthermore, it is easier for you to reuse the code, and it promotes transparency. Interpret results by comparing them to literature. List main findings, so that results can easily be understood by others without advanced data analytics knowledge. Avoid hard-coding. Use variables which get values in the beginning of the pipeline. That way it is easier for you to modify parameters and reuse the code. 18.1 Workflows 18.1.1 Reproducible reporting Create a Quarto file (e.g. Rstudio has ready-made templates for this). Add a code chunk and give a name for it. Render (or knit) the file into pdf or html format Import e.g., iris dataset, and add a dotplot with a title. Create another code chunk and plot. Adjust the size of the figure, and choose from the options that the code chunk will not be shown in the report. Add some text. Add an R command within the text. Update HTML file from the qmd file. For tips on Quarto, see Quarto tutorial 18.2 Data containers 18.2.1 TreeSummarizedExperiment data exploration (Install the latest development version of mia from GitHub) Load experimental dataset from mia. What are the dimensions? (How many samples there are, and how many taxa in each taxonomic rank)? Calculate library size. Summarize sample metadata variables. (How many age groups, how they are distributed? 0%, 25%, 50%, 75%, and 100% quantiles of library size?) Create two histograms. Another shows the distribution of absolute counts, another shows how CLR transformed values are distributed. Visualize how relative abundances are distributed between taxa in samples. Useful functions: nrow, ncol, dim, summary, table, quantile, unique, transformSamples, ggplot, wilcox.test, addPerCellQC, agglomerateByRank, plotAbundance 18.2.2 TreeSummarizedExperiment (TreeSE) data import Import data from CSV files to TreeSE. Import the data files in R Construct a TreeSE data object Check that importing is done correctly. E.g., choose random samples and features, and check that their values equal between raw files and TreeSE. Useful functions: DataFrame, TreeSummarizedExperiment, matrix, rownames, colnames, SimpleList 18.2.3 Introduction to MultiAssayExperient (MAE) Create TreeSE data containers from individual CSV files. Combine TreeSE into MAE. Check that each individual experiment of MAE equals corresponding TreeSE. Take a subset of MAE (e.g., 10 first samples), and observe the subsetted MAE. Useful functions: DataFrame, TreeSummarizedExperiment, matrix, rownames, colnames, MultiAssayExperiment, ExperimentList, SimpleList 18.3 Data manipulation 18.3.1 Prevalent and core features Estimate prevalence for your chosen feature (row, taxonomic group) Identify all prevalent features and subset the data accordingly Report the thresholds and the dimensionality of the data before and after subsetting Visualize prevalence Useful functions: getPrevalence, getPrevalentTaxa, subsetByPrevalentTaxa 18.3.2 Taxonomic levels List the available taxonomic ranks in the data Split the data into alternative experiments by rank (altExp) Merge the data to Phylum level; report dimensionality before and after this Useful functions: taxonomyRanks, agglomerateByRank, mergeRows, splitByRank 18.4 Differential abundance 18.4.1 Univariate analyses Get the abundances for an individual feature (taxonomic group / row) Visualize the abundances per group with boxplot / jitterplot Is the difference significant (Wilcoxon test)? Is the difference significant (linear model with covariates)? How do transformations affect the outcome (log10, clr..)? Get p-values for all features (taxa), for instance with a for loop Do multiple testing correction Compare the results from different tests with a scatterplot Useful functions: [], ggplot2::geom_boxplot, ggplot2::geom_jitter, wilcox.test, lm.test, transformSamples, p.adjust 18.4.2 Differential abundance analysis install the latest development version of mia from GitHub. Load experimental dataset from mia. Compare abundances of each taxa between groups. First, use Wilcoxon or Kruskall-Wallis test. Then use some other method dedicated to microbiome data. Summarize findings by plotting a taxa vs samples heatmap. Add column annotation that tells the group of each sample, and row annotation that tells whether the difference of certain taxa was statistically significant. Choose statistically significant taxa and visualize their abundances with boxplot &amp; jitterplot. Useful functions: wilcox.test, kruskal.test, ggplot, pheatmap, ComplexHeatMap::Heatmap, ancombc, aldex2, maaslin2, agglomerateByRank, transformSamples, transformFeatures, subsetByPrevalentTaxa 18.5 Alpha diversity 18.5.1 Alpha diversity basics Calculate alpha diversity indices Test if data agglomeration to higher taxonomic ranks affects the indices Look for differences in alpha diversity between groups or correlation with a continuous variable Useful functions: estimateDiversity, colSums, agglomerateByRank, kruskal.test, cor 18.5.2 Alpha diversity extra Estimate Shannon diversity for the data Try also another diversity index and compare the results with a scatterplot Compare Shannon diversity between groups (boxplot) Is diversity significantly different between vegan and mixed diet? Calculate and visualize library size, compare with diversity Useful functions: estimateDiversity, colSums, geom_point, geom_boxplot 18.6 Community composition 18.6.1 Beta diversity basics Visualize community variation with different methods (PCA, MDS, NMDS, etc.) with plotReduceDim and with different dissimilarities and transformations,plot also other than the first two axes. Use PERMANOVA to test differences in beta diversity. You can also try including continuous and/or categorical covariates If there are statistical differences in PERMANOVA, test PERMDISP2 (betadisper function) Do clustering Try RDA to test the variance explained by external variables 18.6.2 Beta diversity extra Install the latest development version of mia from GitHub. Load experimental dataset from mia. Create a PCoA with Aitchison dissimilarities. How much coordinate 1 explains the differences? How about coordinate 2? Create dbRDA with Bray-Curtis dissimilarities on relative abundances. Use PERMANOVA. Can differences between samples be explained with variables of sample meta data? Analyze diets’ association on beta diversity. Calculate dbRDA and then PERMANOVA. Visualize coefficients. Which taxa’s abundances differ the most between samples? Interpret your results. Is there association between community composition and location? What are those taxa that differ the most; find information from literature. Useful functions: runMDS, runRDA, anova.cca, transformSamples, agglomerateByRank, ggplot, plotReducedDim, vegan::adonis2 18.7 Visualization 18.7.1 Multivariate ordination Load experimental dataset from mia. Create PCoA with Bray-Curtis dissimilarities Create PCA with Aitchison dissimilarities Visualize and compare both Test other transformations, dissimilarities, and ordination methods Useful functions: runMDS, runNMDS, transformSamples, ggplot, plotReducedDim 18.7.2 Heatmap visualization Load experimental dataset from mia. Visualize abundances with heatmap Visualize abundances with heatmap after CLR + Z transformation See the OMA book for examples. 18.8 Multiomics 18.8.1 Introduction to multiomics Load experimental dataset from microbiomeDataSets (e.g., HintikkaXOData). Analyze correlations between experiments. (Taxa vs lipids, Taxa vs biomarkers, Lipids vs biomarkers) Agglomerate taxa data. Apply CLR to taxa data, apply log10 to lipids and biomarkers. Perform cross-correlation analyses and visualize results with heatmaps. (Use Spearman coefficients) Is there significant correlations? Interpret your results. Useful functions: pheatmap, ComplexHeatMap::Heatmap, ggplot, transformSamples, testExperimentCrossAssociation "],["bibliography.html", "Bibliography", " Bibliography "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
