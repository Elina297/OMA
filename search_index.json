[["index.html", "Orchestrating Microbiome Analysis Preface", " Orchestrating Microbiome Analysis Authors: Leo Lahti [aut], Sudarshan Shetty [aut], Felix GM Ernst [aut, cre] Version: 0.98.9 Modified: 2021-04-10 Compiled: 2021-07-26 Environment: R version 4.1.0 (2021-05-18), Bioconductor 3.14 License: CC BY-NC-SA 3.0 US Copyright: Source: https://github.com/microbiome/OMA Preface This website is a book on microbiome analysis in the Bioconductor universe and is showing common principles and workflows of performing microbiome analysis. The book was borne out of necessity, while updating tools for microbiome analysis to work with common classes of the Bioconductor project handling count data of various sorts. It is heavily influenced by similar resources, such as the Orchestrating Single-Cell Analysis with Bioconductor book, phyloseq tutorials and microbiome tutorials. We focus on microbiome analysis tools, new, updated and established methods. In the Introduction section, we show how to work with the key data infrastructure TreeSummarizedExperiment and related classes, how this framework relates to other infrastructure and how to load microbiome analysis data to work with in the context of this framework. The second section, Focus Topics, is all about the steps for analyzing microbiome data, beginning with the most common steps and progressing to more specialized methods in subsequent sections. The third section, Appendix, contains the rest of things we didn’t find another place for, yet. "],["data-introduction.html", "Chapter 1 Data Infrastructure 1.1 Installation 1.2 Background 1.3 Loading experimental microbiome data 1.4 Metadata 1.5 Microbiome and tree data specific aspects 1.6 Data conversion 1.7 Conclusion 1.8 Additional Reading Session Info", " Chapter 1 Data Infrastructure .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } The SummarizedExperiment (SE) is a widely used class for analyzing data obtained by common sequencing techniques. SE is common structure for several Bioconductor packages that are used for analyzing RNAseq, ChIp-Seq data. SE class is also used in R packages for analyzing microarrays, flow cytometry, proteomics, single-cell sequencing data and many more. The single-cell analysis is facilitated by SingelCellExperiment class (SCE), which allows the user to store results of dimensionality reduction and alternative experiments. Alternative experiments (altExps) can be differently processed data within the analysis workflows. Recently, TreeSummarizedExperiment (TSE) were developed to extend the SE and SCE class for incorporating hierarchical information (including phylogenetic tree) and reference sequences. The mia package implements tools using these classes for analysis of microbiome sequencing data. 1.1 Installation Install the development version from GitHub using remotes R package. # install remotes #install.packages(&quot;remotes&quot;) BiocManager::install(&quot;FelixErnst/mia&quot;) 1.1.1 Packages mia : Microbiome analysis tools miaViz : Microbiome analysis specific visualization See also: microbiome 1.2 Background The widely used phyloseq package and class were around before the SummarizedExperiment and the derived TreeSummarizedExperiment class. Many methods for taxonomic profiling data are readily for the phyloseq class structure. In order to facilitate the transition, we provide here a short description how phyloseq and *Experiment classes relate to each other. assays : This slot is similar to otu_table in phyloseq. In a SummarizedExperiment object multiple assays, raw counts, transformed counts can be stored. See also MultiAssayExperiment for storing data from multiple experiments such as RNASeq, Proteomics, etc. rowData : This slot is similar to tax_table in phyloseq to store taxonomic information. colData : This slot is similar to sample_data in phyloseq to store information related to samples. rowTree : This slot is similar to phy_tree in phyloseq to store phylogenetic tree. In this book, you will come across terms like FeatureIDs and SampleIDs. FeatureIDs : These are basically OTU/ASV ids which are row names in assays and rowData. SampleIDs : As the name suggests, these are sample ids which are column names in assays and row names in colData. FeatureIDs and SampleIDs are used but the technical terms rownames and colnames are encouraged to be used, since they relate to actual objects we work with. Figure sources: Original article - Huang R et al. (2021) TreeSummarizedExperiment: a S4 class for data with hierarchical structure. F1000Research 9:1246. Reference Sequence slot extension - Lahti L et al. (2020) Upgrading the R/Bioconductor ecosystem for microbiome research F1000Research 9:1464 (slides). 1.3 Loading experimental microbiome data 1.3.1 Importing data from external files Microbiome (taxonomic) profiling data is commonly distributed in various file formats. You can import such external data files as a (Tree)SummarizedExperiment object but the details depend on the file format. Here, we provide examples for common formats. CSV data tables can be imported with the standard R functions, then converted to the desired format. For detailed examples, you can check the Bioconductor course material by Martin Morgan. The following example reads abundance tables, taxonomic mapping tables, and sample metadata, assuming that the input data files are properly prepared with appropriate row and column names. counts &lt;- read.csv(count_file) # Abundance table (e.g. ASV data; to assay data) tax &lt;- read.csv(tax_file) # Taxonomy table (to rowData) samples &lt;- read.csv(sample_file) # Sample data (to colData) se &lt;- SummarizedExperiment(assays = list(counts = counts), colData = samples, rowData = tax) A specific import functions are provided for: Biom files (see help(mia::loadFromBiom)) QIIME2 files (see help(mia::loadFromQIIME2)) Mothur files (see help(mia::loadFromMothur)) 1.3.1.1 Example for importing Biom files This example shows how Biom files are imported into a TreeSummarizedExperiment object. The data is from following publication: Tengeler AC et al. (2020) Gut microbiota from persons with attention-deficit/hyperactivity disorder affects the brain in mice. The data set consists of 3 files: biom file: abundance table and taxonomy information csv file: sample metadata tree file: phylogenetic tree Store the data in your desired local directory (for instance, data/ under the working directory), and define source file paths biom_file_path &lt;- &quot;data/Aggregated_humanization2.biom&quot; sample_meta_file_path &lt;- &quot;data/Mapping_file_ADHD_aggregated.csv&quot; tree_file_path &lt;- &quot;data/Data_humanization_phylo_aggregation.tre&quot; Now we can load the biom data into a SummarizedExperiment (SE) object. library(mia) # Imports the data se &lt;- loadFromBiom(biom_file_path) # Check se ## class: SummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): taxonomy1 taxonomy2 ... taxonomy5 taxonomy6 ## colnames(27): A110 A111 ... A38 A39 ## colData names(0): The assays slot includes a list of abundance tables. The imported abundance table is named as “counts.” Let us inspect only the first cols and rows. assays(se)$counts[1:3, 1:3] ## A110 A111 A12 ## 1726470 17722 11630 0 ## 1726471 12052 0 2679 ## 17264731 0 970 0 The rowdata includes taxonomic information from the biom file. The head() command shows just the beginning of the data table for an overview. knitr::kable() is for printing the information more nicely. head(rowData(se)) ## DataFrame with 6 rows and 6 columns ## taxonomy1 taxonomy2 taxonomy3 ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1726470 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## 1726471 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## 17264731 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## 17264726 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## 1726472 &quot;k__Bacteria p__Verrucomicrobia c__Verrucomicrobiae ## 17264724 &quot;k__Bacteria p__Bacteroidetes c__Bacteroidia ## taxonomy4 taxonomy5 taxonomy6 ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1726470 o__Bacteroidales f__Bacteroidaceae g__Bacteroides&quot; ## 1726471 o__Bacteroidales f__Bacteroidaceae g__Bacteroides&quot; ## 17264731 o__Bacteroidales f__Porphyromonadaceae g__Parabacteroides&quot; ## 17264726 o__Bacteroidales f__Bacteroidaceae g__Bacteroides&quot; ## 1726472 o__Verrucomicrobiales f__Verrucomicrobiaceae g__Akkermansia&quot; ## 17264724 o__Bacteroidales f__Bacteroidaceae g__Bacteroides&quot; These taxonomic rank names (column names) are not real rank names. Let’s replace them with real rank names. In addition to that, the taxa names include, e.g., ’\"k__’ before the name, so let’s make them cleaner by removing them. names(rowData(se)) &lt;- c(&quot;Kingdom&quot;, &quot;Phylum&quot;, &quot;Class&quot;, &quot;Order&quot;, &quot;Family&quot;, &quot;Genus&quot;) # Goes through the whole DataFrame. Removes &#39;.*[kpcofg]__&#39; from strings, where [kpcofg] # is any character from listed ones, and .* any character. rowdata_modified &lt;- BiocParallel::bplapply(rowData(se), FUN = stringr::str_remove, pattern = &#39;.*[kpcofg]__&#39;) # Genus level has additional &#39;\\&quot;&#39;, so let&#39;s delete that also rowdata_modified &lt;- BiocParallel::bplapply(rowdata_modified, FUN = stringr::str_remove, pattern = &#39;\\&quot;&#39;) # rowdata_modified is a list, so it is converted back to DataFrame format. rowdata_modified &lt;- DataFrame(rowdata_modified) # And then assigned back to the SE object rowData(se) &lt;- rowdata_modified # Now we have a nicer table head(rowData(se)) ## DataFrame with 6 rows and 6 columns ## Kingdom Phylum Class Order ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1726470 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 1726471 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 17264731 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 17264726 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 1726472 Bacteria Verrucomicrobia Verrucomicrobiae Verrucomicrobiales ## 17264724 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## Family Genus ## &lt;character&gt; &lt;character&gt; ## 1726470 Bacteroidaceae Bacteroides ## 1726471 Bacteroidaceae Bacteroides ## 17264731 Porphyromonadaceae Parabacteroides ## 17264726 Bacteroidaceae Bacteroides ## 1726472 Verrucomicrobiaceae Akkermansia ## 17264724 Bacteroidaceae Bacteroides We notice that the imported biom file did not contain the sample meta data yet, so it includes an empty data frame. head(colData(se)) ## DataFrame with 6 rows and 0 columns Let us add a sample meta data file. # We use this to check what type of data it is # read.table(sample_meta_file_path) # It seems like a comma separated file and it does not include headers # Let us read it and then convert from data.frame to DataFrame # (required for our purposes) sample_meta &lt;- DataFrame(read.table(sample_meta_file_path, sep = &quot;,&quot;, header = FALSE)) # Add sample names to rownames rownames(sample_meta) &lt;- sample_meta[,1] # Delete column that included sample names sample_meta[,1] &lt;- NULL # We can add headers colnames(sample_meta) &lt;- c(&quot;patient_status&quot;, &quot;cohort&quot;, &quot;patient_status_vs_cohort&quot;, &quot;sample_name&quot;) # Then it can be added to colData colData(se) &lt;- sample_meta Now colData includes the sample metadata. head(colData(se)) ## DataFrame with 6 rows and 4 columns ## patient_status cohort patient_status_vs_cohort sample_name ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## A110 ADHD Cohort_1 ADHD_Cohort_1 A110 ## A12 ADHD Cohort_1 ADHD_Cohort_1 A12 ## A15 ADHD Cohort_1 ADHD_Cohort_1 A15 ## A19 ADHD Cohort_1 ADHD_Cohort_1 A19 ## A21 ADHD Cohort_2 ADHD_Cohort_2 A21 ## A23 ADHD Cohort_2 ADHD_Cohort_2 A23 Now, let’s add a phylogenetic tree. The current data object, se, is a SummarizedExperiment object. This does not include a slot for adding a phylogenetic tree. In order to do this, we can convert the SE object to an extended TreeSummarizedExperiment object which includes also a rowTree slot. tse &lt;- as(se, &quot;TreeSummarizedExperiment&quot;) # tse includes same data as se tse ## class: TreeSummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): Kingdom Phylum ... Family Genus ## colnames(27): A110 A12 ... A35 A38 ## colData names(4): patient_status cohort patient_status_vs_cohort ## sample_name ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: NULL ## rowTree: NULL ## colLinks: NULL ## colTree: NULL Next, let us read the tree data file and add it to the R data object (tse). # Reads the tree file tree &lt;- ape::read.tree(tree_file_path) # Add tree to rowTree rowTree(tse) &lt;- tree # Check tse ## class: TreeSummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): Kingdom Phylum ... Family Genus ## colnames(27): A110 A12 ... A35 A38 ## colData names(4): patient_status cohort patient_status_vs_cohort ## sample_name ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (151 rows) ## rowTree: 1 phylo tree(s) (151 leaves) ## colLinks: NULL ## colTree: NULL Now rowTree includes a phylogenetic tree: head(rowTree(tse)) 1.3.2 Conversions between data formats in R If the data is has already been imported in R in another format, it can be readily converted into TreeSummarizedExperiment, as shown in our next example. Note that similar conversion functions to TreeSummarizedExperiment are available for multiple data formats via the mia package (see makeTreeSummarizedExperimentFrom* for phyloseq, Biom, and DADA2). library(mia) # phyloseq example data data(GlobalPatterns, package=&quot;phyloseq&quot;) GlobalPatterns_phyloseq &lt;- GlobalPatterns # convert phyloseq to TSE GlobalPatterns_TSE &lt;- makeTreeSummarizedExperimentFromPhyloseq(GlobalPatterns_phyloseq) We can also convert TreeSummarizedExperiment objects into phyloseq with respect to the shared components that are supported by both formats (i.e. taxonomic abundance table, sample metadata, taxonomic table, phylogenetic tree, sequence information). This is useful for instance when additional methods are available for phyloseq. TODO: conversion function from TSE to phyloseq 1.4 Metadata 1.5 Microbiome and tree data specific aspects library(mia) data(&quot;GlobalPatterns&quot;) se &lt;- GlobalPatterns se ## class: TreeSummarizedExperiment ## dim: 19216 26 ## metadata(0): ## assays(1): counts ## rownames(19216): 549322 522457 ... 200359 271582 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (19216 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL 1.5.1 Assays The assays slot contains the experimental data as count matrices. Multiple matrices can be stored the result of assays is actually a list of matrices. assays(se) ## List of length 1 ## names(1): counts Individual assays can be accessed via assay assay(se, &quot;counts&quot;)[1:5,1:7] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## 549322 0 0 0 0 0 0 0 ## 522457 0 0 0 0 0 0 0 ## 951 0 0 0 0 0 0 1 ## 244423 0 0 0 0 0 0 0 ## 586076 0 0 0 0 0 0 0 To illustrate the use of multiple assays, the relative abundance data can be calcualted and stored along the original count data using relAbundanceCounts. se &lt;- relAbundanceCounts(se) assays(se) ## List of length 2 ## names(2): counts relabundance Now there are two assays available in the se object, counts and relabundance. assay(se, &quot;relabundance&quot;)[1:5,1:7] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## 549322 0 0 0 0 0 0 0.000e+00 ## 522457 0 0 0 0 0 0 0.000e+00 ## 951 0 0 0 0 0 0 2.305e-06 ## 244423 0 0 0 0 0 0 0.000e+00 ## 586076 0 0 0 0 0 0 0.000e+00 1.5.2 colData colData contains data on the samples. colData(se) ## DataFrame with 26 rows and 7 columns ## X.SampleID Primer Final_Barcode Barcode_truncated_plus_T ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## CL3 CL3 ILBC_01 AACGCA TGCGTT ## CC1 CC1 ILBC_02 AACTCG CGAGTT ## SV1 SV1 ILBC_03 AACTGT ACAGTT ## M31Fcsw M31Fcsw ILBC_04 AAGAGA TCTCTT ## M11Fcsw M11Fcsw ILBC_05 AAGCTG CAGCTT ## ... ... ... ... ... ## TS28 TS28 ILBC_25 ACCAGA TCTGGT ## TS29 TS29 ILBC_26 ACCAGC GCTGGT ## Even1 Even1 ILBC_27 ACCGCA TGCGGT ## Even2 Even2 ILBC_28 ACCTCG CGAGGT ## Even3 Even3 ILBC_29 ACCTGT ACAGGT ## Barcode_full_length SampleType ## &lt;factor&gt; &lt;factor&gt; ## CL3 CTAGCGTGCGT Soil ## CC1 CATCGACGAGT Soil ## SV1 GTACGCACAGT Soil ## M31Fcsw TCGACATCTCT Feces ## M11Fcsw CGACTGCAGCT Feces ## ... ... ... ## TS28 GCATCGTCTGG Feces ## TS29 CTAGTCGCTGG Feces ## Even1 TGACTCTGCGG Mock ## Even2 TCTGATCGAGG Mock ## Even3 AGAGAGACAGG Mock ## Description ## &lt;factor&gt; ## CL3 Calhoun South Carolina Pine soil, pH 4.9 ## CC1 Cedar Creek Minnesota, grassland, pH 6.1 ## SV1 Sevilleta new Mexico, desert scrub, pH 8.3 ## M31Fcsw M3, Day 1, fecal swab, whole body study ## M11Fcsw M1, Day 1, fecal swab, whole body study ## ... ... ## TS28 Twin #1 ## TS29 Twin #2 ## Even1 Even1 ## Even2 Even2 ## Even3 Even3 1.5.3 rowData rowData contains data on the features of the samples analyzed. Of particular interest for the microbiome field this is used to store taxonomic information. rowData(se) ## DataFrame with 19216 rows and 7 columns ## Kingdom Phylum Class Order Family ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 549322 Archaea Crenarchaeota Thermoprotei NA NA ## 522457 Archaea Crenarchaeota Thermoprotei NA NA ## 951 Archaea Crenarchaeota Thermoprotei Sulfolobales Sulfolobaceae ## 244423 Archaea Crenarchaeota Sd-NA NA NA ## 586076 Archaea Crenarchaeota Sd-NA NA NA ## ... ... ... ... ... ... ## 278222 Bacteria SR1 NA NA NA ## 463590 Bacteria SR1 NA NA NA ## 535321 Bacteria SR1 NA NA NA ## 200359 Bacteria SR1 NA NA NA ## 271582 Bacteria SR1 NA NA NA ## Genus Species ## &lt;character&gt; &lt;character&gt; ## 549322 NA NA ## 522457 NA NA ## 951 Sulfolobus Sulfolobusacidocalda.. ## 244423 NA NA ## 586076 NA NA ## ... ... ... ## 278222 NA NA ## 463590 NA NA ## 535321 NA NA ## 200359 NA NA ## 271582 NA NA 1.5.4 rowTree Phylogenetic trees also play an important role for the microbiome field. The TreeSummarizedExperiment class is able to keep track of feature and node relations via two functions, rowTree and rowLinks. A tree can be accessed via rowTree as phylo object. rowTree(se) ## ## Phylogenetic tree with 19216 tips and 19215 internal nodes. ## ## Tip labels: ## 549322, 522457, 951, 244423, 586076, 246140, ... ## Node labels: ## , 0.858.4, 1.000.154, 0.764.3, 0.995.2, 1.000.2, ... ## ## Rooted; includes branch lengths. The links to the individual features are available through rowLinks. rowLinks(se) ## LinkDataFrame with 19216 rows and 5 columns ## nodeLab nodeNum nodeLab_alias isLeaf whichTree ## &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;logical&gt; &lt;character&gt; ## 1 549322 1 alias_1 TRUE phylo ## 2 522457 2 alias_2 TRUE phylo ## 3 951 3 alias_3 TRUE phylo ## 4 244423 4 alias_4 TRUE phylo ## 5 586076 5 alias_5 TRUE phylo ## ... ... ... ... ... ... ## 19212 278222 19212 alias_19212 TRUE phylo ## 19213 463590 19213 alias_19213 TRUE phylo ## 19214 535321 19214 alias_19214 TRUE phylo ## 19215 200359 19215 alias_19215 TRUE phylo ## 19216 271582 19216 alias_19216 TRUE phylo Please note that there can be a 1:1 relationship between tree nodes and features, but this is not a must have. This means there can be features, which are not linked to nodes, and nodes, which are not linked to features. To change the links in an existing object, the changeTree function is available. 1.6 Data conversion Sometimes custom solutions are need for analyzing the data. mia contains a few functions to help in these situations. 1.6.1 Tidy data For several custom analysis and visualization packages such as those from the tidyverse the SE data can be converted to long data.frame format with meltAssay. library(mia) molten_se &lt;- meltAssay(se, add_row_data = TRUE, add_col_data = TRUE, abund_values = &quot;relabundance&quot;) molten_se ## # A tibble: 499,616 x 17 ## FeatureID SampleID counts Kingdom Phylum Class Order Family Genus Species ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 549322 CL3 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 549322 CC1 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 549322 SV1 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 549322 M31Fcsw 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 549322 M11Fcsw 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 6 549322 M31Plmr 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 7 549322 M11Plmr 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 8 549322 F21Plmr 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 9 549322 M31Tong 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 10 549322 M11Tong 0 Archaea Crenarc… Thermo… &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # … with 499,606 more rows, and 7 more variables: X.SampleID &lt;fct&gt;, ## # Primer &lt;fct&gt;, Final_Barcode &lt;fct&gt;, Barcode_truncated_plus_T &lt;fct&gt;, ## # Barcode_full_length &lt;fct&gt;, SampleType &lt;fct&gt;, Description &lt;fct&gt; 1.7 Conclusion Some wrapping up… 1.8 Additional Reading 1.8.1 Lecture slides Introduction to microbiome data science lecture slides. 1.8.2 R programming resources R programming basics: Base R Basics of R programming: Base R R cheat sheets R visualization with ggplot2 R graphics cookbook Rmarkdown Rmarkdown tips RStudio RStudio cheat sheet 1.8.3 Resources for TreeSummarizedExperiment SingleCellExperiment Publication Project page SummarizedExperiment Publication Project page TreeSummarizedExperiment Publication Project page 1.8.4 Resources for phyloseq List of R tools for microbiome analysis phyloseq microbiome tutorial microbiomeutilities Bioconductor Workflow for Microbiome Data Analysis: from raw reads to community analyses (Callahan et al. F1000, 2016). 1.8.5 Further reading Data Analysis and Visualization in R for Ecologists by Data Carpentry Modern Statistics for Modern Biology. Holmes &amp; Huber (2018) for background in statistical analysis Microbiome Data Science. Shetty &amp; Lahti, 2019 Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] mia_1.1.7 TreeSummarizedExperiment_2.1.3 [3] Biostrings_2.61.1 XVector_0.33.0 [5] SingleCellExperiment_1.15.1 SummarizedExperiment_1.23.1 [7] Biobase_2.53.0 GenomicRanges_1.45.0 [9] GenomeInfoDb_1.29.3 IRanges_2.27.0 [11] S4Vectors_0.31.0 BiocGenerics_0.39.1 [13] MatrixGenerics_1.5.1 matrixStats_0.59.0 [15] BiocStyle_2.21.3 rebook_1.3.0 loaded via a namespace (and not attached): [1] ggbeeswarm_0.6.0 colorspace_2.0-2 [3] ellipsis_0.3.2 scuttle_1.3.0 [5] BiocNeighbors_1.11.0 bit64_4.0.5 [7] fansi_0.5.0 decontam_1.13.0 [9] splines_4.1.0 codetools_0.2-18 [11] sparseMatrixStats_1.5.0 cachem_1.0.5 [13] knitr_1.33 scater_1.21.2 [15] ade4_1.7-17 phyloseq_1.37.0 [17] jsonlite_1.7.2 cluster_2.1.2 [19] graph_1.71.2 BiocManager_1.30.16 [21] compiler_4.1.0 assertthat_0.2.1 [23] Matrix_1.3-4 fastmap_1.1.0 [25] lazyeval_0.2.2 cli_3.0.1 [27] BiocSingular_1.9.1 htmltools_0.5.1.1 [29] tools_4.1.0 igraph_1.2.6 [31] rsvd_1.0.5 gtable_0.3.0 [33] glue_1.4.2 GenomeInfoDbData_1.2.6 [35] reshape2_1.4.4 dplyr_1.0.7 [37] Rcpp_1.0.7 jquerylib_0.1.4 [39] rhdf5filters_1.5.0 vctrs_0.3.8 [41] multtest_2.49.0 ape_5.5 [43] nlme_3.1-152 DECIPHER_2.21.0 [45] iterators_1.0.13 DelayedMatrixStats_1.15.0 [47] xfun_0.24 stringr_1.4.0 [49] beachmat_2.9.0 lifecycle_1.0.0 [51] irlba_2.3.3 XML_3.99-0.6 [53] zlibbioc_1.39.0 MASS_7.3-54 [55] scales_1.1.1 biomformat_1.21.0 [57] parallel_4.1.0 rhdf5_2.37.0 [59] yaml_2.2.1 memoise_2.0.0 [61] gridExtra_2.3 ggplot2_3.3.5 [63] sass_0.4.0 stringi_1.7.3 [65] RSQLite_2.2.7 foreach_1.5.1 [67] ScaledMatrix_1.1.0 tidytree_0.3.4 [69] permute_0.9-5 filelock_1.0.2 [71] BiocParallel_1.27.2 rlang_0.4.11 [73] pkgconfig_2.0.3 bitops_1.0-7 [75] evaluate_0.14 lattice_0.20-44 [77] Rhdf5lib_1.15.2 purrr_0.3.4 [79] treeio_1.17.2 CodeDepends_0.6.5 [81] bit_4.0.4 tidyselect_1.1.1 [83] plyr_1.8.6 magrittr_2.0.1 [85] bookdown_0.22 R6_2.5.0 [87] generics_0.1.0 DelayedArray_0.19.1 [89] DBI_1.1.1 mgcv_1.8-36 [91] pillar_1.6.1 survival_3.2-11 [93] RCurl_1.98-1.3 tibble_3.1.2 [95] dir.expiry_1.1.0 crayon_1.4.1 [97] utf8_1.2.1 rmarkdown_2.9 [99] viridis_0.6.1 grid_4.1.0 [101] data.table_1.14.0 blob_1.2.1 [103] vegan_2.5-7 digest_0.6.27 [105] tidyr_1.1.3 munsell_0.5.0 [107] DirichletMultinomial_1.35.0 beeswarm_0.4.0 [109] viridisLite_0.4.0 vipor_0.4.5 [111] bslib_0.2.5.1 "],["overview.html", "Chapter 2 Overview 2.1 Introduction 2.2 Microbiome experiment types 2.3 Processing steps 2.4 Quick Start Session Info", " Chapter 2 Overview .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 2.1 Introduction 2.2 Microbiome experiment types 2.3 Processing steps 2.4 Quick Start Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] BiocStyle_2.21.3 rebook_1.3.0 loaded via a namespace (and not attached): [1] graph_1.71.2 knitr_1.33 magrittr_2.0.1 [4] BiocGenerics_0.39.1 R6_2.5.0 rlang_0.4.11 [7] stringr_1.4.0 tools_4.1.0 xfun_0.24 [10] jquerylib_0.1.4 htmltools_0.5.1.1 CodeDepends_0.6.5 [13] yaml_2.2.1 digest_0.6.27 bookdown_0.22 [16] dir.expiry_1.1.0 BiocManager_1.30.16 codetools_0.2-18 [19] sass_0.4.0 evaluate_0.14 rmarkdown_2.9 [22] stringi_1.7.3 compiler_4.1.0 bslib_0.2.5.1 [25] filelock_1.0.2 stats4_4.1.0 XML_3.99-0.6 [28] jsonlite_1.7.2 "],["taxonomic-information.html", "Chapter 3 Taxonomic Information 3.1 Assigning taxonomic information. 3.2 Functions to access taxonomic information 3.3 Data agglomeration 3.4 Data transformation 3.5 Pick specific Session Info", " Chapter 3 Taxonomic Information .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } library(mia) data(&quot;GlobalPatterns&quot;) se &lt;- GlobalPatterns Taxonomic information are a key part of analyzing microbiome data and without it, any type of data analysis probably will not make much sense. However, the degree of detail of taxonomic information differs depending on the dataset and annotation data used. Therefore, the mia package expects a loose assembly of taxonomic information and assumes certain key aspects: Taxonomic information is given as character vectors or factors in the rowData of an SummarizedExperiment object. The columns containing the taxonomic information must be named domain, kingdom, phylum, class, order, family, genus, species or with a capital first letter. the columns must be given in the order shown above column can be omited, but the order must remain 3.1 Assigning taxonomic information. There are a number of methods to assign taxonomic information. We like to give a short introduction about the methods available without ranking one over the other. This has to be your choice based on the result for the individual dataset. 3.1.1 dada2 The dada2 package (Callahan, McMurdie, and Holmes 2020) implements the assignTaxonomy function, which takes as input the ASV sequences associated with each row of data and a training dataset. For more information visit the dada2 website. 3.1.2 DECIPHER The DECIPHER package (Wright 2020) implements the IDTAXA algorithm to assign either taxonomic information or function information. For mia only the first option is of interest for now and more information can be found on the DECIPHER website 3.2 Functions to access taxonomic information checkTaxonomy checks whether the taxonomic information is usable for mia checkTaxonomy(se) ## [1] TRUE Since the rowData can contain other data, taxonomyRanks will return the columns mia assumes to contain the taxonomic information. taxonomyRanks(se) ## [1] &quot;Kingdom&quot; &quot;Phylum&quot; &quot;Class&quot; &quot;Order&quot; &quot;Family&quot; &quot;Genus&quot; &quot;Species&quot; This can then be used to subset the rowData to columns needed. rowData(se)[,taxonomyRanks(se)] ## DataFrame with 19216 rows and 7 columns ## Kingdom Phylum Class Order Family ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 549322 Archaea Crenarchaeota Thermoprotei NA NA ## 522457 Archaea Crenarchaeota Thermoprotei NA NA ## 951 Archaea Crenarchaeota Thermoprotei Sulfolobales Sulfolobaceae ## 244423 Archaea Crenarchaeota Sd-NA NA NA ## 586076 Archaea Crenarchaeota Sd-NA NA NA ## ... ... ... ... ... ... ## 278222 Bacteria SR1 NA NA NA ## 463590 Bacteria SR1 NA NA NA ## 535321 Bacteria SR1 NA NA NA ## 200359 Bacteria SR1 NA NA NA ## 271582 Bacteria SR1 NA NA NA ## Genus Species ## &lt;character&gt; &lt;character&gt; ## 549322 NA NA ## 522457 NA NA ## 951 Sulfolobus Sulfolobusacidocalda.. ## 244423 NA NA ## 586076 NA NA ## ... ... ... ## 278222 NA NA ## 463590 NA NA ## 535321 NA NA ## 200359 NA NA ## 271582 NA NA taxonomyRankEmpty checks for empty values in the given rank and returns a logical vector of length(x). all(!taxonomyRankEmpty(se, rank = &quot;Kingdom&quot;)) ## [1] TRUE table(taxonomyRankEmpty(se, rank = &quot;Genus&quot;)) ## ## FALSE TRUE ## 8008 11208 table(taxonomyRankEmpty(se, rank = &quot;Species&quot;)) ## ## FALSE TRUE ## 1413 17803 getTaxonomyLabels is a multi-purpose function, which turns taxonomic information into a character vector of length(x) head(getTaxonomyLabels(se)) ## [1] &quot;Class:Thermoprotei&quot; &quot;Class:Thermoprotei_1&quot; ## [3] &quot;Species:Sulfolobusacidocaldarius&quot; &quot;Class:Sd-NA&quot; ## [5] &quot;Class:Sd-NA_1&quot; &quot;Class:Sd-NA_2&quot; By default this will used the lowest non-empty information to construct a string with the following scheme level:value. If all levels are the same this part is omited, but can be added by setting with_rank = TRUE phylum &lt;- !is.na(rowData(se)$Phylum) &amp; vapply(data.frame(apply(rowData(se)[,taxonomyRanks(se)[3:7]],1L,is.na)),all,logical(1)) head(getTaxonomyLabels(se[phylum,])) ## [1] &quot;Crenarchaeota&quot; &quot;Crenarchaeota_1&quot; &quot;Crenarchaeota_2&quot; &quot;Actinobacteria&quot; ## [5] &quot;Actinobacteria_1&quot; &quot;Spirochaetes&quot; head(getTaxonomyLabels(se[phylum,], with_rank = TRUE)) ## [1] &quot;Phylum:Crenarchaeota&quot; &quot;Phylum:Crenarchaeota_1&quot; ## [3] &quot;Phylum:Crenarchaeota_2&quot; &quot;Phylum:Actinobacteria&quot; ## [5] &quot;Phylum:Actinobacteria_1&quot; &quot;Phylum:Spirochaetes&quot; By default the return value of getTaxonomyLabels contains only unique elements by passing it through make.unique. This step can be omited by setting make_unique = FALSE head(getTaxonomyLabels(se[phylum,], with_rank = TRUE, make_unique = FALSE)) ## [1] &quot;Phylum:Crenarchaeota&quot; &quot;Phylum:Crenarchaeota&quot; &quot;Phylum:Crenarchaeota&quot; ## [4] &quot;Phylum:Actinobacteria&quot; &quot;Phylum:Actinobacteria&quot; &quot;Phylum:Spirochaetes&quot; To apply the loop resolving function resolveLoop from the TreeSummarizedExperiment package (Huang 2020) within getTaxonomyLabels, set resolve_loops = TRUE. 3.2.1 Generate a taxonomic tree on the fly To create a taxonomic tree taxonomyTree used the information and returns a phylo object. Duplicate information from the rowData are removed. taxonomyTree(se) ## ## Phylogenetic tree with 1645 tips and 1089 internal nodes. ## ## Tip labels: ## Species:Cenarchaeumsymbiosum, Species:pIVWA5, Species:CandidatusNitrososphaeragargensis, Species:SCA1145, Species:SCA1170, Species:Sulfolobusacidocaldarius, ... ## Node labels: ## root:ALL, Kingdom:Archaea, Phylum:Crenarchaeota, Class:C2, Class:Sd-NA, Class:Thaumarchaeota, ... ## ## Rooted; includes branch lengths. se &lt;- addTaxonomyTree(se) se ## class: TreeSummarizedExperiment ## dim: 19216 26 ## metadata(0): ## assays(1): counts ## rownames(19216): Class:Thermoprotei Class:Thermoprotei ... Phylum:SR1 ## Phylum:SR1 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (19216 rows) ## rowTree: 1 phylo tree(s) (1645 leaves) ## colLinks: NULL ## colTree: NULL The implementation is based on the the toTree function from the TreeSummarizedExperiment package (Huang 2020). 3.3 Data agglomeration One of the main applications of taxonomic information in regards to count data is to agglomerate count data on taxonomic levels and track the influence of changing conditions through these levels. For this mia contains the agglomerateByRank function. The ideal location to store the agglomerated data is as an alternative experiment. se &lt;- relAbundanceCounts(se) altExp(se, &quot;Family&quot;) &lt;- agglomerateByRank(se, rank = &quot;Family&quot;, agglomerateTree = TRUE) altExp(se, &quot;Family&quot;) ## class: TreeSummarizedExperiment ## dim: 603 26 ## metadata(0): ## assays(2): counts relabundance ## rownames(603): Class:Thermoprotei Family:Sulfolobaceae ... ## Family:Thermodesulfobiaceae Phylum:SR1 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (603 rows) ## rowTree: 1 phylo tree(s) (496 leaves) ## colLinks: NULL ## colTree: NULL If multiple assays (counts and relabundance) exists, both will be agglomerated. assayNames(se) ## [1] &quot;counts&quot; &quot;relabundance&quot; assayNames(altExp(se, &quot;Family&quot;)) ## [1] &quot;counts&quot; &quot;relabundance&quot; assay(altExp(se, &quot;Family&quot;), &quot;relabundance&quot;)[1:5,1:7] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## Class:Thermoprotei 0.0000000 0.000e+00 0 0 0 0 0.000e+00 ## Family:Sulfolobaceae 0.0000000 0.000e+00 0 0 0 0 2.305e-06 ## Class:Sd-NA 0.0000000 0.000e+00 0 0 0 0 0.000e+00 ## Order:NRP-J 0.0001991 2.070e-04 0 0 0 0 6.914e-06 ## Family:SAGMA-X 0.0000000 6.165e-06 0 0 0 0 0.000e+00 assay(altExp(se, &quot;Family&quot;), &quot;counts&quot;)[1:5,1:7] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Family:Sulfolobaceae 0 0 0 0 0 0 1 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Order:NRP-J 172 235 0 0 0 0 3 ## Family:SAGMA-X 0 7 0 0 0 0 0 altExpNames now consists of Family level data. This can be extended to use any level present in Kingdom, Phylum, Class, Order, Family, Genus, Species. 3.4 Data transformation Data transformation is very common procedure in microbiome analysis. In transformation, each data point is replaced with transformed value that is calculated by applying transformation formula to the data point. Transformation can be used, for example, to normalize skewed data, or to reduce weight of bigger values compared to smaller values. In mia package, transformations are applied to abundance data. Transformed abundance table is stored back to ‘assays.’ mia includes transformation functions for sample-wise or column-wise transformation (‘transformSamples()’), and for feature-wise or row-wise transformation (‘transformFeatures()’). For complete list of available transformations and parameters, see function help. se &lt;- transformSamples(x = se, abund_values = &quot;counts&quot;, method = &quot;clr&quot;, pseudocount = 1, name = &quot;clr_transformation&quot;) head(assay(se, &quot;clr_transformation&quot;)) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr ## Class:Thermoprotei -0.9552 -1.124 -0.7435 -0.2916 -0.2652 -0.356 ## Class:Thermoprotei -0.9552 -1.124 -0.7435 -0.2916 -0.2652 -0.356 ## Species:Sulfolobusacidocaldarius -0.9552 -1.124 -0.7435 -0.2916 -0.2652 -0.356 ## Class:Sd-NA -0.9552 -1.124 -0.7435 -0.2916 -0.2652 -0.356 ## Class:Sd-NA -0.9552 -1.124 -0.7435 -0.2916 -0.2652 -0.356 ## Class:Sd-NA -0.9552 -1.124 -0.7435 -0.2916 -0.2652 -0.356 ## M11Plmr F21Plmr M31Tong M11Tong LMEpi24M ## Class:Thermoprotei -0.4713 -0.2645 -0.2547 -0.1572 -0.359 ## Class:Thermoprotei -0.4713 -0.2645 -0.2547 -0.1572 -0.359 ## Species:Sulfolobusacidocaldarius 0.2219 -0.2645 -0.2547 -0.1572 -0.359 ## Class:Sd-NA -0.4713 -0.2645 -0.2547 -0.1572 -0.359 ## Class:Sd-NA -0.4713 -0.2645 -0.2547 -0.1572 -0.359 ## Class:Sd-NA -0.4713 -0.2645 -0.2547 -0.1572 -0.359 ## SLEpi20M AQC1cm AQC4cm AQC7cm NP2 ## Class:Thermoprotei 0.3704 2.6250 3.7862 4.0751 0.4502 ## Class:Thermoprotei -0.3228 -0.7072 0.2697 1.1459 -0.2429 ## Species:Sulfolobusacidocaldarius -0.3228 -0.7072 -0.8289 -0.8001 -0.2429 ## Class:Sd-NA -0.3228 -0.7072 2.3066 2.6011 -0.2429 ## Class:Sd-NA -0.3228 -0.7072 0.2697 -0.1069 -0.2429 ## Class:Sd-NA -0.3228 -0.7072 -0.1357 0.5862 -0.2429 ## NP3 NP5 TRRsed1 TRRsed2 TRRsed3 TS28 ## Class:Thermoprotei -0.433 -0.3606 -0.2677 -0.4828 -0.4384 -0.2691 ## Class:Thermoprotei -0.433 -0.3606 -0.2677 -0.4828 -0.4384 -0.2691 ## Species:Sulfolobusacidocaldarius -0.433 -0.3606 -0.2677 -0.4828 -0.4384 -0.2691 ## Class:Sd-NA -0.433 -0.3606 -0.2677 -0.4828 -0.4384 -0.2691 ## Class:Sd-NA -0.433 -0.3606 -0.2677 -0.4828 -0.4384 -0.2691 ## Class:Sd-NA -0.433 -0.3606 -0.2677 -0.4828 -0.4384 -0.2691 ## TS29 Even1 Even2 Even3 ## Class:Thermoprotei -0.2569 -0.3481 -0.2534 -0.2382 ## Class:Thermoprotei -0.2569 -0.3481 -0.2534 -0.2382 ## Species:Sulfolobusacidocaldarius -0.2569 -0.3481 -0.2534 -0.2382 ## Class:Sd-NA -0.2569 -0.3481 -0.2534 -0.2382 ## Class:Sd-NA -0.2569 -0.3481 -0.2534 -0.2382 ## Class:Sd-NA -0.2569 -0.3481 -0.2534 -0.2382 In ‘pa’ transformation, ‘threshold’ specifies the value that divides observations to be absent or present. By default, it is 0. se &lt;- transformFeatures(se, method = &quot;pa&quot;, threshold = 10) head(assay(se, &quot;pa&quot;)) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Species:Sulfolobusacidocaldarius 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## F21Plmr M31Tong M11Tong LMEpi24M SLEpi20M ## Class:Thermoprotei 0 0 0 0 0 ## Class:Thermoprotei 0 0 0 0 0 ## Species:Sulfolobusacidocaldarius 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 ## AQC1cm AQC4cm AQC7cm NP2 NP3 NP5 TRRsed1 ## Class:Thermoprotei 1 1 1 0 0 0 0 ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Species:Sulfolobusacidocaldarius 0 0 0 0 0 0 0 ## Class:Sd-NA 0 1 1 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## TRRsed2 TRRsed3 TS28 TS29 Even1 Even2 Even3 ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Class:Thermoprotei 0 0 0 0 0 0 0 ## Species:Sulfolobusacidocaldarius 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 ## Class:Sd-NA 0 0 0 0 0 0 0 # list of abundance tables that assays slot contains assays(se) ## List of length 4 ## names(4): counts relabundance clr_transformation pa 3.5 Pick specific Retrieving of specific elements are required for specific analysis. For instance, extracting abundances for a specific taxa in all samples or all taxa in one sample. 3.5.1 Abundances of all taxa in specific sample taxa.abund.cc1 &lt;- getAbundanceSample(se, sample_id = &quot;CC1&quot;, abund_values = &quot;counts&quot;) taxa.abund.cc1[1:10] ## Class:Thermoprotei Class:Thermoprotei ## 0 0 ## Species:Sulfolobusacidocaldarius Class:Sd-NA ## 0 0 ## Class:Sd-NA Class:Sd-NA ## 0 0 ## Order:NRP-J Order:NRP-J ## 1 0 ## Order:NRP-J Order:NRP-J ## 194 5 3.5.2 Abundances of specific taxa in all samples taxa.abundances &lt;- getAbundanceFeature(se, feature_id = &quot;Phylum:Bacteroidetes&quot;, abund_values = &quot;counts&quot;) taxa.abundances[1:10] ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr M11Plmr F21Plmr M31Tong M11Tong ## 2 18 2 0 0 0 0 1 0 0 Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] mia_1.1.7 TreeSummarizedExperiment_2.1.3 [3] Biostrings_2.61.1 XVector_0.33.0 [5] SingleCellExperiment_1.15.1 SummarizedExperiment_1.23.1 [7] Biobase_2.53.0 GenomicRanges_1.45.0 [9] GenomeInfoDb_1.29.3 IRanges_2.27.0 [11] S4Vectors_0.31.0 BiocGenerics_0.39.1 [13] MatrixGenerics_1.5.1 matrixStats_0.59.0 [15] BiocStyle_2.21.3 rebook_1.3.0 loaded via a namespace (and not attached): [1] ggbeeswarm_0.6.0 colorspace_2.0-2 [3] ellipsis_0.3.2 scuttle_1.3.0 [5] BiocNeighbors_1.11.0 bit64_4.0.5 [7] fansi_0.5.0 decontam_1.13.0 [9] splines_4.1.0 codetools_0.2-18 [11] sparseMatrixStats_1.5.0 cachem_1.0.5 [13] knitr_1.33 scater_1.21.2 [15] jsonlite_1.7.2 cluster_2.1.2 [17] graph_1.71.2 BiocManager_1.30.16 [19] compiler_4.1.0 assertthat_0.2.1 [21] Matrix_1.3-4 fastmap_1.1.0 [23] lazyeval_0.2.2 BiocSingular_1.9.1 [25] htmltools_0.5.1.1 tools_4.1.0 [27] rsvd_1.0.5 gtable_0.3.0 [29] glue_1.4.2 GenomeInfoDbData_1.2.6 [31] reshape2_1.4.4 dplyr_1.0.7 [33] Rcpp_1.0.7 jquerylib_0.1.4 [35] vctrs_0.3.8 ape_5.5 [37] nlme_3.1-152 DECIPHER_2.21.0 [39] DelayedMatrixStats_1.15.0 xfun_0.24 [41] stringr_1.4.0 beachmat_2.9.0 [43] lifecycle_1.0.0 irlba_2.3.3 [45] XML_3.99-0.6 zlibbioc_1.39.0 [47] MASS_7.3-54 scales_1.1.1 [49] parallel_4.1.0 yaml_2.2.1 [51] memoise_2.0.0 gridExtra_2.3 [53] ggplot2_3.3.5 sass_0.4.0 [55] stringi_1.7.3 RSQLite_2.2.7 [57] ScaledMatrix_1.1.0 tidytree_0.3.4 [59] permute_0.9-5 filelock_1.0.2 [61] BiocParallel_1.27.2 rlang_0.4.11 [63] pkgconfig_2.0.3 bitops_1.0-7 [65] evaluate_0.14 lattice_0.20-44 [67] purrr_0.3.4 treeio_1.17.2 [69] CodeDepends_0.6.5 bit_4.0.4 [71] tidyselect_1.1.1 plyr_1.8.6 [73] magrittr_2.0.1 bookdown_0.22 [75] R6_2.5.0 generics_0.1.0 [77] DelayedArray_0.19.1 DBI_1.1.1 [79] mgcv_1.8-36 pillar_1.6.1 [81] RCurl_1.98-1.3 tibble_3.1.2 [83] dir.expiry_1.1.0 crayon_1.4.1 [85] utf8_1.2.1 rmarkdown_2.9 [87] viridis_0.6.1 grid_4.1.0 [89] blob_1.2.1 vegan_2.5-7 [91] digest_0.6.27 tidyr_1.1.3 [93] munsell_0.5.0 DirichletMultinomial_1.35.0 [95] beeswarm_0.4.0 viridisLite_0.4.0 [97] vipor_0.4.5 bslib_0.2.5.1 Bibliography "],["quality-control.html", "Chapter 4 Quality Control 4.1 Get top taxa and taxonomy 4.2 Library size Session Info", " Chapter 4 Quality Control .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } library(mia) data(&quot;GlobalPatterns&quot;) se &lt;- GlobalPatterns 4.1 Get top taxa and taxonomy 4.1.1 Features The getTopTaxa can be used for identifying top taxa in the data. top_features &lt;- getTopTaxa(se, method=&quot;median&quot;, top=10) tax_data &lt;- rowData(se)[top_features,taxonomyRanks(se)] tax_data ## DataFrame with 10 rows and 7 columns ## Kingdom Phylum Class Order ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 549656 Bacteria Cyanobacteria Chloroplast Stramenopiles ## 331820 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 317182 Bacteria Cyanobacteria Chloroplast Stramenopiles ## 94166 Bacteria Proteobacteria Gammaproteobacteria Pasteurellales ## 279599 Bacteria Cyanobacteria Nostocophycideae Nostocales ## 158660 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 329744 Bacteria Actinobacteria Actinobacteria Actinomycetales ## 326977 Bacteria Actinobacteria Actinobacteria Bifidobacteriales ## 248140 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 550960 Bacteria Proteobacteria Gammaproteobacteria Enterobacteriales ## Family Genus Species ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 549656 NA NA NA ## 331820 Bacteroidaceae Bacteroides NA ## 317182 NA NA NA ## 94166 Pasteurellaceae Haemophilus Haemophilusparainflu.. ## 279599 Nostocaceae Dolichospermum NA ## 158660 Bacteroidaceae Bacteroides NA ## 329744 ACK-M1 NA NA ## 326977 Bifidobacteriaceae Bifidobacterium Bifidobacteriumadole.. ## 248140 Bacteroidaceae Bacteroides Bacteroidescaccae ## 550960 Enterobacteriaceae Providencia NA 4.2 Library size The total counts/sample can be calculated using the perCellQCMetrics/addPerCellQC from the scater package. The first one just calculates the values, whereas the latter one directly adds them to the colData. library(scater) perCellQCMetrics(se) ## DataFrame with 26 rows and 3 columns ## sum detected total ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## CL3 864077 6964 864077 ## CC1 1135457 7679 1135457 ## SV1 697509 5729 697509 ## M31Fcsw 1543451 2667 1543451 ## M11Fcsw 2076476 2574 2076476 ## ... ... ... ... ## TS28 937466 2679 937466 ## TS29 1211071 2629 1211071 ## Even1 1216137 4213 1216137 ## Even2 971073 3130 971073 ## Even3 1078241 2776 1078241 se &lt;- addPerCellQC(se) colData(se) ## DataFrame with 26 rows and 10 columns ## X.SampleID Primer Final_Barcode Barcode_truncated_plus_T ## &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; ## CL3 CL3 ILBC_01 AACGCA TGCGTT ## CC1 CC1 ILBC_02 AACTCG CGAGTT ## SV1 SV1 ILBC_03 AACTGT ACAGTT ## M31Fcsw M31Fcsw ILBC_04 AAGAGA TCTCTT ## M11Fcsw M11Fcsw ILBC_05 AAGCTG CAGCTT ## ... ... ... ... ... ## TS28 TS28 ILBC_25 ACCAGA TCTGGT ## TS29 TS29 ILBC_26 ACCAGC GCTGGT ## Even1 Even1 ILBC_27 ACCGCA TGCGGT ## Even2 Even2 ILBC_28 ACCTCG CGAGGT ## Even3 Even3 ILBC_29 ACCTGT ACAGGT ## Barcode_full_length SampleType ## &lt;factor&gt; &lt;factor&gt; ## CL3 CTAGCGTGCGT Soil ## CC1 CATCGACGAGT Soil ## SV1 GTACGCACAGT Soil ## M31Fcsw TCGACATCTCT Feces ## M11Fcsw CGACTGCAGCT Feces ## ... ... ... ## TS28 GCATCGTCTGG Feces ## TS29 CTAGTCGCTGG Feces ## Even1 TGACTCTGCGG Mock ## Even2 TCTGATCGAGG Mock ## Even3 AGAGAGACAGG Mock ## Description sum detected ## &lt;factor&gt; &lt;numeric&gt; &lt;numeric&gt; ## CL3 Calhoun South Carolina Pine soil, pH 4.9 864077 6964 ## CC1 Cedar Creek Minnesota, grassland, pH 6.1 1135457 7679 ## SV1 Sevilleta new Mexico, desert scrub, pH 8.3 697509 5729 ## M31Fcsw M3, Day 1, fecal swab, whole body study 1543451 2667 ## M11Fcsw M1, Day 1, fecal swab, whole body study 2076476 2574 ## ... ... ... ... ## TS28 Twin #1 937466 2679 ## TS29 Twin #2 1211071 2629 ## Even1 Even1 1216137 4213 ## Even2 Even2 971073 3130 ## Even3 Even3 1078241 2776 ## total ## &lt;numeric&gt; ## CL3 864077 ## CC1 1135457 ## SV1 697509 ## M31Fcsw 1543451 ## M11Fcsw 2076476 ## ... ... ## TS28 937466 ## TS29 1211071 ## Even1 1216137 ## Even2 971073 ## Even3 1078241 The distribution of calculated library sizes can be visualized as a histogram. library(ggplot2) ggplot(as.data.frame(colData(se))) + geom_histogram(aes(x = sum), color = &quot;black&quot;, fill = &quot;gray&quot;, bins = 30) + labs(x = &quot;Library size&quot;, y = &quot;Frequency&quot;) + theme_bw() + theme(panel.grid.major = element_blank(), # Removes the grid panel.grid.minor = element_blank(), panel.border = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) # Adds y-axis Figure 4.1: Library size distribution. Library sizes - and other variables from colData - can be also visualized by using specified function called plotColData. library(ggplot2) plotColData(se,&quot;sum&quot;,&quot;X.SampleID&quot;, colour_by = &quot;X.SampleID&quot;) + theme(axis.text.x = element_text(angle = 45, hjust=1)) Figure 4.2: Library sizes per sample. plotColData(se,&quot;sum&quot;,&quot;SampleType&quot;, colour_by = &quot;SampleType&quot;) + theme(axis.text.x = element_text(angle = 45, hjust=1)) Figure 4.3: Library sizes per sample type. Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] scater_1.21.2 ggplot2_3.3.5 [3] scuttle_1.3.0 mia_1.1.7 [5] TreeSummarizedExperiment_2.1.3 Biostrings_2.61.1 [7] XVector_0.33.0 SingleCellExperiment_1.15.1 [9] SummarizedExperiment_1.23.1 Biobase_2.53.0 [11] GenomicRanges_1.45.0 GenomeInfoDb_1.29.3 [13] IRanges_2.27.0 S4Vectors_0.31.0 [15] BiocGenerics_0.39.1 MatrixGenerics_1.5.1 [17] matrixStats_0.59.0 BiocStyle_2.21.3 [19] rebook_1.3.0 loaded via a namespace (and not attached): [1] ggbeeswarm_0.6.0 colorspace_2.0-2 [3] ellipsis_0.3.2 BiocNeighbors_1.11.0 [5] farver_2.1.0 bit64_4.0.5 [7] fansi_0.5.0 decontam_1.13.0 [9] splines_4.1.0 codetools_0.2-18 [11] sparseMatrixStats_1.5.0 cachem_1.0.5 [13] knitr_1.33 jsonlite_1.7.2 [15] cluster_2.1.2 graph_1.71.2 [17] BiocManager_1.30.16 compiler_4.1.0 [19] assertthat_0.2.1 Matrix_1.3-4 [21] fastmap_1.1.0 lazyeval_0.2.2 [23] BiocSingular_1.9.1 htmltools_0.5.1.1 [25] tools_4.1.0 rsvd_1.0.5 [27] gtable_0.3.0 glue_1.4.2 [29] GenomeInfoDbData_1.2.6 reshape2_1.4.4 [31] dplyr_1.0.7 Rcpp_1.0.7 [33] jquerylib_0.1.4 vctrs_0.3.8 [35] ape_5.5 nlme_3.1-152 [37] DECIPHER_2.21.0 DelayedMatrixStats_1.15.0 [39] xfun_0.24 stringr_1.4.0 [41] beachmat_2.9.0 lifecycle_1.0.0 [43] irlba_2.3.3 XML_3.99-0.6 [45] zlibbioc_1.39.0 MASS_7.3-54 [47] scales_1.1.1 parallel_4.1.0 [49] yaml_2.2.1 memoise_2.0.0 [51] gridExtra_2.3 sass_0.4.0 [53] stringi_1.7.3 RSQLite_2.2.7 [55] highr_0.9 ScaledMatrix_1.1.0 [57] tidytree_0.3.4 permute_0.9-5 [59] filelock_1.0.2 BiocParallel_1.27.2 [61] rlang_0.4.11 pkgconfig_2.0.3 [63] bitops_1.0-7 evaluate_0.14 [65] lattice_0.20-44 purrr_0.3.4 [67] labeling_0.4.2 treeio_1.17.2 [69] CodeDepends_0.6.5 cowplot_1.1.1 [71] bit_4.0.4 tidyselect_1.1.1 [73] plyr_1.8.6 magrittr_2.0.1 [75] bookdown_0.22 R6_2.5.0 [77] generics_0.1.0 DelayedArray_0.19.1 [79] DBI_1.1.1 withr_2.4.2 [81] mgcv_1.8-36 pillar_1.6.1 [83] RCurl_1.98-1.3 tibble_3.1.2 [85] dir.expiry_1.1.0 crayon_1.4.1 [87] utf8_1.2.1 rmarkdown_2.9 [89] viridis_0.6.1 grid_4.1.0 [91] blob_1.2.1 vegan_2.5-7 [93] digest_0.6.27 tidyr_1.1.3 [95] munsell_0.5.0 DirichletMultinomial_1.35.0 [97] beeswarm_0.4.0 viridisLite_0.4.0 [99] vipor_0.4.5 bslib_0.2.5.1 "],["microbiome-exploration.html", "Chapter 5 Microbiome Exploration 5.1 Prevalence Session Info", " Chapter 5 Microbiome Exploration .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } This chapter focuses on the exploration of microbiome data and establish commonly used descriptors of a microbiome. The main difference to quality control is that the exploration assumes the technical aspects of the dataset have been investigated to your satisfaction. Generally speaking at this point you should be quite certain, that the dataset doesn’t suffer from severe technical biases or you should at least be aware of potential problems. In reality you might need to go back and forth between QC and exploration, since you discover through exploration of your dataset technical aspects you need to check. library(mia) data(&quot;GlobalPatterns&quot;) se &lt;- GlobalPatterns 5.1 Prevalence Prevalence is a measurements, which describes in how many samples certain microbes were detected. Investigating the prevalence of microbes allows you either to focus on changes, which pertain to most of the samples, or to focus on less often found microbes, which are nonetheless abundantly found in a small number of samples. On the raw data, the population prevalence (frequency) at a 1% relative abundance threshold (detection = 1/100 and as_relative = TRUE), can look like this. The low prevalence in this examples can be explained by rather different sample types as well as the in depth nature of the data. head(getPrevalence(se, detection = 1/100, sort = TRUE, as_relative = TRUE)) ## 331820 158660 98605 326977 145149 114821 ## 0.2308 0.2308 0.1923 0.1923 0.1538 0.1538 The detection and as_relative can also be used to access, how many samples do pass a threshold for raw counts. Here the population prevalence (frequency) at the absolute abundance threshold (as_relative = FALSE) at read count 1 (detection = TRUE) is accessed. head(getPrevalence(se, detection = 1, sort = TRUE, abund_values = &quot;counts&quot;, as_relative = FALSE)) ## 145149 114821 108747 526804 98605 180658 ## 1 1 1 1 1 1 Note that, if the output should used for subsetting or storing the data in the rowData, set sort = FALSE. 5.1.1 Prevalent microbiota analysis To investigate the microbiome data at a selected taxonomic levels, two approaches are available. First the data can be agglomerated to the taxonomic level and getPrevalence be used on the result. altExp(se,&quot;Phylum&quot;) &lt;- agglomerateByRank(se, &quot;Phylum&quot;) head(getPrevalence(altExp(se,&quot;Phylum&quot;), detection = 1/100, sort = TRUE, abund_values = &quot;counts&quot;, as_relative = TRUE)) ## Phylum:Bacteroidetes Phylum:Proteobacteria Phylum:Actinobacteria ## 1.0000 0.9231 0.8462 ## Phylum:Cyanobacteria Phylum:Firmicutes Phylum:Verrucomicrobia ## 0.6154 0.5769 0.4615 Alternatively the rank argument can be set, to perform the agglomeration on the fly. altExp(se,&quot;Phylum&quot;) &lt;- agglomerateByRank(se, &quot;Phylum&quot;) head(getPrevalence(se, rank = &quot;Phylum&quot;, detection = 1/100, sort = TRUE, abund_values = &quot;counts&quot;, as_relative = TRUE)) ## Bacteroidetes Proteobacteria Actinobacteria Cyanobacteria Firmicutes ## 1.0000 0.9231 0.8462 0.6154 0.5769 ## Verrucomicrobia ## 0.4615 The difference in the naming scheme, is that by default na.rm = TRUE is used for agglomeration in getPrevalence, whereas the default for agglomerateByRank is FALSE to prevent accidental data loss. If you only need the names of the prevalent taxa, getPrevalentTaxa is available. This returns the taxa that exceed the given prevalence and detection thresholds. getPrevalentTaxa(se, detection = 0, prevalence = 50/100) prev &lt;- getPrevalentTaxa(se, detection = 0, prevalence = 50/100, rank = &quot;Phylum&quot;, sort = TRUE) prev Note, that the detection and prevalence thresholds are not the same, since detection can be applied to relative counts or absolute couts depending on whether as_relative is set TRUE or FALSE TODO See also related functions for the analysis of rare and variable taxa (rareMembers; rareAbundance; lowAbundance). 5.1.2 Plotting prevalence To plot the prevalence, the data is first added to the rowData. rowData(altExp(se,&quot;Phylum&quot;))$prevalence &lt;- getPrevalence(altExp(se,&quot;Phylum&quot;), detection = 1/100, sort = FALSE, abund_values = &quot;counts&quot;, as_relative = TRUE) Then it can be plotted via the plotting functions from the scater package. library(scater) plotRowData(altExp(se,&quot;Phylum&quot;), &quot;prevalence&quot;, colour_by = &quot;Phylum&quot;) Additionally, the prevalence can be plotted on the taxonomic tree using the miaViz package. altExps(se) &lt;- splitByRanks(se) altExps(se) &lt;- lapply(altExps(se), function(y){ rowData(y)$prevalence &lt;- getPrevalence(y, detection = 1/100, sort = FALSE, abund_values = &quot;counts&quot;, as_relative = TRUE) y }) top_phyla &lt;- getTopTaxa(altExp(se,&quot;Phylum&quot;), method=&quot;prevalence&quot;, top=10L, abund_values=&quot;counts&quot;) top_phyla_mean &lt;- getTopTaxa(altExp(se,&quot;Phylum&quot;), method=&quot;mean&quot;, top=10L, abund_values=&quot;counts&quot;) x &lt;- unsplitByRanks(se, ranks = taxonomyRanks(se)[1:6]) x &lt;- addTaxonomyTree(x) After some preparation the data is assembled and can be plotted via plotRowTree. library(miaViz) plotRowTree(x[rowData(x)$Phylum %in% top_phyla,], edge_colour_by = &quot;Phylum&quot;, tip_colour_by = &quot;prevalence&quot;, node_colour_by = &quot;prevalence&quot;) Figure 5.1: Prevalence of top phyla as judged by prevalence plotRowTree(x[rowData(x)$Phylum %in% top_phyla_mean,], edge_colour_by = &quot;Phylum&quot;, tip_colour_by = &quot;prevalence&quot;, node_colour_by = &quot;prevalence&quot;) Figure 5.2: Prevalence of top phyla as judged by mean abundance Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] miaViz_1.1.2 ggraph_2.0.5 [3] scater_1.21.2 ggplot2_3.3.5 [5] scuttle_1.3.0 mia_1.1.7 [7] TreeSummarizedExperiment_2.1.3 Biostrings_2.61.1 [9] XVector_0.33.0 SingleCellExperiment_1.15.1 [11] SummarizedExperiment_1.23.1 Biobase_2.53.0 [13] GenomicRanges_1.45.0 GenomeInfoDb_1.29.3 [15] IRanges_2.27.0 S4Vectors_0.31.0 [17] BiocGenerics_0.39.1 MatrixGenerics_1.5.1 [19] matrixStats_0.59.0 BiocStyle_2.21.3 [21] rebook_1.3.0 loaded via a namespace (and not attached): [1] ggtree_3.1.2 ggnewscale_0.4.5 [3] ggbeeswarm_0.6.0 colorspace_2.0-2 [5] ellipsis_0.3.2 BiocNeighbors_1.11.0 [7] aplot_0.0.6 farver_2.1.0 [9] graphlayouts_0.7.1 ggrepel_0.9.1 [11] bit64_4.0.5 fansi_0.5.0 [13] decontam_1.13.0 splines_4.1.0 [15] codetools_0.2-18 sparseMatrixStats_1.5.0 [17] cachem_1.0.5 knitr_1.33 [19] polyclip_1.10-0 jsonlite_1.7.2 [21] cluster_2.1.2 graph_1.71.2 [23] ggforce_0.3.3 BiocManager_1.30.16 [25] compiler_4.1.0 rvcheck_0.1.8 [27] assertthat_0.2.1 Matrix_1.3-4 [29] fastmap_1.1.0 lazyeval_0.2.2 [31] tweenr_1.0.2 BiocSingular_1.9.1 [33] htmltools_0.5.1.1 tools_4.1.0 [35] igraph_1.2.6 rsvd_1.0.5 [37] gtable_0.3.0 glue_1.4.2 [39] GenomeInfoDbData_1.2.6 reshape2_1.4.4 [41] dplyr_1.0.7 Rcpp_1.0.7 [43] jquerylib_0.1.4 vctrs_0.3.8 [45] ape_5.5 nlme_3.1-152 [47] DECIPHER_2.21.0 DelayedMatrixStats_1.15.0 [49] xfun_0.24 stringr_1.4.0 [51] beachmat_2.9.0 lifecycle_1.0.0 [53] irlba_2.3.3 XML_3.99-0.6 [55] zlibbioc_1.39.0 MASS_7.3-54 [57] scales_1.1.1 tidygraph_1.2.0 [59] parallel_4.1.0 yaml_2.2.1 [61] memoise_2.0.0 gridExtra_2.3 [63] sass_0.4.0 stringi_1.7.3 [65] RSQLite_2.2.7 highr_0.9 [67] ScaledMatrix_1.1.0 tidytree_0.3.4 [69] permute_0.9-5 filelock_1.0.2 [71] BiocParallel_1.27.2 rlang_0.4.11 [73] pkgconfig_2.0.3 bitops_1.0-7 [75] evaluate_0.14 lattice_0.20-44 [77] purrr_0.3.4 patchwork_1.1.1 [79] labeling_0.4.2 treeio_1.17.2 [81] CodeDepends_0.6.5 cowplot_1.1.1 [83] bit_4.0.4 tidyselect_1.1.1 [85] plyr_1.8.6 magrittr_2.0.1 [87] bookdown_0.22 R6_2.5.0 [89] generics_0.1.0 DelayedArray_0.19.1 [91] DBI_1.1.1 withr_2.4.2 [93] mgcv_1.8-36 pillar_1.6.1 [95] RCurl_1.98-1.3 tibble_3.1.2 [97] dir.expiry_1.1.0 crayon_1.4.1 [99] utf8_1.2.1 rmarkdown_2.9 [101] viridis_0.6.1 grid_4.1.0 [103] blob_1.2.1 vegan_2.5-7 [105] digest_0.6.27 tidyr_1.1.3 [107] munsell_0.5.0 DirichletMultinomial_1.35.0 [109] beeswarm_0.4.0 viridisLite_0.4.0 [111] vipor_0.4.5 bslib_0.2.5.1 "],["alpha-diversity.html", "Chapter 6 Alpha Diversity 6.1 Estimating alpha diversity 6.2 Visualize alpha diversities Session Info", " Chapter 6 Alpha Diversity .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } Diversity estimates are a central topic in microbiome data analysis. There are three commonly employed levels of diversity measurements, which are trying to put a number on different aspects of the questions associated with diversity (Whittaker 1960). Many different ways for estimating such diversity measurements have been described in the literature. Which measurement is best or applicable for your samples, is not the aim of the following sections. library(mia) data(&quot;GlobalPatterns&quot;) se &lt;- GlobalPatterns Alpha diversity, also sometimes interchangeably used with the term species diversity, summarizes the distribution of species abundances in a given sample into a single number that depends on species richness and evenness. Diversity indices measure the overall community heterogeneity. A number of ecological diversity measures are available. The Hill coefficient combines many standard indices into a single equation that provides observed richness, inverse Simpson, and Shannon diversity, and generalized diversity as special cases. In general, diversity increases together with increasing richness and evenness. Sometimes richness, evenness, and dominance are considered to be variants of alpha diversity. Richness refers to the total number of species in a community (sample). The simplest richness index is the number of observed species (observed richness). Assuming limited sampling from the community, however, this may underestimate the true species richness. Several estimators are available, including for instance ACE (A and SM 1992) and Chao1 (A 1984). Richness estimates are unaffected by species abundances. Phylogenetic diversity was first proposed by (Faith 1992), unlike the diversity measures mentioned above, Phylogenetic diversity (PD) measure incorporates information from phylogenetic relationships stored in phylo tree between species in a community (sample). The Faith’s PD is calculated as the sum of branch length of all species in a community (sample). Evenness focuses on species abundances, and can thus complement the number of species. A typical evenness index is the Pielou’s evenness, which is Shannon diversity normalized by the observed richness. Dominance indices are in general negatively correlated with diversity, and sometimes used in ecological literature. High dominance is obtained when one or few species have a high share of the total species abundance in the community. 6.1 Estimating alpha diversity Alpha diversity can be estimated with wrapper functions that interact with other packages implementing the calculation, such as vegan (Oksanen et al. 2020). 6.1.1 Richness Richness gives the number of features present within a community and can be calculated with estimateRichness. Each of the estimate diversity/richness/evenness/dominance functions adds the calculated measure(s) to the colData of the SummarizedExperiment under the given column name. Here, we calculate observed features as a measure of richness. se &lt;- mia::estimateRichness(se, abund_values = &quot;counts&quot;, index = &quot;observed&quot;, name=&quot;observed&quot;) head(colData(se)$observed) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr ## 6964 7679 5729 2667 2574 3214 This allows access to the values to be analyzed directly from the colData, for example by plotting them using plotColData from the scater package (McCarthy et al. 2020). library(scater) plotColData(se, &quot;observed&quot;, &quot;SampleType&quot;, colour_by = &quot;SampleType&quot;) + theme(axis.text.x = element_text(angle=45,hjust=1)) + ylab(expression(Richness[Observed])) Figure 6.1: Shannon diversity estimates plotted grouped by sample type. 6.1.2 Diversity Non-Phylogenetic measures The main function, estimateDiversity, calculates the selected diversity index based on the selected assay data. se &lt;- mia::estimateDiversity(se, abund_values = &quot;counts&quot;, index = &quot;shannon&quot;, name = &quot;shannon&quot;) head(colData(se)$shannon) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr ## 6.577 6.777 6.498 3.828 3.288 4.289 Alpha diversities can be visualized with boxplot. Here, Shannon index is compared between different sample type groups. Individual data points are visualized by plotting them as points with geom_jitter. geom_signif is used to test, if these differences are statistically significant. It adds p-values to plot. if( !require(ggsignif) ){ install.packages(ggsignif) } library(ggplot2) library(ggsignif) # Subsets the data. Takes only those samples that are from feces, skin, or tongue, # and creates data frame from the collected data df &lt;- as.data.frame(colData(se)[colData(se)$SampleType %in% c(&quot;Feces&quot;, &quot;Skin&quot;, &quot;Tongue&quot;), ]) # Changes old levels with new levels df$SampleType &lt;- factor(df$SampleType) # For significance testing, all different combinations are determined comb &lt;- split(t(combn(levels(df$SampleType), 2)), seq(nrow(t(combn(levels(df$SampleType), 2))))) ggplot(df, aes(x = SampleType, y = shannon)) + # Outliers are removed, because otherwise each data point would be plotted twice; # as an outlier of boxplot and as a point of dotplot. geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2) + geom_signif(comparisons = comb, map_signif_level = FALSE) + theme(text = element_text(size = 10)) Phylogenetic diversity The phylogenetic diversity is calculated by mia::estimateDiversity. This is a faster re-implementation of the widely function in picante W et al. (2010). Load picante R package and get the phylo stored in rowTree. se &lt;- mia::estimateDiversity(se, abund_values = &quot;counts&quot;, index = &quot;faith&quot;, name = &quot;faith&quot;) head(colData(se)$faith) ## [1] 250.5 262.3 208.5 117.9 119.8 135.8 6.1.3 Evenness Evenness can be calculated with estimateEvenness. se &lt;- estimateEvenness(se, abund_values = &quot;counts&quot;, index=&quot;simpson&quot;) head(colData(se)$simpson) ## [1] 0.026871 0.027197 0.047049 0.005179 0.004304 0.005011 6.1.4 Dominance Dominance can be calculated with estimateDominance. Here, the Relative index is calculated which is the relative abundance of the most dominant species in the sample. se &lt;- estimateDominance(se, abund_values = &quot;counts&quot;, index=&quot;relative&quot;) head(colData(se)$relative) ## CL3 CC1 SV1 M31Fcsw M11Fcsw M31Plmr ## 0.03910 0.03226 0.01690 0.22981 0.21778 0.22329 6.1.5 Rarity TODO… 6.2 Visualize alpha diversities A plot comparing all the diversity measures calculated above and stored in colData can then be constructed directly. plots &lt;- lapply(c(&quot;observed&quot;, &quot;shannon&quot;,&quot;simpson&quot;, &quot;relative&quot;, &quot;faith&quot;), plotColData, object = se, x = &quot;SampleType&quot;, colour_by = &quot;SampleType&quot;) plots &lt;- lapply(plots,&quot;+&quot;, theme(axis.text.x = element_text(angle=45,hjust=1))) ggpubr::ggarrange(plotlist = plots, nrow = 2, ncol = 3, common.legend = TRUE, legend = &quot;right&quot;) Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] ggsignif_0.6.2 scater_1.21.2 [3] ggplot2_3.3.5 scuttle_1.3.0 [5] mia_1.1.7 TreeSummarizedExperiment_2.1.3 [7] Biostrings_2.61.1 XVector_0.33.0 [9] SingleCellExperiment_1.15.1 SummarizedExperiment_1.23.1 [11] Biobase_2.53.0 GenomicRanges_1.45.0 [13] GenomeInfoDb_1.29.3 IRanges_2.27.0 [15] S4Vectors_0.31.0 BiocGenerics_0.39.1 [17] MatrixGenerics_1.5.1 matrixStats_0.59.0 [19] BiocStyle_2.21.3 rebook_1.3.0 loaded via a namespace (and not attached): [1] readxl_1.3.1 backports_1.2.1 [3] plyr_1.8.6 lazyeval_0.2.2 [5] splines_4.1.0 BiocParallel_1.27.2 [7] digest_0.6.27 htmltools_0.5.1.1 [9] viridis_0.6.1 fansi_0.5.0 [11] magrittr_2.0.1 memoise_2.0.0 [13] ScaledMatrix_1.1.0 cluster_2.1.2 [15] DECIPHER_2.21.0 openxlsx_4.2.4 [17] colorspace_2.0-2 blob_1.2.1 [19] haven_2.4.1 xfun_0.24 [21] dplyr_1.0.7 crayon_1.4.1 [23] RCurl_1.98-1.3 jsonlite_1.7.2 [25] graph_1.71.2 ape_5.5 [27] glue_1.4.2 gtable_0.3.0 [29] zlibbioc_1.39.0 DelayedArray_0.19.1 [31] car_3.0-11 BiocSingular_1.9.1 [33] abind_1.4-5 scales_1.1.1 [35] DBI_1.1.1 rstatix_0.7.0 [37] Rcpp_1.0.7 viridisLite_0.4.0 [39] decontam_1.13.0 tidytree_0.3.4 [41] foreign_0.8-81 bit_4.0.4 [43] rsvd_1.0.5 dir.expiry_1.1.0 [45] ellipsis_0.3.2 pkgconfig_2.0.3 [47] XML_3.99-0.6 farver_2.1.0 [49] CodeDepends_0.6.5 sass_0.4.0 [51] utf8_1.2.1 tidyselect_1.1.1 [53] labeling_0.4.2 rlang_0.4.11 [55] reshape2_1.4.4 cellranger_1.1.0 [57] munsell_0.5.0 tools_4.1.0 [59] cachem_1.0.5 DirichletMultinomial_1.35.0 [61] generics_0.1.0 RSQLite_2.2.7 [63] broom_0.7.8 evaluate_0.14 [65] stringr_1.4.0 fastmap_1.1.0 [67] yaml_2.2.1 knitr_1.33 [69] bit64_4.0.5 zip_2.2.0 [71] purrr_0.3.4 nlme_3.1-152 [73] sparseMatrixStats_1.5.0 compiler_4.1.0 [75] beeswarm_0.4.0 filelock_1.0.2 [77] curl_4.3.2 treeio_1.17.2 [79] tibble_3.1.2 bslib_0.2.5.1 [81] stringi_1.7.3 highr_0.9 [83] forcats_0.5.1 lattice_0.20-44 [85] Matrix_1.3-4 vegan_2.5-7 [87] permute_0.9-5 vctrs_0.3.8 [89] pillar_1.6.1 lifecycle_1.0.0 [91] BiocManager_1.30.16 jquerylib_0.1.4 [93] BiocNeighbors_1.11.0 data.table_1.14.0 [95] cowplot_1.1.1 bitops_1.0-7 [97] irlba_2.3.3 R6_2.5.0 [99] bookdown_0.22 gridExtra_2.3 [101] rio_0.5.27 vipor_0.4.5 [103] codetools_0.2-18 MASS_7.3-54 [105] assertthat_0.2.1 withr_2.4.2 [107] GenomeInfoDbData_1.2.6 mgcv_1.8-36 [109] parallel_4.1.0 hms_1.1.0 [111] grid_4.1.0 beachmat_2.9.0 [113] tidyr_1.1.3 rmarkdown_2.9 [115] DelayedMatrixStats_1.15.0 carData_3.0-4 [117] ggpubr_0.4.0 ggbeeswarm_0.6.0 .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } Bibliography "],["beta-diversity.html", "Chapter 7 Beta Diversity 7.1 Explained variance 7.2 Estimating beta diversity 7.3 Other ordination methods 7.4 Visualizing the most dominant genus on PCoA 7.5 Community comparisons [TODO combine with the material above for simplicity?] 7.6 Further reading Session Info", " Chapter 7 Beta Diversity Where alpha diversity focuses on community variation within a community (sample), beta diversity quantifies (dis-)similarites between communities (samples). Some of the most popular beta diversity measures in microbiome research include Bray-Curtis index (for compositional data), Jaccard index (for presence / absence data, ignoring abundance information), Aitchison distance (Euclidean distance for clr transformed abundances, aiming to avoid the compositionality bias), and the Unifrac distances (that take into account the phylogenetic tree information). Only some of the commonly used beta diversity measures are actual distances; this is a mathematically well-defined concept and many ecological beta diversity measures, such as Bray-Curtis index, are not proper distances. Therefore, the term dissimilarity or beta diversity is commonly used. Technically, beta diversities are usually represented as dist objects, which contain triangular data describing the distance between each pair of samples. These distances can be further subjected to ordination. Ordination is a common concept in ecology that aims to reduce the dimensionsionality of the data for further evaluation or visualization. Ordination techniques aim to capture as much of essential information in the data as possible in a lower dimensional representation. Dimension reduction is bound to loose information but the common ordination techniques aim to preserve relevant information of sample similarities in an optimal way, which is defined in different way by different methods. [TODO add references and/or link to ordination chapter instead?] Some of the most common ordination methods in microbiome research include Principal Component Analysis (PCA), metric and non-metric multi-dimensional scaling (MDS, NMDS), The MDS methods is also known as Principal Coordinates Analysis (PCoA). Other recently popular techniques include t-SNE and UMAP. 7.1 Explained variance The percentage of explained variance is typically shown for PCA ordination plots. This quantifies the proportion of overall variance in the data that is captured by the PCA axes, or how well the ordination axes reflect the original distances. Sometimes a similar measure is shown for MDS/PCoA. The interpretation is generally different, however, and hence we do not recommend using it. PCA is a special case of PCoA with Euclidean distances. With non-Euclidean dissimilarities PCoA uses a trick where the pointwise dissimilarities are first cast into similarities a Euclidean space (with some information loss i.e. stress) and then projected to the maximal variance axes. In this case, the maximal variance axes do not directly reflect the correspondence of the projected distances and original distances, as they do for PCA. In typical use cases, we would like to know how well the ordination reflects the original similarity structures; then the quantity of interest is the so-called “stress” function, which measures the difference in pairwise similarities between the data points in the original (high-dimensional) vs. projected (low-dimensional) space. Hence, we propose that for PCoA and other ordination methods, users would report relative stress (varies in the unit interval; the smaller the better). This can be calculated as shown below. For further examples, check the note from Huber lab. # Example data library(mia) data(GlobalPatterns) # Data matrix (features x samples) x &lt;- GlobalPatterns x &lt;- transformCounts(x, method = &quot;relabundance&quot;) x &lt;- assay(x, &quot;relabundance&quot;) # Quantify dissimilarities in the original feature space library(vegan) d0 &lt;- as.matrix(vegdist(t(x), &quot;bray&quot;)) # PCoA Ordination pcoa &lt;- as.data.frame(cmdscale(d0, k = 2)) names(pcoa) &lt;- c(&quot;PCoA1&quot;, &quot;PCoA2&quot;) # Quantify dissimilarities in the ordination space dp &lt;- as.matrix(dist(pcoa)) # Calculate stress i.e. relative difference in the original and # projected dissimilarities stress &lt;- sum((dp - d0)^2)/sum(d0^2) Shepard plot visualizes the original versus projected (ordination) dissimilarities between the data points: ord &lt;- order(as.vector(d0)) df &lt;- data.frame(d0 = as.vector(d0)[ord], dmds = as.vector(dp)[ord]) library(ggplot2) ggplot(aes(x = d0, y = dmds), data=df) + geom_smooth() + geom_point() + labs(title = &quot;Shepard plot&quot;, x = &quot;Original distance&quot;, y = &quot;MDS distance&quot;, subtitle = paste(&quot;Stress:&quot;, round(stress, 2))) + theme_bw() 7.2 Estimating beta diversity In the following examples dissimilarities are calculated by functions supplied to the FUN argument. This function can defined by the user. It must return a dist function, which can then be used to calculate reduced dimension either via ordination methods (such as MDS or NMDS), and the results can be stored in the reducedDim. This entire process is wrapped in the runMDS and runNMDS functions. library(scater) se &lt;- GlobalPatterns se &lt;- runMDS(se, FUN = vegan::vegdist, name = &quot;MDS_BC&quot;, exprs_values = &quot;counts&quot;) Sample similarities can be visualized on a lower-dimensional display (typically 2D) using the plotReducedDim function in the scaterpackage. This provides also further tools to incorporate additional information using variations in colour, shape or size. # Create ggplot object p &lt;- plotReducedDim(se, &quot;MDS_BC&quot;, colour_by = &quot;SampleType&quot;) # Add explained variance for each axis e &lt;- attr(reducedDim(se, &quot;MDS_BC&quot;), &quot;eig&quot;); rel_eig &lt;- e/sum(e[e&gt;0]) p &lt;- p + labs(x = paste(&quot;PCoA 1 (&quot;, round(100 * rel_eig[[1]],1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;), y = paste(&quot;PCoA 2 (&quot;, round(100 * rel_eig[[2]],1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;)) print(p) Figure 7.1: MDS plot based on the Bray-Curtis distances on the GlobalPattern dataset. With additional tools from the ggplot2 universe, comparisons can be performed informing on the applicability to visualize sample similarities in a meaningful way. se &lt;- runMDS(se, FUN = vegan::vegdist, name = &quot;MDS_euclidean&quot;, method = &quot;euclidean&quot;, exprs_values = &quot;counts&quot;) se &lt;- runNMDS(se, FUN = vegan::vegdist, name = &quot;NMDS_BC&quot;) ## initial value 47.733208 ## iter 5 value 33.853364 ## iter 10 value 32.891200 ## final value 32.823570 ## converged se &lt;- runNMDS(se, FUN = vegan::vegdist, name = &quot;NMDS_euclidean&quot;, method = &quot;euclidean&quot;) ## initial value 31.882673 ## final value 31.882673 ## converged plots &lt;- lapply(c(&quot;MDS_BC&quot;,&quot;MDS_euclidean&quot;,&quot;NMDS_BC&quot;,&quot;NMDS_euclidean&quot;), plotReducedDim, object = se, colour_by = &quot;SampleType&quot;) ggpubr::ggarrange(plotlist = plots, nrow = 2, ncol = 2, common.legend = TRUE, legend = &quot;right&quot;) Figure 7.2: Comparison of MDS and NMDS plots based on the Bray-Curtis or euclidean distances on the GlobalPattern dataset. The UniFrac method is a special case, as it requires data on the relationship of features in form on a phylo tree. calculateUniFrac performs the calculation to return a dist object, which can again be used within runMDS. se &lt;- runMDS(se, FUN = calculateUniFrac, name = &quot;UniFrac&quot;, tree = rowTree(se), ntop = nrow(se), exprs_values = &quot;counts&quot;) plotReducedDim(se, &quot;UniFrac&quot;, colour_by = &quot;SampleType&quot;) Figure 7.3: UniFrac distances scaled by MDS of the GlobalPattern dataset. 7.3 Other ordination methods Other dimension reduction methods, such as PCA, t-SNE and UMAP are inherited directly from the scater package. se &lt;- runPCA(se, name = &quot;PCA&quot;, exprs_values = &quot;counts&quot;, ncomponents = 10) plotReducedDim(se, &quot;PCA&quot;, colour_by = &quot;SampleType&quot;) Figure 7.4: PCA plot on the GlobalPatterns data set containing sample from different sources. As mentioned before, applicability of the different methods depends on your sample set. FIXME: let us switch to UMAP for the examples? se &lt;- runTSNE(se, name = &quot;TSNE&quot;, exprs_values = &quot;counts&quot;, ncomponents = 3) plotReducedDim(se, &quot;TSNE&quot;, colour_by = &quot;SampleType&quot;, ncomponents = c(1:3)) Figure 7.5: t-SNE plot on the GlobalPatterns data set containing sample from different sources. 7.4 Visualizing the most dominant genus on PCoA In this section we visualize most dominant genus in the alcohol study dataset from curatedMetagenomicData on PCoA. A similar visualization has been used in Taxonomic signatures of cause-specific mortality risk in human gut microbiome, Salosensaari et al. (2021). # Installing the package if (!require(curatedMetagenomicData)){ BiocManager::install(&quot;curatedMetagenomicData&quot;) } Retrieving data as a TreeSummarizedExperiment object. library(curatedMetagenomicData) library(dplyr) library(DT) # Querying the data tse &lt;- sampleMetadata %&gt;% filter(age &gt;= 18) %&gt;% # taking only data of age 18 or above filter(!is.na(alcohol)) %&gt;% # excluding missing values returnSamples(&quot;relative_abundance&quot;) tse ## class: TreeSummarizedExperiment ## dim: 1057 780 ## metadata(0): ## assays(1): relative_abundance ## rownames(1057): ## k__Bacteria|p__Actinobacteria|c__Actinobacteria|o__Propionibacteriales|f__Propionibacteriaceae|g__Cutibacterium|s__Cutibacterium_acnes ## k__Bacteria|p__Proteobacteria|c__Gammaproteobacteria|o__Enterobacterales|f__Enterobacteriaceae|g__Klebsiella|s__Klebsiella_pneumoniae ## ... ## k__Bacteria|p__Firmicutes|c__Clostridia|o__Clostridiales|f__Lachnospiraceae|g__Anaerostipes|s__Anaerostipes_sp_494a ## k__Bacteria|p__Bacteroidetes|c__Bacteroidia|o__Bacteroidales|f__Barnesiellaceae|g__Barnesiella|s__Barnesiella_viscericola ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(780): WBE003 WBE004 ... YSZC12003_37879 YSZC12003_37880 ## colData names(129): study_name subject_id ... ALT eGFR ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (1057 rows) ## rowTree: 1 phylo tree(s) (10430 leaves) ## colLinks: NULL ## colTree: NULL Agglomerating the data at a Genus level and getting the dominant taxa per sample. tse_Genus &lt;- agglomerateByRank(tse, rank=&quot;Genus&quot;) tse_Genus &lt;- addPerSampleDominantTaxa(tse_Genus,abund_values=&quot;relative_abundance&quot;, name = &quot;dominant_taxa&quot;) Performing PCoA with Bray-Curtis dissimilarity. tse_Genus &lt;- runMDS(tse_Genus, FUN = vegan::vegdist, name = &quot;PCoA_BC&quot;, exprs_values = &quot;relative_abundance&quot;) Getting top taxa and visualizing the abundance on PCoA. # Getting the 6 top taxa top_taxa &lt;- getTopTaxa(tse_Genus,top = 6, abund_values = &quot;relative_abundance&quot;) # Naming all the rest of non top-taxa as &quot;Other&quot; most_abundant &lt;- lapply(colData(tse_Genus)$dominant_taxa, function(x){if (x %in% top_taxa) {x} else {&quot;Other&quot;}}) # Storing the previous results as a new column within colData colData(tse_Genus)$most_abundant &lt;- as.character(most_abundant) # Calculating percentage of the most abundant most_abundant_freq &lt;- table(as.character(most_abundant)) most_abundant_percent &lt;- round(most_abundant_freq/sum(most_abundant_freq)*100, 1) # Retrieving the explained variance e &lt;- attr(reducedDim(tse_Genus, &quot;PCoA_BC&quot;), &quot;eig&quot;); var_explained &lt;- e/sum(e[e&gt;0])*100 # Visualization plot &lt;-plotReducedDim(tse_Genus,&quot;PCoA_BC&quot;, colour_by = &quot;most_abundant&quot;) + scale_colour_manual(values = c(&quot;black&quot;, &quot;blue&quot;, &quot;lightblue&quot;, &quot;darkgray&quot;, &quot;magenta&quot;, &quot;darkgreen&quot;, &quot;red&quot;), labels=paste0(names(most_abundant_percent),&quot;(&quot;,most_abundant_percent,&quot;%)&quot;))+ labs(x=paste(&quot;PC 1 (&quot;,round(var_explained[1],1),&quot;%)&quot;), y=paste(&quot;PC 2 (&quot;,round(var_explained[2],1),&quot;%)&quot;), color=&quot;&quot;) plot Note: A 3D interactive version of the earlier plot can be found from here. Similarly lets visualize and compare the alcohol sub-polulation. # Calculating the frequencies and percentages for both categories freq_yes &lt;- table(as.character(most_abundant[colData(tse_Genus)$alcohol==&quot;yes&quot;])) freq_no &lt;- table(as.character(most_abundant[colData(tse_Genus)$alcohol==&quot;no&quot;])) percent_yes &lt;- round(freq_yes/sum(freq_yes)*100, 1) percent_no &lt;- round(freq_no/sum(freq_no)*100, 1) # Visualization plotReducedDim(tse_Genus[,colData(tse_Genus)$alcohol==&quot;yes&quot;], &quot;PCoA_BC&quot;, colour_by = &quot;most_abundant&quot;) + scale_colour_manual(values = c(&quot;black&quot;, &quot;blue&quot;, &quot;lightblue&quot;, &quot;darkgray&quot;, &quot;magenta&quot;, &quot;darkgreen&quot;, &quot;red&quot;), labels=paste0(names(percent_yes),&quot;(&quot;,percent_yes,&quot;%)&quot;))+ labs(x=paste(&quot;PC 1 (&quot;,round(var_explained[1],1),&quot;%)&quot;), y=paste(&quot;PC 2 (&quot;,round(var_explained[2],1),&quot;%)&quot;), title = &quot;alcohol = yes&quot;, color=&quot;&quot;) plotReducedDim(tse_Genus[,colData(tse_Genus)$alcohol==&quot;no&quot;], &quot;PCoA_BC&quot;, colour_by = &quot;most_abundant&quot;) + scale_colour_manual(values = c(&quot;black&quot;, &quot;blue&quot;, &quot;lightblue&quot;, &quot;darkgray&quot;, &quot;magenta&quot;, &quot;darkgreen&quot;, &quot;red&quot;), labels=paste0(names(percent_no),&quot;(&quot;,percent_no,&quot;%)&quot;))+ labs(x=paste(&quot;PC 1 (&quot;,round(var_explained[1],1),&quot;%)&quot;), y=paste(&quot;PC 2 (&quot;,round(var_explained[2],1),&quot;%)&quot;), title = &quot;alcohol = no&quot;, color=&quot;&quot;) 7.5 Community comparisons [TODO combine with the material above for simplicity?] A typical comparison of community composition starts with a visual comparison of the groups on a 2D ordination. Let us load an example data set: library(microbiomeDataSets) se.lahti &lt;- LahtiMData() Then we estimate relative abundances and MDS ordination based on Bray-Curtis (BC) dissimilarity between the groups, and visualize the results. se.lahti &lt;- relAbundanceCounts(se.lahti) se.lahti &lt;- runNMDS(se.lahti, FUN = vegan::vegdist, name = &quot;BC&quot;, nmdsFUN = &quot;monoMDS&quot;, exprs_values = &quot;relabundance&quot;, keep_dist = TRUE) plotReducedDim(se.lahti, &quot;BC&quot;, colour_by = &quot;group&quot;) No clear difference between the groups can be visually observed. 7.5.1 Testing differences in community composition between sample groups The permutational analysis of variance (PERMANOVA) (Anderson 2001) is a widely used non-parametric multivariate method that can be used to estimate the actual statistical significance of differences in the observed community composition between two groups of samples. PERMANOVA evaluates the hypothesis that the centroids and dispersion of the community are equivalent between the compared groups. A small p-value indicates that the compared groups have, on average, a different community composition. This method is implemented in the vegan package (function adonis). library(vegan) permanova &lt;- vegan::adonis(t(assay(se.lahti,&quot;relabundance&quot;)) ~ group, data = colData(se.lahti), permutations = 9999) # P-value print(as.data.frame(permanova$aov.tab)[&quot;group&quot;, &quot;Pr(&gt;F)&quot;]) ## [1] 0.273 In this case, the community composition is not significantly different between the groups. Let us visualize the model coefficients for species that exhibit the largest differences between the groups. This gives some insights into how the groups tend to differ from each other in terms of community composition. coef &lt;- coefficients(permanova)[&quot;group1&quot;,] top.coef &lt;- sort(head(coef[rev(order(abs(coef)))],20)) ggplot(data.frame(x = top.coef, y = factor(names(top.coef), unique(names(top.coef)))), aes(x = x, y = y)) + geom_bar(stat=&quot;identity&quot;) + labs(x=&quot;&quot;,y=&quot;&quot;,title=&quot;Top Taxa&quot;) + theme_bw() In the above example, the largest differences between the two groups can be attributed to Bacteroides intestinalis (elevated in the first group) and Faecalibacterium prausnitzii (elevated in the second group), and many other co-varying species. 7.5.2 Checking the homogeneity condition It is important to note that the application of PERMANOVA assumes homogeneous group dispersions (variances). This can be tested with the PERMDISP2 method (Anderson 2006). anova(vegan::betadisper(attr(reducedDim(se.lahti,&quot;BC&quot;),&quot;dist&quot;), colData(se.lahti)$group)) ## Analysis of Variance Table ## ## Response: Distances ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Groups 1 0.000 0.00002 0 0.95 ## Residuals 42 0.158 0.00376 In our example, the groups have similar dispersion, and PERMANOVA is an appropriate choice for comparing community compositions. 7.6 Further reading In certain settings, beta diversities might be used to group samples without prior knowledge. For this we want to point to excellent resources on how to extract information from the clusters. See also community typing. Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] microbiomeDataSets_1.1.0 MultiAssayExperiment_1.19.3 [3] DT_0.18 dplyr_1.0.7 [5] curatedMetagenomicData_3.1.1 scater_1.21.2 [7] scuttle_1.3.0 ggplot2_3.3.5 [9] vegan_2.5-7 lattice_0.20-44 [11] permute_0.9-5 mia_1.1.7 [13] TreeSummarizedExperiment_2.1.3 Biostrings_2.61.1 [15] XVector_0.33.0 SingleCellExperiment_1.15.1 [17] SummarizedExperiment_1.23.1 Biobase_2.53.0 [19] GenomicRanges_1.45.0 GenomeInfoDb_1.29.3 [21] IRanges_2.27.0 S4Vectors_0.31.0 [23] BiocGenerics_0.39.1 MatrixGenerics_1.5.1 [25] matrixStats_0.59.0 BiocStyle_2.21.3 [27] rebook_1.3.0 loaded via a namespace (and not attached): [1] readxl_1.3.1 backports_1.2.1 [3] AnnotationHub_3.1.4 BiocFileCache_2.1.1 [5] plyr_1.8.6 lazyeval_0.2.2 [7] splines_4.1.0 BiocParallel_1.27.2 [9] digest_0.6.27 htmltools_0.5.1.1 [11] viridis_0.6.1 fansi_0.5.0 [13] magrittr_2.0.1 memoise_2.0.0 [15] ScaledMatrix_1.1.0 cluster_2.1.2 [17] DECIPHER_2.21.0 openxlsx_4.2.4 [19] colorspace_2.0-2 rappdirs_0.3.3 [21] blob_1.2.1 haven_2.4.1 [23] xfun_0.24 crayon_1.4.1 [25] RCurl_1.98-1.3 jsonlite_1.7.2 [27] graph_1.71.2 ape_5.5 [29] glue_1.4.2 gtable_0.3.0 [31] zlibbioc_1.39.0 DelayedArray_0.19.1 [33] car_3.0-11 BiocSingular_1.9.1 [35] abind_1.4-5 scales_1.1.1 [37] DBI_1.1.1 rstatix_0.7.0 [39] Rcpp_1.0.7 xtable_1.8-4 [41] viridisLite_0.4.0 decontam_1.13.0 [43] tidytree_0.3.4 foreign_0.8-81 [45] bit_4.0.4 rsvd_1.0.5 [47] htmlwidgets_1.5.3 httr_1.4.2 [49] dir.expiry_1.1.0 ellipsis_0.3.2 [51] pkgconfig_2.0.3 XML_3.99-0.6 [53] farver_2.1.0 dbplyr_2.1.1 [55] CodeDepends_0.6.5 sass_0.4.0 [57] utf8_1.2.1 AnnotationDbi_1.55.1 [59] later_1.2.0 tidyselect_1.1.1 [61] labeling_0.4.2 rlang_0.4.11 [63] reshape2_1.4.4 BiocVersion_3.14.0 [65] cellranger_1.1.0 munsell_0.5.0 [67] tools_4.1.0 cachem_1.0.5 [69] ExperimentHub_2.1.3 DirichletMultinomial_1.35.0 [71] generics_0.1.0 RSQLite_2.2.7 [73] broom_0.7.8 evaluate_0.14 [75] stringr_1.4.0 fastmap_1.1.0 [77] yaml_2.2.1 knitr_1.33 [79] bit64_4.0.5 zip_2.2.0 [81] purrr_0.3.4 KEGGREST_1.33.0 [83] nlme_3.1-152 sparseMatrixStats_1.5.0 [85] mime_0.11 compiler_4.1.0 [87] png_0.1-7 interactiveDisplayBase_1.31.0 [89] beeswarm_0.4.0 filelock_1.0.2 [91] curl_4.3.2 ggsignif_0.6.2 [93] treeio_1.17.2 tibble_3.1.2 [95] bslib_0.2.5.1 stringi_1.7.3 [97] highr_0.9 forcats_0.5.1 [99] Matrix_1.3-4 vctrs_0.3.8 [101] pillar_1.6.1 lifecycle_1.0.0 [103] BiocManager_1.30.16 jquerylib_0.1.4 [105] BiocNeighbors_1.11.0 data.table_1.14.0 [107] cowplot_1.1.1 bitops_1.0-7 [109] irlba_2.3.3 httpuv_1.6.1 [111] R6_2.5.0 promises_1.2.0.1 [113] bookdown_0.22 gridExtra_2.3 [115] rio_0.5.27 vipor_0.4.5 [117] codetools_0.2-18 MASS_7.3-54 [119] assertthat_0.2.1 withr_2.4.2 [121] GenomeInfoDbData_1.2.6 mgcv_1.8-36 [123] parallel_4.1.0 hms_1.1.0 [125] grid_4.1.0 beachmat_2.9.0 [127] tidyr_1.1.3 rmarkdown_2.9 [129] DelayedMatrixStats_1.15.0 carData_3.0-4 [131] Rtsne_0.15 ggpubr_0.4.0 [133] shiny_1.6.0 ggbeeswarm_0.6.0 Bibliography "],["microbiome-community.html", "Chapter 8 Microbiome Community 8.1 Community composition 8.2 Community typing Session Info", " Chapter 8 Microbiome Community .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } ## Loading required package: ecodist library(mia) data(&quot;GlobalPatterns&quot;) tse &lt;- GlobalPatterns 8.1 Community composition 8.1.1 Composition barplot A typical way to visualize microbiome composition is by using composition barplot. In the following, relative abundance is calculated and top 5 taxa is retrieved for the Phylum rank. Thereafter, the barplot is visualized ordering rank by abundance values and samples by “Bacteroidetes”: library(miaViz) # Computing relative abundance tse &lt;- relAbundanceCounts(tse) # Getting top taxa on a Phylum level tse_phylum &lt;- agglomerateByRank(tse, rank =&quot;Phylum&quot;, onRankOnly=TRUE) top_taxa &lt;- getTopTaxa(tse_phylum,top = 5, abund_values = &quot;relabundance&quot;) # Renaming the &quot;Phylum&quot; rank to keep only top taxa and the rest to &quot;Other&quot; phylum_renamed &lt;- lapply(rowData(tse)$Phylum, function(x){if (x %in% top_taxa) {x} else {&quot;Other&quot;}}) rowData(tse)$Phylum &lt;- as.character(phylum_renamed) # Visualizing the composition barplot, with samples order by &quot;Bacteroidetes&quot; plotAbundance(tse, abund_values=&quot;relabundance&quot;, rank = &quot;Phylum&quot;, order_rank_by=&quot;abund&quot;, order_sample_by = &quot;Bacteroidetes&quot;) 8.1.2 Composition heatmap Community composition can be visualized with heatmap where other axis represent samples and another taxa. Color of each intersection point represent abundance of a taxon in a specific sample. Here, Z-transformed abundances are plotted at Phylum level. library(ggplot2) # Does z-transformation tse_phylum &lt;- transformFeatures(tse_phylum, method = &quot;z&quot;, name = &quot;Ztransform&quot;) # Melts the assay df &lt;- meltAssay(tse_phylum, assay_name = &quot;Ztransform&quot;) # Creates a ggplot object ggplot(df, aes(x = SampleID, y = FeatureID, fill = Ztransform)) + geom_tile() + scale_fill_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) + theme(text = element_text(size=10), axis.text.x = element_text(angle=45, hjust=1)) + labs(x = &quot;Samples&quot;, y = &quot;Taxa&quot;) 8.2 Community typing 8.2.1 Dirichlet Multinomial Mixtures (DMM) This section focus on DMM analysis. One technique that allows to search for groups of samples that are similar to each other is the Dirichlet-Multinomial Mixture Model. In DMM, we first determine the number of clusters (k) that best fit the data (model evidence) using Laplace approximation. After fitting the model with k clusters, we obtain for each sample k probabilities that reflect the probability that a sample belongs to the given cluster. Let’s cluster the data with DMM clustering. # Runs model and calculates the most likely number of clusters from 1 to 7. # Since this is a large dataset it takes long computational time. # For this reason we use only a subset of the data; agglomerated by Phylum as a rank. tse &lt;- GlobalPatterns tse &lt;- agglomerateByRank(tse, rank = &quot;Phylum&quot;, agglomerateTree=TRUE) tse_dmn &lt;- runDMN(tse, name = &quot;DMN&quot;, k = 1:7) # It is stored in metadata tse_dmn ## class: TreeSummarizedExperiment ## dim: 67 26 ## metadata(1): DMN ## assays(1): counts ## rownames(67): Phylum:Crenarchaeota Phylum:Euryarchaeota ... ## Phylum:Synergistetes Phylum:SR1 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (67 rows) ## rowTree: 1 phylo tree(s) (66 leaves) ## colLinks: NULL ## colTree: NULL Return information on metadata that the object contains. names(metadata(tse_dmn)) ## [1] &quot;DMN&quot; This returns a list of DMN objects for a closer investigation. getDMN(tse_dmn) ## [[1]] ## class: DMN ## k: 1 ## samples x taxa: 26 x 67 ## Laplace: 7715 BIC: 7802 AIC: 7760 ## ## [[2]] ## class: DMN ## k: 2 ## samples x taxa: 26 x 67 ## Laplace: 7673 BIC: 7927 AIC: 7842 ## ## [[3]] ## class: DMN ## k: 3 ## samples x taxa: 26 x 67 ## Laplace: 7690 BIC: 8076 AIC: 7948 ## ## [[4]] ## class: DMN ## k: 4 ## samples x taxa: 26 x 67 ## Laplace: 7751 BIC: 8274 AIC: 8103 ## ## [[5]] ## class: DMN ## k: 5 ## samples x taxa: 26 x 67 ## Laplace: 7854 BIC: 8553 AIC: 8340 ## ## [[6]] ## class: DMN ## k: 6 ## samples x taxa: 26 x 67 ## Laplace: 7952 BIC: 8850 AIC: 8594 ## ## [[7]] ## class: DMN ## k: 7 ## samples x taxa: 26 x 67 ## Laplace: 8011 BIC: 9035 AIC: 8736 Show Laplace approximation (model evidence) for each model of the k models. library(miaViz) plotDMNFit(tse_dmn, type = &quot;laplace&quot;) Return the model that has the best fit. getBestDMNFit(tse_dmn, type = &quot;laplace&quot;) ## class: DMN ## k: 2 ## samples x taxa: 26 x 67 ## Laplace: 7673 BIC: 7927 AIC: 7842 8.2.2 PCoA for ASV-level data with Bray-Curtis; with DMM clusters shown with colors Group samples and return DMNGroup object that contains a summary. Patient status is used for grouping. dmn_group &lt;- calculateDMNgroup(tse_dmn, variable = &quot;SampleType&quot;, exprs_values = &quot;counts&quot;, k = 2, seed=.Machine$integer.max) dmn_group ## class: DMNGroup ## summary: ## k samples taxa NLE LogDet Laplace BIC AIC ## Feces 2 4 67 1078.3 -106.19 901.1 1171.9 1213 ## Freshwater 2 2 67 889.6 -97.28 716.9 936.4 1025 ## Freshwater (creek) 2 3 67 1600.3 860.08 1906.3 1674.5 1735 ## Mock 2 3 67 1008.4 -55.37 856.6 1082.5 1143 ## Ocean 2 3 67 1096.7 -56.21 944.6 1170.9 1232 ## Sediment (estuary) 2 3 67 1195.5 18.63 1080.8 1269.7 1331 ## Skin 2 3 67 992.6 -84.81 826.2 1066.8 1128 ## Soil 2 3 67 1380.3 11.21 1261.8 1454.5 1515 ## Tongue 2 2 67 783.0 -107.74 605.1 829.8 918 Mixture weights (rough measure of the cluster size). DirichletMultinomial::mixturewt(getBestDMNFit(tse_dmn)) ## pi theta ## 1 0.5385 20.58 ## 2 0.4615 15.29 Samples-cluster assignment probabilities / how probable it is that sample belongs to each cluster head(DirichletMultinomial::mixture(getBestDMNFit(tse_dmn))) ## [,1] [,2] ## CL3 1.000e+00 5.041e-17 ## CC1 1.000e+00 3.887e-22 ## SV1 1.000e+00 1.939e-12 ## M31Fcsw 7.866e-26 1.000e+00 ## M11Fcsw 1.137e-16 1.000e+00 ## M31Plmr 1.118e-13 1.000e+00 Contribution of each taxa to each component head(DirichletMultinomial::fitted(getBestDMNFit(tse_dmn))) ## [,1] [,2] ## Phylum:Crenarchaeota 0.30380 0.1354611 ## Phylum:Euryarchaeota 0.23113 0.1468692 ## Phylum:Actinobacteria 1.21355 1.0604577 ## Phylum:Spirochaetes 0.21392 0.1318400 ## Phylum:MVP-15 0.02982 0.0007674 ## Phylum:Proteobacteria 6.84505 1.8150154 Get the assignment probabilities prob &lt;- DirichletMultinomial::mixture(getBestDMNFit(tse_dmn)) # Add column names colnames(prob) &lt;- c(&quot;comp1&quot;, &quot;comp2&quot;) # For each row, finds column that has the highest value. Then extract the column # names of highest values. vec &lt;- colnames(prob)[max.col(prob,ties.method = &quot;first&quot;)] Computing the euclidean PCoA and storing it as a dataframe # Does clr transformation. Pseudocount is added, because data contains zeros. tse &lt;- transformCounts(tse, method = &quot;clr&quot;, pseudocount = 1) # Gets clr table clr_assay &lt;- assays(tse)$clr # Transposes it to get taxa to columns clr_assay &lt;- t(clr_assay) # Calculates Euclidean distances between samples. Because taxa is in columns, # it is used to compare different samples. euclidean_dist &lt;- vegan::vegdist(clr_assay, method = &quot;euclidean&quot;) # Does principal coordinate analysis euclidean_pcoa &lt;- ecodist::pco(euclidean_dist) # Creates a data frame from principal coordinates euclidean_pcoa_df &lt;- data.frame(pcoa1 = euclidean_pcoa$vectors[,1], pcoa2 = euclidean_pcoa$vectors[,2]) # Creates a data frame that contains principal coordinates and DMM information euclidean_dmm_pcoa_df &lt;- cbind(euclidean_pcoa_df, dmm_component = vec) # Creates a plot euclidean_dmm_plot &lt;- ggplot(data = euclidean_dmm_pcoa_df, aes(x=pcoa1, y=pcoa2, color = dmm_component)) + geom_point() + labs(x = &quot;Coordinate 1&quot;, y = &quot;Coordinate 2&quot;, title = &quot;PCoA with Aitchison distances&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_dmm_plot Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] miaViz_1.1.2 ggraph_2.0.5 [3] ggplot2_3.3.5 mia_1.1.7 [5] TreeSummarizedExperiment_2.1.3 Biostrings_2.61.1 [7] XVector_0.33.0 SingleCellExperiment_1.15.1 [9] SummarizedExperiment_1.23.1 Biobase_2.53.0 [11] GenomicRanges_1.45.0 GenomeInfoDb_1.29.3 [13] IRanges_2.27.0 S4Vectors_0.31.0 [15] BiocGenerics_0.39.1 MatrixGenerics_1.5.1 [17] matrixStats_0.59.0 ecodist_2.0.7 [19] BiocStyle_2.21.3 rebook_1.3.0 loaded via a namespace (and not attached): [1] ggtree_3.1.2 ggnewscale_0.4.5 [3] ggbeeswarm_0.6.0 colorspace_2.0-2 [5] ellipsis_0.3.2 scuttle_1.3.0 [7] BiocNeighbors_1.11.0 aplot_0.0.6 [9] farver_2.1.0 graphlayouts_0.7.1 [11] ggrepel_0.9.1 bit64_4.0.5 [13] fansi_0.5.0 decontam_1.13.0 [15] splines_4.1.0 codetools_0.2-18 [17] sparseMatrixStats_1.5.0 cachem_1.0.5 [19] knitr_1.33 scater_1.21.2 [21] polyclip_1.10-0 jsonlite_1.7.2 [23] cluster_2.1.2 graph_1.71.2 [25] ggforce_0.3.3 BiocManager_1.30.16 [27] compiler_4.1.0 rvcheck_0.1.8 [29] assertthat_0.2.1 Matrix_1.3-4 [31] fastmap_1.1.0 lazyeval_0.2.2 [33] tweenr_1.0.2 BiocSingular_1.9.1 [35] htmltools_0.5.1.1 tools_4.1.0 [37] igraph_1.2.6 rsvd_1.0.5 [39] gtable_0.3.0 glue_1.4.2 [41] GenomeInfoDbData_1.2.6 reshape2_1.4.4 [43] dplyr_1.0.7 Rcpp_1.0.7 [45] jquerylib_0.1.4 vctrs_0.3.8 [47] ape_5.5 nlme_3.1-152 [49] DECIPHER_2.21.0 DelayedMatrixStats_1.15.0 [51] xfun_0.24 stringr_1.4.0 [53] beachmat_2.9.0 lifecycle_1.0.0 [55] irlba_2.3.3 XML_3.99-0.6 [57] zlibbioc_1.39.0 MASS_7.3-54 [59] scales_1.1.1 tidygraph_1.2.0 [61] parallel_4.1.0 yaml_2.2.1 [63] memoise_2.0.0 gridExtra_2.3 [65] sass_0.4.0 stringi_1.7.3 [67] RSQLite_2.2.7 highr_0.9 [69] ScaledMatrix_1.1.0 permute_0.9-5 [71] tidytree_0.3.4 filelock_1.0.2 [73] BiocParallel_1.27.2 rlang_0.4.11 [75] pkgconfig_2.0.3 bitops_1.0-7 [77] evaluate_0.14 lattice_0.20-44 [79] purrr_0.3.4 labeling_0.4.2 [81] patchwork_1.1.1 treeio_1.17.2 [83] CodeDepends_0.6.5 bit_4.0.4 [85] tidyselect_1.1.1 plyr_1.8.6 [87] magrittr_2.0.1 bookdown_0.22 [89] R6_2.5.0 generics_0.1.0 [91] DelayedArray_0.19.1 DBI_1.1.1 [93] withr_2.4.2 mgcv_1.8-36 [95] pillar_1.6.1 RCurl_1.98-1.3 [97] tibble_3.1.2 dir.expiry_1.1.0 [99] crayon_1.4.1 utf8_1.2.1 [101] rmarkdown_2.9 viridis_0.6.1 [103] grid_4.1.0 blob_1.2.1 [105] vegan_2.5-7 digest_0.6.27 [107] tidyr_1.1.3 munsell_0.5.0 [109] DirichletMultinomial_1.35.0 beeswarm_0.4.0 [111] viridisLite_0.4.0 vipor_0.4.5 [113] bslib_0.2.5.1 "],["differential-abundance.html", "Chapter 9 Differential Abundance Session Info", " Chapter 9 Differential Abundance .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } A number of methods for differential abundance analysis are available, and reviewed elsewhere. Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] BiocStyle_2.21.3 rebook_1.3.0 loaded via a namespace (and not attached): [1] graph_1.71.2 knitr_1.33 magrittr_2.0.1 [4] BiocGenerics_0.39.1 R6_2.5.0 rlang_0.4.11 [7] stringr_1.4.0 tools_4.1.0 xfun_0.24 [10] jquerylib_0.1.4 htmltools_0.5.1.1 CodeDepends_0.6.5 [13] yaml_2.2.1 digest_0.6.27 bookdown_0.22 [16] dir.expiry_1.1.0 BiocManager_1.30.16 codetools_0.2-18 [19] sass_0.4.0 evaluate_0.14 rmarkdown_2.9 [22] stringi_1.7.3 compiler_4.1.0 bslib_0.2.5.1 [25] filelock_1.0.2 stats4_4.1.0 XML_3.99-0.6 [28] jsonlite_1.7.2 "],["microbiome-timeseries.html", "Chapter 10 Microbiome Time Series 10.1 Stability 10.2 Tipping elements Session Info", " Chapter 10 Microbiome Time Series .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } This chapter focuses on the exploration of microbiome time series. 10.1 Stability 10.2 Tipping elements Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] BiocStyle_2.21.3 rebook_1.3.0 loaded via a namespace (and not attached): [1] graph_1.71.2 knitr_1.33 magrittr_2.0.1 [4] BiocGenerics_0.39.1 R6_2.5.0 rlang_0.4.11 [7] stringr_1.4.0 tools_4.1.0 xfun_0.24 [10] jquerylib_0.1.4 htmltools_0.5.1.1 CodeDepends_0.6.5 [13] yaml_2.2.1 digest_0.6.27 bookdown_0.22 [16] dir.expiry_1.1.0 BiocManager_1.30.16 codetools_0.2-18 [19] sass_0.4.0 evaluate_0.14 rmarkdown_2.9 [22] stringi_1.7.3 compiler_4.1.0 bslib_0.2.5.1 [25] filelock_1.0.2 stats4_4.1.0 XML_3.99-0.6 [28] jsonlite_1.7.2 "],["multitable.html", "Chapter 11 Representation of Multiple Data Tables 11.1 Assay data 11.2 Alternative experiments 11.3 MultiAssayExperiments Session Info", " Chapter 11 Representation of Multiple Data Tables .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } Microbiome data can be part of multiomics experiments and analysis strategies and we want to outline the understanding in which we think the packages explained and used in this book relate to these experiment layouts using the TreeSummarizedExperiment and classes beyond. Many microbiome experiments include multiple versions and types of data generated independently or derived from each other through transformation or agglomeration. We start by providing recommendations on how to represent different varieties of multi-table data within the TreeSummarizedExperiment class. The options and recommendations are summarized in Table 11.1. 11.1 Assay data The original count-based taxonomic abundance tables may have different transformations, such as logarithmic, Centered Log-Ratio (CLR), or relative abundance. These are typically stored in assays. library(mia) data(GlobalPatterns) se &lt;- GlobalPatterns assays(se) ## List of length 1 ## names(1): counts As an example the relative abundance is calculated. se &lt;- relAbundanceCounts(se) assays(se) ## List of length 2 ## names(2): counts relabundance Here the dimension of the count data remains unchanged. This is actually a requirement for any SummarizedExperiment object. 11.2 Alternative experiments Alternative experiments differ from transformations as they can contain complementary data, which is no longer tied to the same dimensions as the assay data. However, the number of samples (columns) must be the same, however. This can come into play for instance when one has taxonomic abundance profiles quantified with different measurement technologies, such as phylogenetic microarrays, amplicon sequencing, or metagenomic sequencing. Such alternative experiments that concern the same samples can be stored as Separate assays assuming that the taxonomic information can be mapped between feature directly 1:1; or data in the altExp slot of the TreeSummarizedExperiment, if the feature dimensions differ. Each element of the altExp slot is a SummarizedExperiment or an object from a derived class with independent feature data. As an example, we show how to store taxonomic abundance tables agglomerated at different taxonomic levels. However, the data could as well originate from entirely different measurement sources as long as the samples are matched. # Agglomerate the data to Phylym level se.phylum &lt;- agglomerateByRank(se, &quot;Phylum&quot;) # both have the same number of columns (samples) dim(se) ## [1] 19216 26 dim(se.phylum) ## [1] 67 26 # Add the new table as an alternative experiment altExp(se, &quot;Phylum&quot;) &lt;- se.phylum altExpNames(se) ## [1] &quot;Phylum&quot; # Pick a sample subset: this acts on both altExp and assay data se[,1:10] ## class: TreeSummarizedExperiment ## dim: 19216 10 ## metadata(0): ## assays(2): counts relabundance ## rownames(19216): 549322 522457 ... 200359 271582 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(10): CL3 CC1 ... M31Tong M11Tong ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(1): Phylum ## rowLinks: a LinkDataFrame (19216 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL dim(altExp(se[,1:10],&quot;Phylum&quot;)) ## [1] 67 10 For more details of altExp have a look at the Intro vignette of the SingleCellExperiment package (Lun and Risso 2020). 11.3 MultiAssayExperiments Multiple experiments relate to complementary measurement types, such as transcriptomic or metabolomic profiling of the microbiome or the host. Multiple experiments can be represented using the same options as alternative experiments, or by using the MultiAssayExperiment class (Ramos and Waldron 2020). Depending on how the datasets relate to each other the data can be stored as: Separate altExp if the samples can be matched directly 1:1; or As MultiAssayExperiment objects, in which the connections between sample are defined through a sampleMap. Each element on the experimentsList of an MultiAssayExperiment is matrix or matrix-like object including SummarizedExperiment objects, and the number of samples can differ between the elements. #TODO: Find the right dataset to explain a non 1:1 sample relationship For information have a look at the intro vignette of the MultiAssayExperiment package. Table 11.1: Recommended options for storing multiple data tables in microbiome studies The assays are best suited for data transformations (one-to-one match between samples and columns across the assays). The alternative experiments are particularly suitable for alternative versions of the data that is of same type but may have a different number of features (e.g. taxonomic groups); this is for instance the case with taxonomic abundance tables agglomerated at different levels (e.g. genus vs. phyla) or alternative profiling technologies (e.g. amplicon sequencing vs. shallow shotgun metagenomics). For alternative experiments one-to-one match between samples (cols) is required but the alternative experiment tables can have different numbers of features (rows). Finally, elements of the MultiAssayExperiment provide the most flexible way to incorporate multi-omic data tables with flexible numbers of samples and features. We recommend these conventions as the basis for methods development and application in microbiome studies. Option Rows (features) Cols (samples) Recommended assays match match Data transformations altExp free match Alternative experiments MultiAssay free free (mapping) Multi-omic experiments Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] mia_1.1.7 TreeSummarizedExperiment_2.1.3 [3] Biostrings_2.61.1 XVector_0.33.0 [5] SingleCellExperiment_1.15.1 SummarizedExperiment_1.23.1 [7] Biobase_2.53.0 GenomicRanges_1.45.0 [9] GenomeInfoDb_1.29.3 IRanges_2.27.0 [11] S4Vectors_0.31.0 BiocGenerics_0.39.1 [13] MatrixGenerics_1.5.1 matrixStats_0.59.0 [15] BiocStyle_2.21.3 rebook_1.3.0 loaded via a namespace (and not attached): [1] ggbeeswarm_0.6.0 colorspace_2.0-2 [3] ellipsis_0.3.2 scuttle_1.3.0 [5] BiocNeighbors_1.11.0 bit64_4.0.5 [7] fansi_0.5.0 decontam_1.13.0 [9] splines_4.1.0 codetools_0.2-18 [11] sparseMatrixStats_1.5.0 cachem_1.0.5 [13] knitr_1.33 scater_1.21.2 [15] jsonlite_1.7.2 cluster_2.1.2 [17] graph_1.71.2 BiocManager_1.30.16 [19] compiler_4.1.0 assertthat_0.2.1 [21] Matrix_1.3-4 fastmap_1.1.0 [23] lazyeval_0.2.2 BiocSingular_1.9.1 [25] htmltools_0.5.1.1 tools_4.1.0 [27] rsvd_1.0.5 gtable_0.3.0 [29] glue_1.4.2 GenomeInfoDbData_1.2.6 [31] reshape2_1.4.4 dplyr_1.0.7 [33] Rcpp_1.0.7 jquerylib_0.1.4 [35] vctrs_0.3.8 ape_5.5 [37] nlme_3.1-152 DECIPHER_2.21.0 [39] DelayedMatrixStats_1.15.0 xfun_0.24 [41] stringr_1.4.0 beachmat_2.9.0 [43] lifecycle_1.0.0 irlba_2.3.3 [45] XML_3.99-0.6 zlibbioc_1.39.0 [47] MASS_7.3-54 scales_1.1.1 [49] parallel_4.1.0 yaml_2.2.1 [51] memoise_2.0.0 gridExtra_2.3 [53] ggplot2_3.3.5 sass_0.4.0 [55] stringi_1.7.3 RSQLite_2.2.7 [57] ScaledMatrix_1.1.0 tidytree_0.3.4 [59] permute_0.9-5 filelock_1.0.2 [61] BiocParallel_1.27.2 rlang_0.4.11 [63] pkgconfig_2.0.3 bitops_1.0-7 [65] evaluate_0.14 lattice_0.20-44 [67] purrr_0.3.4 treeio_1.17.2 [69] CodeDepends_0.6.5 bit_4.0.4 [71] tidyselect_1.1.1 plyr_1.8.6 [73] magrittr_2.0.1 bookdown_0.22 [75] R6_2.5.0 generics_0.1.0 [77] DelayedArray_0.19.1 DBI_1.1.1 [79] mgcv_1.8-36 pillar_1.6.1 [81] RCurl_1.98-1.3 tibble_3.1.2 [83] dir.expiry_1.1.0 crayon_1.4.1 [85] utf8_1.2.1 rmarkdown_2.9 [87] viridis_0.6.1 grid_4.1.0 [89] blob_1.2.1 vegan_2.5-7 [91] digest_0.6.27 tidyr_1.1.3 [93] munsell_0.5.0 DirichletMultinomial_1.35.0 [95] beeswarm_0.4.0 viridisLite_0.4.0 [97] vipor_0.4.5 bslib_0.2.5.1 Bibliography "],["example-data.html", "Chapter 12 Example Data 12.1 Package data Session Info", " Chapter 12 Example Data .rebook-collapse { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; } .rebook-content { padding: 0 18px; display: none; overflow: hidden; background-color: #f1f1f1; } 12.1 Package data The datasets in mia are conversions of the phyloseq datasets GlobalPatterns enterotype, esophagus and soilrep. 12.1.1 GlobalPatterns library(mia) # Example how to load data data(&quot;GlobalPatterns&quot;) GlobalPatterns ## class: TreeSummarizedExperiment ## dim: 19216 26 ## metadata(0): ## assays(1): counts ## rownames(19216): 549322 522457 ... 200359 271582 ## rowData names(7): Kingdom Phylum ... Genus Species ## colnames(26): CL3 CC1 ... Even2 Even3 ## colData names(7): X.SampleID Primer ... SampleType Description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (19216 rows) ## rowTree: 1 phylo tree(s) (19216 leaves) ## colLinks: NULL ## colTree: NULL 12.1.2 Enterotype 12.1.3 Esophagus 12.1.4 Soilrep Session Info View session info R version 4.1.0 (2021-05-18) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 20.04.2 LTS Matrix products: default BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so locale: [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats4 stats graphics grDevices utils datasets methods [8] base other attached packages: [1] mia_1.1.7 TreeSummarizedExperiment_2.1.3 [3] Biostrings_2.61.1 XVector_0.33.0 [5] SingleCellExperiment_1.15.1 SummarizedExperiment_1.23.1 [7] Biobase_2.53.0 GenomicRanges_1.45.0 [9] GenomeInfoDb_1.29.3 IRanges_2.27.0 [11] S4Vectors_0.31.0 BiocGenerics_0.39.1 [13] MatrixGenerics_1.5.1 matrixStats_0.59.0 [15] BiocStyle_2.21.3 rebook_1.3.0 loaded via a namespace (and not attached): [1] ggbeeswarm_0.6.0 colorspace_2.0-2 [3] ellipsis_0.3.2 scuttle_1.3.0 [5] BiocNeighbors_1.11.0 bit64_4.0.5 [7] fansi_0.5.0 decontam_1.13.0 [9] splines_4.1.0 codetools_0.2-18 [11] sparseMatrixStats_1.5.0 cachem_1.0.5 [13] knitr_1.33 scater_1.21.2 [15] jsonlite_1.7.2 cluster_2.1.2 [17] graph_1.71.2 BiocManager_1.30.16 [19] compiler_4.1.0 assertthat_0.2.1 [21] Matrix_1.3-4 fastmap_1.1.0 [23] lazyeval_0.2.2 BiocSingular_1.9.1 [25] htmltools_0.5.1.1 tools_4.1.0 [27] rsvd_1.0.5 gtable_0.3.0 [29] glue_1.4.2 GenomeInfoDbData_1.2.6 [31] reshape2_1.4.4 dplyr_1.0.7 [33] Rcpp_1.0.7 jquerylib_0.1.4 [35] vctrs_0.3.8 ape_5.5 [37] nlme_3.1-152 DECIPHER_2.21.0 [39] DelayedMatrixStats_1.15.0 xfun_0.24 [41] stringr_1.4.0 beachmat_2.9.0 [43] lifecycle_1.0.0 irlba_2.3.3 [45] XML_3.99-0.6 zlibbioc_1.39.0 [47] MASS_7.3-54 scales_1.1.1 [49] parallel_4.1.0 yaml_2.2.1 [51] memoise_2.0.0 gridExtra_2.3 [53] ggplot2_3.3.5 sass_0.4.0 [55] stringi_1.7.3 RSQLite_2.2.7 [57] ScaledMatrix_1.1.0 tidytree_0.3.4 [59] permute_0.9-5 filelock_1.0.2 [61] BiocParallel_1.27.2 rlang_0.4.11 [63] pkgconfig_2.0.3 bitops_1.0-7 [65] evaluate_0.14 lattice_0.20-44 [67] purrr_0.3.4 treeio_1.17.2 [69] CodeDepends_0.6.5 bit_4.0.4 [71] tidyselect_1.1.1 plyr_1.8.6 [73] magrittr_2.0.1 bookdown_0.22 [75] R6_2.5.0 generics_0.1.0 [77] DelayedArray_0.19.1 DBI_1.1.1 [79] mgcv_1.8-36 pillar_1.6.1 [81] RCurl_1.98-1.3 tibble_3.1.2 [83] dir.expiry_1.1.0 crayon_1.4.1 [85] utf8_1.2.1 rmarkdown_2.9 [87] viridis_0.6.1 grid_4.1.0 [89] blob_1.2.1 vegan_2.5-7 [91] digest_0.6.27 tidyr_1.1.3 [93] munsell_0.5.0 DirichletMultinomial_1.35.0 [95] beeswarm_0.4.0 viridisLite_0.4.0 [97] vipor_0.4.5 bslib_0.2.5.1 "],["function-ref.html", "Chapter 13 Function Reference 13.1 Objects 13.2 Reduced dimension (PCA, t-SNE, UMAP, MDS, etc) 13.3 Plotting", " Chapter 13 Function Reference 13.1 Objects Function name package man page link SingleCellExperiment SingleCellExperiment ?SingleCellExperiment BioC TreeSummarizedExperiment TreeSummarizedExperiment ?TreeSummarizedExperiment BioC 13.2 Reduced dimension (PCA, t-SNE, UMAP, MDS, etc) Function name package man page link reducedDim SingleCellExperiment ?reducedDims BioC reducedDims SingleCellExperiment ?reducedDims BioC plotReducedDim scater ?plotReducedDim BioC 13.3 Plotting Function name package man page link plotColData scater ?plotColData BioC plotRowData scater ?plotRowData BioC plotExpression scater ?plotExpression BioC plotReducedDim scater ?plotReducedDim BioC plotRowTree miaViz ?plotTree GitHub plotColTree miaViz ?plotTree GitHub plotRowGraph miaViz ?plotGraph GitHub plotColGraph miaViz ?plotGraph GitHub plotAbundance miaViz ?plotAbundance GitHub plotPrevalence miaViz ?plotPrevalence GitHub plotSeries miaViz ?plotSeries GitHub # Installing required packages if (!require(rgl)){ BiocManager::install(&quot;rgl&quot;) } if (!require(plotly)){ BiocManager::install(&quot;plotly&quot;) } library(knitr) library(rgl) knitr::knit_hooks$set(webgl = hook_webgl) "],["interactive-3d-plots.html", "Interactive 3D Plots", " Interactive 3D Plots In this section we make a 3D version of the earlier Visualizing the most dominant genus on PCoA, with the help of the plotly R package. # Installing the package if (!require(curatedMetagenomicData)){ BiocManager::install(&quot;curatedMetagenomicData&quot;) } # Importing necessary libraries library(curatedMetagenomicData) library(dplyr) library(DT) library(mia) library(scater) # Querying the data tse &lt;- sampleMetadata %&gt;% filter(age &gt;= 18) %&gt;% # taking only data of age 18 or above filter(!is.na(alcohol)) %&gt;% # excluding missing values returnSamples(&quot;relative_abundance&quot;) tse_Genus &lt;- agglomerateByRank(tse, rank=&quot;Genus&quot;) tse_Genus &lt;- addPerSampleDominantTaxa(tse_Genus,abund_values=&quot;relative_abundance&quot;, name = &quot;dominant_taxa&quot;) # Performing PCoA with Bray-Curtis dissimilarity. tse_Genus &lt;- runMDS(tse_Genus, FUN = vegan::vegdist, ncomponents = 3, name = &quot;PCoA_BC&quot;, exprs_values = &quot;relative_abundance&quot;) # Getting the 6 top taxa top_taxa &lt;- getTopTaxa(tse_Genus,top = 6, abund_values = &quot;relative_abundance&quot;) # Naming all the rest of non top-taxa as &quot;Other&quot; most_abundant &lt;- lapply(colData(tse_Genus)$dominant_taxa, function(x){if (x %in% top_taxa) {x} else {&quot;Other&quot;}}) # Storing the previous results as a new column within colData colData(tse_Genus)$most_abundant &lt;- as.character(most_abundant) # Calculating percentage of the most abundant most_abundant_freq &lt;- table(as.character(most_abundant)) most_abundant_percent &lt;- round(most_abundant_freq/sum(most_abundant_freq)*100, 1) # Retrieving the explained variance e &lt;- attr(reducedDim(tse_Genus, &quot;PCoA_BC&quot;), &quot;eig&quot;); var_explained &lt;- e/sum(e[e&gt;0])*100 Interactive 3D visualization of the most dominant genus on PCoA. Note that labels at legend can be used to visualize one or more Genus separately (double click to isolate one from the others, or toggle to select multiple ones). library(plotly) # 3D Visualization reduced_data &lt;- as.data.frame(reducedDim(tse_Genus)[,]) names(reduced_data) &lt;- c(&quot;PC1&quot;,&quot;PC2&quot;,&quot;PC3&quot;) plot_ly(reduced_data, x=~PC1,y=~PC2,z=~PC3)%&gt;% add_markers(color=colData(tse_Genus)$most_abundant, size=5, colors=c(&quot;black&quot;, &quot;blue&quot;, &quot;lightblue&quot;, &quot;darkgray&quot;, &quot;magenta&quot;, &quot;darkgreen&quot;, &quot;red&quot;)) %&gt;% layout(scene=list(xaxis=list(title = paste(&quot;PC1 (&quot;,round(var_explained[1],1),&quot;%)&quot;)), yaxis=list(title = paste(&quot;PC2 (&quot;,round(var_explained[2],1),&quot;%)&quot;)), zaxis=list(title = paste(&quot;PC3 (&quot;,round(var_explained[3],1),&quot;%)&quot;)))) "],["bibliography.html", "Bibliography", " Bibliography "]]
